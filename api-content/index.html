{"posts":[{"title":"简单聊聊指令重排","content":"代码在编译阶段，编译器可能会进行重排序（Java 在编译期字节码是按代码顺序生成的，但 JIT 执行时就不保证顺序了） 代码在执行阶段，CPU 也可能会重排指令（CPU 的乱序执行，忽略不看） 比如下面这段代码 int a = a1; // a1 = 1; double b = b1; // b1 = 0.1; Java 的 JIT 在执行时，并不会保证：对 &quot;a&quot; 内存的写入一定在对 &quot;b1&quot; 内存的读取之前发生 并且，因为 &quot;整形&quot; 和 &quot;浮点型&quot; 用的运算器不同，还是可能被重排的 as-if-serial 规则 as-if-seria指令重排l 的意思是，编译器、处理器、JIT 等为了提高并行度，所有的动作(Action)都可以为了优化，而被重排序 但是，不管怎么重排序，单个线程的执行结果不能被改变。 为了遵守 &quot;as-if-serial&quot; 语义，编译器和处理器不会对存在 &quot;数据依赖关系&quot; 的操作做重排序 一个硬性规定，忽略 Java 的 happens-before 规则 准确来说是 Java 内存模型中的规则，JSR-133 使用 happens-before 的概念来指定两个操作之间的执行顺序 如果 A happens-before B，那么 Java 内存模型将向程序员保证：A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前 至于网上罗列的几条规则，都是根据 Java 内存模型总结出来的，不用刻意去记。重点理解 volatile 关键字的作用即可 详情可以查看 Doug Lea 写给编辑器开发者的文章：The JSR-133 Cookbook for Compiler Writers 参考资料 Doug Lea 的中文博客 Doug Lea 的英文博客 关于指令重排序 - V2EX Java内存访问重排序的研究 - 美团技术团队 4个你未必知道的内存小知识 MESI协议&amp;NUMA架构 ","link":"https://yibaoshan.github.io/post/concurrency-program-order/"},{"title":"Android图形系统（五）番外篇：触摸事件详解","content":" 点击跳转到掘金阅读 Android 是一个有用户界面（GUI）的操作系统，在它诞生之初，就是为带有触摸屏的手持设备准备的。作为提供给用户最重要的交互方式之一，了解触摸系统是怎么工作的，对于实际的项目开发有着非常大的帮助 本篇是图形系列的第五篇文章，在之前的几篇文章中，我们分别了解了 Android 系统[渲染/合成的底层原理]和[自定义 View / ViewGroup 的流程] 今天我们来聊聊图形系统中，另一个老生常谈的话题：事件分发 和以往相比，今天的文章会稍微有那么一点点不一样 我们会从认识硬件驱动开始，自底向上，一步步的来了解，事件是怎么到达的系统内核，内核又是怎么传递到应用，以及应用最终是如何消费掉事件的 废话不多说，我们直接进入正题，let's go 前排提醒：全文 1.5w 字，建议阅读时长 30 分钟 一、触摸事件的起源（Linux Kernel） Android 输入事件的类型，和分发的流程都比较复杂，除了触摸事件外，系统还有来自鼠标、键盘、音量键、电源键等其他 Input 设备的事件需要处理 我们日常开发接触比较多的是 ‘触摸事件’，因此，本文主要讨论的是 ‘触摸事件’ 的分发流程，其他类型的输入事件顺带会提一嘴，不是本文的重点 本文一共分为三大部分： 第一部分介绍 ‘触摸事件的起源’ ，主要讲的是驱动上报原始事件，内核解析原始事件并保存到设备文件中，以供 Framework 读取分发 第二部分介绍 ‘触摸事件的传递’ ，主要讲的是 InputManagerService 怎么把事件传递到应用进程，并分发给目标 Window 第三部分介绍 ‘触摸事件的消费’ ，这是我们应用开发者最熟悉的事件分发/拦截的过程，主要讲的是 ViewGroup / View 的几个关键方法以及使用场景 在文章的开头，我们先来聊聊第一部分的内容，触摸事件的起源 从硬件到内核 在《当我们点击“微信”应用后，它是怎么显示出来的？》这篇文章中，为了搞清楚 Android 设备的绘图硬件是什么，我们拆了一台 小米11 手机 今天，我们继续来拆小米 图片来源：【集微拆评】小米10拆解：内部布局与iPhone相似，1亿像素主摄吸睛 如上图，这是拆解后 小米10 的内部布局，图中左边黄色箭头所指的部分，是触摸屏的触控芯片 米10 触控芯片使用的是，来自意法半导体的 &quot;FJABH&quot;，这块芯片是用来干嘛的呢？ 用来和 CPU 进行通信的 图片是重绘版，参考自：https://blog.csdn.net/qq_39797956/article/details/118863217 我们知道，当我们按下触摸屏后，屏幕的电压/电流大小会发生变化（不展开讨论触摸屏工作原理） 变化的电压/电流会被图中间的触控 IC 捕获，接着计算出触摸位置的坐标值，通过I²C总线（如上图）发送到主板上的 CPU I²C 是硬件之间常用的一种通信协议，它规定了什么表示起始、停止、应答和非应答等一系列信号 当然，作为应用开发，我们无需关心他们的通信细节 我们只需要知道： &quot;一旦触摸屏的信号发生变化，触控芯片就能通过 I²C 总线通知到 CPU &quot;。了解这一点就够了 好了，现在触摸信号已经能被 CPU 读取了，接下来我们看 CPU ，也就是操作系统如何处理触摸信号 内核创建设备文件 我们都知道，Google 使用 Linux 作为 Android 系统的内核，管理着主板上的 内存、网卡、硬盘 等硬件设备，其中也包括 CPU 在上一小节中，触摸屏已经和 CPU 建立了通信。也就是说，操作系统可以读取触摸屏发送过来的信号了 接下来的工作重点分为两个部分，一是制定触摸屏具体的上报规则；二是想办法把设备发生的事件报告给应用程序 先来看设备的上报规则，我们以键盘事件举例，同样都是按下 'A' 按键 达尔优 键盘上报的是：0010 罗技 键盘上报的是：0001 同一个按键事件，两个键盘厂商上报的按键值却不相同，这显然是不行的。 所以，只有上一小节的通信规则（I²C）还不够，我们还需要制定一个内容规则，来规范各个厂家发送的数据内容 说到输入规范，这就不能不提 Linux 的 Input 子系统了 在 2001 年发布的 [2.4.0] 版本，Linux 首次加入了 Input 子系统的代码，为的就是将输入设备的共性抽象出来，制定统一的输入规则 首发版本只支持 手柄、鼠标 和 键盘 这三种硬件，在随后 2002 年发布的 [2.5.25] 版本中，加入了对 触摸屏 的支持 这样一来，厂商只需要按照 Linux 制定的规范，来上报按键值、屏幕坐标等信息即可，上报规则的问题就解决了 除了规范输入内容，Input 子系统还为应用程序提供了 操作/读取 输入设备的接口，来看框架图： 图片来源：自己画的 如图，Input 子系统分为三层： 最下层：输入设备驱动层，drivers/input/xxx，这里就是各大厂商需要遵循的协议规范，向内核层报告输入的内容 中间层：输入核心层，input.c 属于这一层。这是 Linux 核心逻辑，用来管理设备添加、卸载等操作，事件提供给应用前的准备工作 最上层：输入事件驱动层，到这里硬件驱动已经抽象为设备文件了，对应 /dev/input/xxx ，硬件驱动发送的数据就保存在该路径下的各个设备文件中，等待应用读取 最下面的 Drivers 层，是 Linux 平台对各种输入设备的规范，各大厂商都需要去遵循该协议，否则 Linux 内核无法识别，设备也就无法正常工作 然后是中间的核心层，它是输入设备驱动的管理层，在输入框架中起着承上启下的作用：向下提供驱动层的接口，向上提供事件处理层的接口 我们来看一眼 input.c 中的几个关键方法，也就大概知道它提供了哪些功能 /drivers/input/input.c class input { //Linux input 框架的核心层，为驱动层提供设备注册和操作接口 /* 设备注册 */ int input_register_device(input_dev *dev); // 注册一个 input 设备到内核 void input_unregister_device(input_dev *dev); // 从内核注销掉一个 input 设备 /* 设备连接 */ int input_attach_handler(input_dev *dev, input_handler *handler); void input_disconnect_device(input_dev *dev); /* 事件上报 */ void input_handle_event(input_dev *dev, type, code, value); /* 应用程序数据读取 */ int input_event_to_user(input_dev *dev, type, code, value); } 从代码来看，核心层负责 设备的注册、设备的连接、事件上报 和 数据读取 这几件事，具体的实现逻辑我们这里不展开讨论，太长了。 在 Input 子系统的最上层（Handlers），事件驱动层负责的是，为用户访问提供接口，将硬件驱动层发送的消息报告给用户 我们可以在 /dev/input/xxx 找到所有已加载成功的输入设备，它们就是事件驱动层创建的设备文件 图片来源：自己截的 如图所示，我手里的 Pixel 3 在 /dev/input/ 这个路径下，发现了4个输入设备，从 event0 到 event3 我们可以用 ' cat /proc/bus/input/devices ' 命令，查看每个输入设备的信息，我这台手机 event2 节点是触摸屏的设备文件（' name = fts ' 表示的触控驱动厂商是 '敦泰'） 接着，我们还可以用 'getevent' 命令打开这个设备文件，获取它发送的原始数据 图片来源：自己录的 你看，当我们滑动屏幕时，终端窗口会不停的打印来自 event2 的触摸事件消息 好，现在触摸事件已经能被应用程序读取了，我们来简单总结下第一部分 ‘触摸事件的起源’ 的内容： 首先，按下触摸屏后，触控芯片捕获到电压/电流的变化，计算出位置坐标后，通过 I²C 总线汇报给 CPU 接着，我们需要统一通信内容的规则，在 Linux 平台下，触控芯片需要实现 input.c 协议，事件按照规定的协议上报给内核系统 最后，等到设备开机，内核加载触摸屏驱动，再然后是设备的注册/连接/上报的过程 到这里，内核已经为我们收集好触摸屏的输入事件，并存放在了 eventX 设备文件中，Linux Input 子系统的任务已经完成 接下来我们看 Android 系统的框架层（Framework）是如何处理触摸事件的 二、触摸事件的传递（Android Framework） 上回书说到，触摸屏上报的事件已经保存到 /dev/input/xxx 设备文件中，那么系统接下来的任务是： 读取触摸事件，并封装成 MotionEvent / KeyEvent 对象，最后分发给正在运行的 APP 使用 ”读取“ 和 “分发” ，是 Android Framework 的主线任务 在接下来的章节中，我们将主要围绕着这两件事展开 ps：本章节的 '事件分发' 探讨的是，如何将触摸事件从设备文件传递到 APP 进程，和 View 的事件分发不是一回事儿，注意别搞混了 初识 InputManagerService 我们都知道，在 Framework 中，输入事件是由 InputManagerService（后续简称IMS） 来管理 我们又知道，InputManagerService 是 Java 层代码，不可能直接调用到 Linux 内核层的 Input 框架来获取输入事件 因此，IMS 必然需要 native 层的支持，才能实现对事件的读取与分发 实际的 InputManagerService 实现一共分为三层 native 层，这是 IMS 的核心层，负责 读取/分发 事件，EventHub.cpp、InputReader.cpp、InputDispatcher.cpp 三员大将都在这 jni 层，主要是对 natvie 做转发，另外负责创建对象啥的，不怎么需要关注 Java 层，主要负责通信部分，和 WMS 同步窗口数据啦，和 APP 跨进程通信啦等等 在这其中，只有 native 层稍微有那么一点点复杂，因为数据的读取和分发都发生在 native 层 好，接下来，我们来认识 native 层的主力人员 注意，我们本小节只关注 native 中各个角色有哪些方法功能，做了哪些事情 至于对象什么时候创建，运行在哪个进程，哪个线程，这个后面会讲到，不是本小节关注的重点 1、EventHub EventHub 的作用是监听、读取 /dev/input 目录下产生的新事件，并封装成 RawEvent 结构体供其他人使用 文件在 frameworks/native/services/inputflinger/EventHub.cpp 我们来看 EventHub 中的关键方法 //frameworks/native/services/inputflinger/EventHub.cpp class EventHub { EventHub::EventHub(void) { mEpollFd = epoll_create(EPOLL_SIZE_HINT); // 创建 epoll，用于监听设备文件是否有可读事件 mINotifyFd = inotify_init(); // 创建 inotify ，用于监听文件系统是否变化，有变化说明发生设备插拔 } size_t EventHub::getEvents( timeoutMillis, buffer, bufferSize) { //getEvents() 是 IMS 的核心，该方法一共做了两件事 // 1. 监听设备插拔动作，执行对应的设备的打开/卸载操作，并生成 RawEvent 结构通知调用者 // 2. 监听输入设备文件的事件变化 //如果没有任何事件发生，调用 epoll_wait() 函数执行等待 return event - buffer; // 返回读取到的事件数量 } } EventHub 在初始化时，会创建 mEpollFd 和 mINotifyFd 两个 Fd，利用 INotify 机制监听设备增删事件，利用 Epoll 监听设备文件读写状态变化 然后是 getEvents() 方法，这个方法用来获取当前的设备事件，包括设备数量变化，和设备上报的事件，是 IMS 获取消息的 “核心方法” 如果没有任何事件发生，getEvents() 会发生阻塞，直到有事件发生才返回 EventHub 整个过程如下图 图片来源：自己画的 2、InputReader 从类的命名就能看出来，InputReader 的职责是读取输入消息 不过，它可不是只会读取事件，拿到原始事件以后，还需要解析事件，拆解为按键、触摸屏、鼠标等，根据不同的输入，封装成不同的对象，提交到消息队列等待分发 所以，原始事件的解析、转换，最后生成 KeyEvent、MotionEvent 对象，才是 InputReader 的主要工作 /frameworks/native/services/inputflinger/InputReader.cpp class InputReader { class InputReaderThread : Thread { //内部类 /*InputReaderThread 线程启动后，循环将不断地执行 InputReader#loopOnce()函数*/ bool InputReaderThread::threadLoop() { mReader-&gt;loopOnce(); return true; } } void InputReader::loopOnce(); // 核心方法，负责读取事件，解析事件 } InputReader 类的核心方法是 InputReader#loopOnce() ，它负责读取事件和解析事件 loopOnce() 方法被 InputReaderThread 线程的 threadLoop() 所调用，InputReaderThread 是 InputReader 的内部线程类 和 Java 不同，在 C++ 中，我们只需要将 threadLoop() 返回值设置为 true，当 InputReaderThread 线程启动后， 该方法就会被循环调用，不用手动写 while(true) InputReaderThread 线程启动时机我们后面会讲到，先回过头来看 InputReader#loopOnce() 的工作 /frameworks/native/services/inputflinger/InputReader.cpp class InputReader { // 读取事件，解析事件 void InputReader::loopOnce() { int count = mEventHub-&gt;getEvents(); // 读消息，有消息返回，没消息阻塞到 epoll()。由于事件分发需要时间，所以单次读取的事件可能是多个 if(count) processEventsLocked();//解析原始事件、提交到队列等待分发 } } 关键代码只有两行 第一行是调用了 EventHub#getEvents() 获取事件，我们在上一节已经介绍过这个方法了，有消息返回，没消息阻塞到 epoll() 并且，因为执行事件分发需要时间，在上一次分发还没有执行结束之前，如果多个设备都发生了事件，或者一个设备发送了多次事件，都会造成数据的积压，getEvents() 返回的事件数量可能是多条 第二行代码 processEventsLocked() 是获取到事件以后，对原始事件进行解析，然后提交到队列等待分发 /frameworks/native/services/inputflinger/InputReader.cpp class InputReader { void InputReader::processEventsLocked(rawEvents, count) { // 遍历所有事件，解析、分发 for (const RawEvent* rawEvent = rawEvents; count;) { int32_t type = rawEvent-&gt;type; // 获取事件类型 switch (type){ // 源码不包含此 switch 逻辑，这是 InputDevice 中的内容，为了方便理解我才搬了过来 case EV_KEY; // 按键类型的事件。能够上报这类事件的设备有键盘、鼠标、手柄、手写板等一切拥有按钮的设备（包括手机上的实体按键） case EV_ABS; // 绝对坐标类型的事件。这类事件描述了在空间中的一个点，触控板、触摸屏等使用绝对坐标的输入设备可以上报这类事件 case EV_REL; // 相对坐标类型的事件。这类事件描述了事件在空间中相对于上次事件的偏移量。鼠标、轨迹球等基于游标指针的设备可以上报此类事件 case EV_SW; // 开关类型的事件。这类事件描述了若干固定状态之间的切换。手机上的静音模式开关按钮、模式切换拨盘等设备可以上报此类事件 ... } // 我们只专注 touch 触摸事件 dispatchTouches(when, policyFlags); } } void dispatchTouches(){ // 判断是否只是单指事件，或是多指触摸等等等 // 解析完成后，调用 dispatchMotion() 分发 dispatchMotion(); } void dispatchMotion(){ // 最终生成 NotifyMotionArgs 结构，交给 InputDispatcher 执行最后的分发 NotifyMotionArgs args; InputDispatcher::notifyMotion(args);//提交到 InputDispatcher } } ps：为了方便理解，我把其他分支整合到主方法来，中间还省略了许多代码。所以建议不要对照源码看这篇文章，不然你可能会因为找不到某个方法回来骂我的~ 解析事件的业务逻辑几乎都放在了 processEventsLocked() 方法 在 processEventsLocked() 方法中，首先遍历事件集合，根据不同的事件类型，调用不同的解析方法 我们只专注 touch 触摸事件，也就是 dispatchTouches() 在 dispatchTouches() 方法中，根据触摸点信息来决定，是单指还是多指事件 解析完成后，调用 dispatchMotion() 生成 NotifyMotionArgs 对象，通知 InputDispatcher#notifyMotion() 方法 当 InputDispatcher#notifyMotion() 方法被调用，也就代表着，一次读取事件，解析事件的过程就结束了 接下来就看事件是怎么分发的了，InputReader 整个过程如下图 图片来源：自己画的 3、InputDispatcher 接下来的 InputDispatcher 应该不用再介绍了，就是用来分发输入事件的 上一小节结束时放的图片，左边的 InputReader 向中间的 EventQueue 队列提交了事件消息，我先来解释一下这是什么时候发生的 /frameworks/native/services/inputflinger/InputDispatcher.cpp class InputDispatcher { void notifyMotion(const NotifyMotionArgs* args) { MotionEntry* newEntry = new MotionEntry(args);//封装成entry enqueueInboundEventLocked(newEntry);//入列一个节点，等待分发被执行，逻辑在 dispatchOnce() } } 呐，看代码 上一小节最后一行调用的 InputDispatcher#notifyMotion() 方法，作用就是把事件消息提交到消息队列，等待分发 好，尾收完了我们继续来看 InputDispatcher 类 到了 InputDispatcher 这里，原始的输入事件已经被封装成 Key 、Motion 等对象，InputDispatcher 的任务是：找到合适的 Window，并把数据传递过去 /frameworks/native/services/inputflinger/InputDispatcher.cpp class InputDispatcher { class InputDispatcherThread : Thread { bool InputDispatcherThread::threadLoop() { mDispatcher-&gt;dispatchOnce(); return true; } } void dispatchOnce() { if(!queue.isEmpty()) dispatchOnceInnerLocked();//有消息就执行分发 } } 首先来看 InputDispatcher 的 dispatchOnce() 主方法，和 InputReader 设计思路相同，InputDispatcher 也是内部有个线程类，然后循环调用 dispatchOnce() 执行分发 如果消息队列中有消息，调用 dispatchOnceInnerLocked() 执行分发 /frameworks/native/services/inputflinger/InputDispatcher.cpp class InputDispatcher { void dispatchOnceInnerLocked() { mPendingEvent = queue.dequeue(); // 从派发队列取出一个事件，简略写法 switch (mPendingEvent-&gt;type) { // 判断消息的类型：配置更改、插拔消息、key事件、触摸事件等等 case EventEntry::TYPE_MOTION: dispatchMotionLocked(); // 我们只专注 触摸事件 } } void dispatchMotionLocked() { int32_t injectionResult = findTouchedWindowTargetsLocked(); // 为 Motion 事件寻找合适的目标窗口 if (injectionResult) dispatchEventLocked(); // 如果成功地找到了可以接收事件的目标窗口，则通过dispatchEventLocked()函数完成实际的派发工作 } } 负责分发的 dispatchOnceInnerLocked() 方法需要处理不同输入类型的事件，我们这里还是只关注触摸消息 如果是触摸事件，那么触摸消息的分发是由 dispatchMotionLocked() 方法来完成的 dispatchMotionLocked() 触摸消息的分发，分为两步执行： 第一步，为 Motion 事件寻找合适的目标窗口，这个任务交给 findTouchedWindowTargetsLocked() 函数去完成 第二步，如果成功地找到了可以接收事件的目标窗口，交给 dispatchEventLocked() 函数完成实际的派发工作 接下来我们来看，findTouchedWindowTargetsLocked() 和 dispatchEventLocked() 这两个方法的实现 /frameworks/native/services/inputflinger/InputDispatcher.cpp class InputDispatcher { int findTouchedWindowTargetsLocked(){ size_t numWindows = mWindowHandles.size(); // 获取窗口集合 for (size_t i = 0; i &lt; numWindows; i++);//从前向后遍历所有的window以找出触摸的window，将满足条件的放入inputTargets，没找到返回第一个前台window } // 合适的目标窗口被确定下来之后，便可以开始将实际的事件发送给窗口了 void dispatchEventLocked(Vector&lt;InputTarget&gt;&amp; inputTargets) { InputChannel channel = inputTarget.inputChannel;//删减过的流程 channel-&gt;sendMessage(&amp;msg);//给能够被触摸的window发送跨进程消息 } } findTouchedWindowTargetsLocked() 方法的主要逻辑，是根据窗口的点击区域与事件发生的坐标点选取合适的目标窗口 代码稍微有点长，这里就不展开讨论了，感兴趣的朋友可以阅读《Window Touchable Region》这篇文章 再来看负责分发的 dispatchEventLocked() 方法，代码实现也很简单，根据窗口查找该窗口对应的 channel ，然后通过 channel 跨进程把事件传递到 APP 到这里，InputDispatcher 所有的分发工作就全部结束了，整个过程如下图 图片来源：自己画的 哎， 还没完，回头来看负责分发触摸消息的 InputDispatcher#dispatchMotionLocked() 函数 /frameworks/native/services/inputflinger/InputDispatcher.cpp class InputDispatcher { void dispatchMotionLocked() { int32_t injectionResult = findTouchedWindowTargetsLocked(); // 为 Motion 事件寻找合适的目标窗口 if (injectionResult) dispatchEventLocked(); // 如果成功地找到了可以接收事件的目标窗口，则通过dispatchEventLocked()函数完成实际的派发工作 } int findTouchedWindowTargetsLocked(){ size_t numWindows = mWindowHandles.size(); // 获取窗口集合 for (size_t i = 0; i &lt; numWindows; i++) ... } void dispatchEventLocked(Vector&lt;InputTarget&gt;&amp; inputTargets) { InputChannel channel = inputTarget.inputChannel; channel-&gt;sendMessage(&amp;msg);//给能够被触摸的window发送跨进程消息 } } 再看一遍源码，我们来思考两个问题 🤔 负责查找窗口的 findTouchedWindowTargetsLocked() 方法中，mWindowHandles 所持有的窗口集合，是从哪里来的？ 负责通信的 dispatchEventLocked() 方法中，InputChannel 是什么？IMS 是什么时候和 APP 建立通信的？ 回想一下，在 InputDispatcher 之前，不管是 EventHub ，还是 InputReader ，我们一直都是在和 Linux 内核打交道，读取事件、解析事件啥的 但到了 InputDispatcher 这里，突然和应用程序产生了联系 findTouchedWindowTargetsLocked() 的窗口集合从哪里来的？ dispatchEventLocked() 又是如何把触摸事件通知到 APP 进程的？ 带着这两个疑问，我们开始进入 InputManagerService 的启动流程环节，这里面一定有我们要寻找的答案 启动 InputManagerService 我们知道，InputManagerService 作为运行在 SystemServer 进程中的服务，启动顺序是排在 Zygote 进程之后的 Java 虚拟机初始化完成后，再由 Zygote 进程 fork 而来 本小节我们将要来跟踪 InputManagerService 的启动流程，中间会涉及到一些没那么重要的类（重要的都在上面介绍过了） 比如，同为在 /frameworks/native/services/inputflinger 包下面的 InputManager 类，我们在介绍 native 层成员的时候就没有带上它 因为 InputManager 只是负责管理 reader 和 dispatcher 线程 ，没有业务逻辑，不是很重要 在整个 IMS 的启动流程中，我们时刻要谨记，本节的重点是： 了解 InputManagerService 大致的启动流程 了解 InputDispatcher 的窗口集合从哪里来，以及 IMS 如何建立跟 APP 通信的？ 搞清楚这两个关键问题， IMS 启动流程这 part 就可以翻篇了，千万别被陷入到源码中，很难出来的~ 1、IMS 窗口集合从哪里来？ 在前两节我们了解到，InputManagerService 可以分为 native、jni、Java 三层 这三层大致的启动顺序是：先从 Java 层的初始化开始，再调用到 jni 层，由 jni 拉起 native 的各个类，进而完成 native 部分的初始化，最后返回到 Java 层，IMS 开始为各个 APP 提供服务 我们先来看 Java 层的初始化工作 /frameworks/base/services/java/com/android/server/SystemServer.java class SystemServer { private void startOtherServices() { inputManager = new InputManagerService(context); // 创建 IMS 对象 ... //将 InputMonitor 对象保存到 IMS 对象 inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); inputManager.start(); } } 在 SystemServer#startOtherServices() 启动服务的方法中，首先创建了 InputManagerService 对象 然后，将 WindowManagerService 中的 InputMonitor 对象保存到 IMS 中 这是 InputMonitor 类是干嘛的？之前好像没见过 简单来说，它是连接 WMS 和 IMS 的枢纽。WMS 通过 InputMonitor.java 持有了 IMS 的引用，当窗口信息发生变化后，通过 InputMonitor#updateInputWindowsLw() 方法，将新的窗口集合更新到 IMS 中，IMS 又将窗口集合同步到 InputDispatcher 我们本小节的目标之一，是为了搞清楚 InputDispatcher 持有的窗口集合从哪里来？ 现在，答案有了，是 WMS 通过调用 InputMonitor#updateInputWindowsLw() 函数，最终同步到 InputDispatcher 类中 简单说一下查找过程 先回到 InputDispatcher 源码，搜索 mWindowHandles 关键字，很容易就能发现了 mWindowHandles 集合是在 setInputWindows() 函数中被赋值 /frameworks/native/services/inputflinger/InputDispatcher.cpp class InputDispatcher { void InputDispatcher::setInputWindows(inputWindowHandles) { mWindowHandles = inputWindowHandles; } } 那么 setInputWindows() 是谁调用的？接着搜索 Framework ，结果如图 图片来源：aospxref.com/android-7.1.2 我们发现，Java 层的 IMS 也有一个 setInputWindows() 方法，并通过 JNI 指向了 native 中的 InputDispatcher#setInputWindows() 最终的调用动作就发生在 InputMonitor 类的 updateInputWindowsLw() 方法中！ 好了，InputDispatcher 持有的窗口集合来源，这个疑问已经解决了。我们继续来跟启动流程 /frameworks/base/services/java/com/android/server/SystemServer.java class SystemServer { private void startOtherServices() { inputManager = new InputManagerService(context); inputManager.start(); } } /frameworks/base/services/core/java/com/android/server/input/InputManagerService.java class InputManagerService { // 【step 1.0】初始化流程 public InputManagerService(Context context) { mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); LocalServices.addService(InputManagerInternal.class, new LocalService()); } // 【step 2.0】 启动流程 public void start() { nativeStart(mPtr); // 详见 【2.1】 Watchdog.getInstance().addMonitor(this); } } 在 SystemServer 创建完 InputManagerService 对象后，紧接着就调用了 inputManager#start() 启动了服务 所以我们需要把启动流程分为两个步骤来看，一个是初始化流程做了什么，第二个才是启动流程 在 InputManagerService 的构造函数中，调用了 nativeInit() 执行了初始化工作，这是个 jni 方法，我们一起去看看源码实现 2、IMS 的初始化工作 /frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp class NativeInputManager { static jlong nativeInit(env, jclass, serviceObj, contextObj, messageQueueObj) { NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,messageQueue-&gt;getLooper()); } NativeInputManager::NativeInputManager(contextObj, serviceObj, looper) { sp&lt;EventHub&gt; eventHub = new EventHub(); // 创建 EventHub 对象 mInputManager = new InputManager(eventHub, this, this); // 创建 InputManager 对象 } } nativeInit() 方法中创建了 NativeInputManager 对象 在 NativeInputManager 的构造函数中，又创建了两个我们熟悉的对象，EventHub 和 InputManager EventHub 在前面已经介绍过了，负责监听事件变化，并对外提供获取事件变化的接口 InputManager 也提到过，负责创建 Reader 和 Dispatcher 两线程，没什么逻辑 /frameworks/native/services/inputflinger/EventHub.cpp class EventHub { EventHub::EventHub(void) { mEpollFd = epoll_create(EPOLL_SIZE_HINT); // 创建 epoll，用于监听设备文件是否有可读事件 mINotifyFd = inotify_init(); // 创建 inotify ，用于监听文件系统是否变化，有变化说明发生设备插拔 } } /frameworks/native/services/inputflinger/InputManager.cpp class InputManager { InputManager::InputManager(eventHub, readerPolicy, dispatcherPolicy) { mDispatcher = new InputDispatcher(dispatcherPolicy); mReader = new InputReader(eventHub, readerPolicy, mDispatcher); initialize(); } void InputManager::initialize() { mReaderThread = new InputReaderThread(mReader); //创建线程 “InputReader” mDispatcherThread = new InputDispatcherThread(mDispatcher); //创建线程 ”InputDispatcher“ } } 呐，你看 EventHub 只是创建了 mEpollFd 和 mINotifyFd 两个 Fd 对象 InputManager 也只是创建了 InputReader 和 InputDispatcher 两个对象，然后创建了 InputReaderThread 和 InputDispatcherThread 两个线程 好了，现在 IMS 底层的三员大将：EventHub、InputReader、InputDispatcher 全部成功创建，IMS 类的初始化工作就全部结束了 3、IMS 的启动流程 我们把 SystemServer 的代码再拿出来看看，看看接下来应该做什么 /frameworks/base/services/java/com/android/server/SystemServer.java class SystemServer { private void startOtherServices() { inputManager.start(); } } /frameworks/base/services/core/java/com/android/server/input/InputManagerService.java class InputManagerService { public InputManagerService(Context context); // 初始化工作已完成 public void start() { nativeStart(mPtr); // 启动服务 Watchdog.getInstance().addMonitor(this); } } 初始化工作完成以后，紧接着调用了 start() 方法启动了服务 start() 内部调用了 nativeStart() 方法，这又是个 jni 函数，我们继续向下跟 /frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp class NativeInputManager { static void nativeStart(env, jclass , ptr) { getInputManager()-&gt;start(); // 调用 InputManager 的 start() 方法 } } /frameworks/native/services/inputflinger/InputManager.cpp class InputManager { status_t InputManager::start() { result = mDispatcherThread-&gt;run(&quot;InputDispatcher&quot;, PRIORITY_URGENT_DISPLAY); // 启动线程“InputReader” result = mReaderThread-&gt;run(&quot;InputReader&quot;, PRIORITY_URGENT_DISPLAY); // 启动线程”InputDispatcher“ ... return OK; } } nativeStart() 内部调用了 InputManager#start() ，启动了 InputReaderThread 和 InputDispatcher 线程 这俩线程我们已经见过了，启动后，InputReaderThread 循环读消息，读到消息解析，生成 Event 对象，提交到事件队列，等待分发 InputDispatcher 循环派发消息，一直从事件队列中取 Event 消息，派发给合适的窗口 到这里， IMS 的启动工作就全部结束了，整个过程如下图 图片来源：自己画的 IMS 启动流程稍微有那么一点点长，完整的启动分析我放在了 GitHub ，点击[这里]跳转查看 启动 APP 进程 在上一小节 InputManagerService 的启动流程中，我们解决了“ InputDispatcher 的窗口集合从哪里来” 的问题 现在还剩下 “ APP 是如何和 IMS 建立通信的 ” 这个问题还没有解决 系统服务全部准备就绪后，接下来是 APP 应用的启动流程，在跟踪启动应用进程的过程中，我们会找到 “ APP 是如何和 IMS 建立通信的 ” 这个问题的答案 1、为 Activity 分配窗口 APP 的启动过程我们应该都多少有点了解，和 AMS 通信怎么创建进程这部分我们就跳过了，本篇重点是触摸事件，我们直接快进到为 Activity 设置视图，分配窗口这部分内容 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { InputChannel mInputChannel; // 保存的是 client 端的 socket void setView(View view){ mInputChannel = new InputChannel(); // 创建了空的 InputChannel ，下面代码将会生成真实的 InputChannel Session.addToDisplay(view,mInputChannel);//向wms添加窗口 if(mInputChannel!=null) mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); } } 我们在 Activity 设置的视图文件，最终会调用到 ViewRootImpl#setView() 方法 在 setView() 方法中，一共有三行关键代码 创建了属于该视图的 InputChannel 空对象，先不用管 向 WMS 添加窗口，并将刚刚创建的 InputChannel 对象一并传递过去，重要逻辑 创建了 WindowInputEventReceiver ，将该视图的 InputChannel 保存起来，也不用管 在这三行代码中，第2行是关键代码，第1行和第3行，以现有的信息没办法解释它们内部做了什么，等到后面有机会在介绍 好，我们来看第2行代码发生了什么 /frameworks/base/services/core/java/com/android/server/wm/Session.java class Session { void addToDisplay(InputChannel inputChannel){ WindowManagerService.addWindow(inputChannel); } } /frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java class WindowManagerService { int addWindow(InputChannel outInputChannel){ WindowState win = new WindowState(); // 首次添加视图时创建，用于描述一个window win.openInputChannel(outInputChannel); // 创建通信的关键代码，打开一对已连接的 socket } } Session#addToDisplay() 方法只是做了转发，实际创建窗口的工作还是由 WindowManagerService#addWindow() 来完成的 在 addWindow() 方法中，首先创建了 WindowState 对象，用于描述该窗口信息 随后调用了 WindowState 对象中的 openInputChannel() 方法，它是创建通信的关键代码，内部是创建了一对已连接的 socket 我们来重点关注 WindowState#openInputChannel() 方法 /frameworks/base/services/core/java/com/android/server/wm/WindowState.java class WindowState { InputChannel mInputChannel; InputChannel mClientChannel; void openInputChannel(InputChannel outInputChannel) { InputChannel[] inputChannels = InputChannel.openInputChannelPair(); // 返回一对已连接的 socket // 这是一对已连接的管道，将 socket 两端分别保存到服务端和客户端即可进行通信 mInputChannel = inputChannels[0]; // 下标为0的传递给 IMS 服务端，服务端可通过该 socket 向窗口发送消息 mClientChannel = inputChannels[1]; // 下标为1的回传给 client 端 // 1. Client 端 InputChanenl 调用 transforTo() 方法传给 ViewRootImpl 的 mInputChannel mClientChannel.transferTo(outInputChannel); // 2. Server 端 InputChannel 存在 WindowState 的 mInputChannel 变量 InputManagerService.registerInputChannel(mInputChannel); } } /frameworks/native/libs/input/InputTransport.cpp status_t InputChannel::openInputChannelPair(name,outServerChannel,outClientChannel) { int sockets[2] = socketpair(sockets); serverChannelName.append(&quot; (server)&quot;); outServerChannel = new InputChannel(serverChannelName, sockets[0]); clientChannelName.append(&quot; (client)&quot;); outClientChannel = new InputChannel(clientChannelName, sockets[1]); return OK; } WindowState#openInputChannel() 中，首先调用了 InputChannel#openInputChannelPair() 函数创建两个 InputChannel，其内部调用 Linux 的 socketpair() 函数 socketpair() 是 Linux 提供的一种进程间通信的方式，跟 pipe() 函数是类似的。但 pipe() 创建的匿名管道是半双工的，而 socketpair() 可以认为是创建一个全双工的管道： 我向我持有的 socket 中写数据，你在你持有的 socket 中能够读到数据，反过来也一样，即两端都可以对自己持有的 socket 进行读写 在触摸事件的传递中，Google 团队使用了 socketpair() 创建一对已连接的 socket ，用于 IMS 和 APP 间跨进程通信 其中，IMS 会持有名为 server 的一端（sockets[0]）进行读写； APP 持有名为 client 的一端（sockets[1]）进行读写 提个醒，我们现在看的代码是：设置 Activity 视图时，经过 binder 通信后，跑在了 system_server 进程中的 WMS 服务里 因此，我们接下来的任务，是把 sockets[0] 的 server 端，传递给 IMS ，让触摸事件发生后， IMS 能够通知到 APP 然后，把 sockets[1] 的 client 端通过 binder 跨进程回传给 APP 进程保存，让 APP 能够接收到来自 IMS 的消息 好，开始干活 2、sockets[1] 回传给 APP 源码里是先将 Client 的回传给 APP 进程，那我们就按照源码的顺序来看，先把属于 APP 进程的 socket / InputChannel 回传过去 /frameworks/base/services/core/java/com/android/server/wm/WindowState.java class WindowState { void openInputChannel(InputChannel outInputChannel) { // 1. Client 端 InputChanenl 调用 transforTo() 方法传给 ViewRootImpl 的 mInputChannel mClientChannel.transferTo(outInputChannel); // 2. Server 端 InputChannel 存在 WindowState 的 mInputChannel 变量 InputManagerService.registerInputChannel(mInputChannel); } } /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { InputChannel mInputChannel; // 保存的是 client 端的 socket void setView(View view){ mInputChannel = new InputChannel(); // 创建了空的 InputChannel try { Session.addToDisplay(view,mInputChannel); } catch (RemoteException e) { mInputChannel = null; } ... if(mInputChannel != null ) mInputEventReceiver = new InputEventReceiver(mInputChannel, Looper.myLooper()); } } 看代码，Session#addToDisplay() 是将我们设置的视图，和刚刚创建的空的 mInputChannel 传递到 WindowManagerService 如果 WMS 成功添加了视图，没有发生异常，表示属于 APP 端的 socket / InputChannel 已经创建成功并通过 binder 跨进程传递回来了，此时 mInputChannel 变量就不是刚刚创建的空对象了，里面已经包含了 APP 端的 socket 监听这个 socket ，我们可以收到来自 IMS 的消息；往这个 socket 写数据，IMS 也可以收到我们发送的消息，美滋滋 如果 WMS 添加视图失败了，会抛出 RemoteException 远程连接异常，mInputChannel 变量将被清空。 总之，只要 mInputChannel 变量不为空，就表示属于 APP 端的 socket 已经传回来了， WMS 和 APP 中间的传递过程我们先不管 好，现在 APP 端的 InputChannel 已经回传成功，下一步的代码是创建了 InputEventReceiver 对象，并将 APP 端的 InputChannel 和 APP 端的 Looper 一同传递过去 一起来看 InputEventReceiver 的代码 /frameworks/base/core/java/android/view/InputEventReceiver.java class InputEventReceiver { public InputEventReceiver(InputChannel inputChannel, Looper looper) { mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this),inputChannel, looper.getQueue()); } } java 层的 InputEventReceiver 只是个空壳子，实际的实现在 native 层，继续向下跟 /frameworks/base/core/jni/android_view_InputEventReceiver.cpp class NativeInputEventReceiver { static jlong nativeInit(env, clazz, receiverWeak, inputChannelObj, messageQueueObj) { // 简略写法 int fd = inputChannelObj-&gt;getFd(); messageQueueObj-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); ... } } 代码我又合并过，关键代码就两行 第一行是利用 inputChannelObj 对象获取里面的 socketfd 第二行是利用 messageQueueObj 对象获取里面的 Looper ，把上一步拿到的 socketfd 丢进去监听 代码虽然不多，但理解这两行代码，需要对 Handler 机制比较熟悉，包括 native 层 我来简单解释一下： 在《Android组件系列：再谈Handler机制（Native篇）》这篇文章中，我们了解到：在 native 层同样拥有一套 Looper 机制。这套 Looper 不但可以处理 native 层消息，还支持监听 自定义 fd，这是本小节的重点 Java 层的 MessageQueue 在初始化时，会调用 nativeInit() 方法，同步创建 naive 层的 NativeMessageQueue 对象，并将返回的 native 引用保存到 mPtr 变量中 注意看，我们现在跟踪的 NativeInputEventReceiver 构造函数的入参，传递过来的参数一个是 InputChannel ，里面包含了属于 APP 端的 socket，还有一个参数是来自 Java 层的 MessageQueue 对象 那么，NativeInputEventReceiver#nativeInit() 方法里完成的事情是：利用 Java MessageQueue 的 mPtr 变量持有的 NativeMessageQueue 对象，找到 native Looper 然后，利用 native 层的 Looper 对象来监听一同传递过来的 InputChannel 中的 socketfd 。 这一段听起来可能会有点绕，暂时没理解某个点问题也不大，我们只需要知道，在设置视图的时候，顺便创建了和 IMS 通信的通道就行了 好了，APP 端的 socket（sockets[1]） 回传工作算是结束了，接下来我们看怎么把 sockets[0] 传递给 IMS 3、sockets[0] 传递到 IMS IMS 端的 socket 最终是由 InputDispatcher 来保管，因为分发事件时，是 InputDispatcher 直接使用 socket 通知 APP 的 所以，我们本小节的目标是：搞清楚 IMS 端的 socket 是如何传递到 InputDispatcher 类中的？ IMS 传递的起点，依旧是在 WindowState#openInputChannel() 方法中： /frameworks/base/services/core/java/com/android/server/wm/WindowState.java class WindowState { void openInputChannel(InputChannel outInputChannel) { // 1. Client 端 InputChanenl 调用 transforTo() 方法传给 ViewRootImpl 的 mInputChannel mClientChannel.transferTo(outInputChannel); // 2. Server 端 InputChannel 存在 WindowState 的 mInputChannel 变量 InputManagerService.registerInputChannel(mInputChannel); } } /frameworks/base/services/core/java/com/android/server/input/InputManagerService.java class InputManagerService { void registerInputChannel(){ nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false); } } InputManagerService#registerInputChannel() 又是一个空壳，具体实现在 native ，继续向下跟 /frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp class NativeInputManager { void nativeRegisterInputChannel(){ InputManager-&gt;getDispatcher()-&gt;registerInputChannel(inputChannel, inputWindowHandle, monitor); } } /frameworks/native/services/inputflinger/InputDispatcher.cpp class InputDispatcher { status_t InputDispatcher::registerInputChannel(inputChannel,inputWindowHandle,monitor){ // 将代表窗口通信的 inputChannel ，以及代表窗口信息的 inputWindowHandle 封装成 Connection 对象 sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor); mConnectionsByFd.add(fd, connection); ... // 省略 IMS 监听来自 client 的代码，这部分是处理 ANR 的逻辑 } } NativeInputManager#nativeRegisterInputChannel() 随手又是一个转发 在 InputDispatcher#registerInputChannel() 方法中，经过一番长途跋涉，最终将 socket 注册到 InputDispatcher，一起被注册过来的还有代表该窗口信息的 inputWindowHandle 代表窗口通信的 inputChannel ，以及代表窗口信息的 inputWindowHandle 被封装成 Connection 对象，保存到 mConnectionsByFd 集合中 至此，IMS 端的 socket 传递工作结束，APP 和 IMS 可以愉快的通信了 整个过程如下 图片来源：自己画的 触摸事件到达 ViewRootImpl 好了，万事俱备，只欠东风 现在 APP 进程起来了，APP 和 IMS 也成功建立了通信，接下来我们按下屏幕，看看触摸事件是怎么到达我们熟悉的 View 的 /frameworks/base/core/jni/android_view_InputEventReceiver.cpp class NativeInputEventReceiver { static jlong nativeInit(env, clazz, receiverWeak, inputChannelObj, messageQueueObj) { // 简略写法 int fd = inputChannelObj-&gt;getFd(); messageQueueObj-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); ... } } 在介绍 APP 端的 socket 回传一节中，最后一步停在了 NativeInputEventReceiver#nativeInit() 方法，利用 Looper 监听了 socketfd 现在我们来聊聊：当 socketfd 有消息时，APP 端会怎么处理，事件是怎么分发到根 View 的？ /frameworks/base/core/jni/android_view_InputEventReceiver.cpp class NativeInputEventReceiver { int NativeInputEventReceiver::handleEvent( receiveFd, events, data) { switch (type) { // 简略写法，这是 consumeEvents() 方法中的逻辑 case AINPUT_EVENT_TYPE_KEY: { inputEventObj = factory-&gt;createKeyEvent(); // 转换为按键类型事件 KeyEvent } case AINPUT_EVENT_TYPE_MOTION: { inputEventObj = factory-&gt;createMotionEvent(); // 转转为触摸类型事件 MotionEvent } } env-&gt;CallVoidMethod(receiverObj.get(),dispatchInputEvent, seq, inputEventObj); // 回调到 Java } } APP 端的 socketfd 发生事件变化时，Looper 根据指定的回调地址，调用到 NativeInputEventReceiver#handleEvent() 方法 在 NativeInputEventReceiver#handleEvent() 方法中，根据事件类型，创建不同的事件对象 最后，利用 CallVoidMethod 回调 Java 方法，将事件传递到 Java 层的 InputEventReceiver#dispatchInputEvent() 方法 /frameworks/base/core/java/android/view/InputEventReceiver.java abstract class InputEventReceiver { // Called from native code. private void dispatchInputEvent(int seq, InputEvent event) { onInputEvent(event); } } /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl extends InputEventReceiver { class WindowInputEventReceiver extends InputEventReceiver { @Override public void onInputEvent(InputEvent event) { enqueueInputEvent(event, this, 0, true); } } void enqueueInputEvent(InputEvent event,InputEventReceiver receiver, int flags, boolean processImmediately) { ... // 执行消息入列以后，接着还有一个比较复杂的流水线过程，我们这里先不关心，直接来看 processPointerEvent() 方法 // input 消息到达 ViewRootImpl 后，Google 使用责任链的模式，将输入事件拆分为 KeyEvent 和 MotionEvent 两种类型，做进一步的处理 // if(event.getType == input) processPointerEvent(event); if(event.getType == key) processKeyEvent(event); } // 责任链模式，每个 InputStage 负责不同的功能，链中的某个 InputStage 的结果会影响对下一节点的执行，或停止继续分发等 // 在 ViewRootImpl#setView() 函数中指定责任链的前后顺序，这里不展开讨论，请查看参考资料列表中《这一次，带你彻底弄懂 Android 事件分发机制(外/内层责任链)》 class InputStage { // 在 ViewRootImpl 中有好几个同名 processPointerEvent() 方法， eventTarget 通常是 ViewRootImpl 保存的 DecorView 对象，也就是会调用到 View#dispatchPointerEvent() 方法 private int processPointerEvent(QueuedInputEvent q) { MotionEvent event = (MotionEvent)q.mEvent; final View eventTarget = mView; // 通常是 DecorView boolean handled = eventTarget.dispatchPointerEvent(event); ... return handled ? FINISH_HANDLED : FORWARD; } private int processKeyEvent(QueuedInputEvent q) { KeyEvent event = (KeyEvent)q.mEvent; mView.dispatchKeyEvent(event) final View eventTarget = mView; // 通常是 DecorView boolean handled = eventTarget.dispatchPointerEvent(event); ... return handled ? FINISH_HANDLED : FORWARD; } } } InputEventReceiver 是抽象类，在 dispatchInputEvent() 方法中回调 onInputEvent() 方法。 而 ViewRootImpl 的内部类 WindowInputEventReceiver 实现了 InputEventReceiver 类，并且在 onInputEvent() 内部又调用了 enqueueInputEvent() 入列输入消息 所以，接下来的分发逻辑全部都发生在 ViewRootImpl#enqueueInputEvent() 方法中 胜利的曙光就在前方，继续冲 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl extends InputEventReceiver { void enqueueInputEvent(InputEvent event,InputEventReceiver receiver, int flags, boolean processImmediately) { if(event.getType == input) processPointerEvent(event); if(event.getType == key) processKeyEvent(event); } class InputStage { private int processPointerEvent(QueuedInputEvent q) { MotionEvent event = (MotionEvent)q.mEvent; final View eventTarget = mView; // 通常是 DecorView boolean handled = eventTarget.dispatchPointerEvent(event); ... return handled ? FINISH_HANDLED : FORWARD; } private int processKeyEvent(QueuedInputEvent q);// 处理 key 事件，忽略 } } input 消息到达 ViewRootImpl 后，将输入事件拆分为 KeyEvent 和 MotionEvent 两种类型，做进一步的处理 Google 团队使用了责任链模式来处理事件消息，每个 InputStage 负责不同的功能，链中的某个 InputStage 的结果会影响对下一节点的执行，或停止分发等 ViewRootImpl#setView() 函数中指定了责任链执行的前后顺序，我们这里不展开讨论，感兴趣的同学可以查看参考资料列表中《这一次，带你彻底弄懂 Android 事件分发机制(外/内层责任链)》 为了省事，我们直接看 processPointerEvent() 处理触摸事件的方法 在 processPointerEvent() 方法中，先是将 InputEvent 强转为 MotionEvent ，然后，调用 mView 的 dispatchPointerEvent() 方法执行分发 触摸事件到达 DecorView 了解 Window 创建流程的朋友肯定知道，mView 就是 DecorView ，那这里其实调用的是 DecorView#dispatchPointerEvent() 执行分发，接着来跟踪 /frameworks/base/core/java/android/view/View.java class View { public final boolean dispatchPointerEvent(MotionEvent event) { if (event.isTouchEvent()) { return dispatchTouchEvent(event); } else { return dispatchGenericMotionEvent(event); } } } DecorView 继承自 FrameLayout ，FrameLayout 继承自 ViewGroup ，ViewGroup 继承自 View View 的 dispatchPointerEvent() 是 final 关键字修饰的，不允许子类重写 所以，调用 DecorView#dispatchPointerEvent() 实际的执行者是 View 在 View#dispatchPointerEvent() 方法中，首先判断是不是触摸事件，那肯定是啊 接着调用 dispatchTouchEvent() 方法执行分发 dispatchTouchEvent() 没有被 final 修饰，可以被重写，所以我们现在回到 DecorView 的 dispatchTouchEvent() 方法中 /frameworks/base/core/java/com/android/internal/policy/DecorView.java class DecorView extends FrameLayout { @Override public boolean dispatchTouchEvent(MotionEvent ev) { Window.Callback cb = mWindow.getCallback(); // 给 Activity 和 Dialog 拦截事件的机会 return cb != null ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); } } 在 DecorView#dispatchTouchEvent() 方法中，先是判断了 mWindow 持有的 Callback 是否为空 这里临时补充两个小细节 Window.Callback 是个接口，而 Activity 和 Dialog 都实现了这个接口 DecorView 持有的 mWindow 的赋值路径是这样的：PhoneWindow#setContentView() -&gt; installDecor() -&gt; generateDecor() -&gt; DecorView#setWindow()，不展开讨论了 接着看代码，如果 mWindow 的 Callback 不为空，则优先调用 Callback 的 dispatchTouchEvent() 函数执行分发 我们以 Activity 来举例 /frameworks/base/core/java/android/app/Activity.java class Activity { public boolean dispatchTouchEvent(MotionEvent ev) { if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } public boolean onTouchEvent(MotionEvent event) { ... } } /frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java class PhoneWindow { public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } } /frameworks/base/core/java/com/android/internal/policy/DecorView.java class DecorView extends FrameLayout { public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } } Activity 的 dispatchTouchEvent() 方法被调用后，先调用了 getWindow().superDispatchTouchEvent(ev) 执行分发，没人处理再调用自身的 onTouchEvent() 方法 而 getWindow().superDispatchTouchEvent() 方法兜兜转转一圈，还是调用到 DecorView#superDispatchTouchEvent() 中 前面说过了，DecorView 继承自 FrameLayout ，FrameLayout 是没有重写 dispatchTouchEvent() 方法的，FrameLayout 继承自 ViewGroup ，ViewGroup 重写了 dispatchTouchEvent() 所以，最终执行分发的还是 ViewGroup#dispatchTouchEvent() 方法 合着绕了一圈，Activity 是啥也没做是吧？ ummmm~ 是的 不过，我觉得这样的设计是在给 Activity / Dialog 拦截事件的机会，毕竟如果我们在 Activity 中重写了 dispatchTouchEvent() 方法，是可以让整棵 View 树都接收不到触摸事件的 好，现在触摸事件分发的起点到了我们非常熟悉的 ViewGroup#dispatchTouchEvent() 这里 接下来的一整章，我们来复习 View / ViewGroup 事件分发的流程 三、触摸事件的消费（Application） 在之前的两节内容中，一个 input 事件一路从硬件驱动，成功的到达应用的 DecorView 我们接下来的任务是，把这个事件分发给某个具体的 View 或者是 ViewGroup 正文开始前，我们先来聊聊触摸事件的本体：MotionEvent MotionEvent 表示一个触摸事件，里面包含了事件的类型，触摸的位置信息等，对分发者来说，事件的类型非常重要，来简单认识一下 ACTION_DOWN： 按下屏幕 ACTION_MOVE：手指滑动 ACTION_UP：抬起手指，离开屏幕 ACTION_CANCEL：非正常抬起，几乎等同于 ACTION_UP ，通常是父视图拦截 ACTION_POINTER_DOWN：多指触摸，表示已经有一只手指按下时，另有一只手指再次按下 ACTION_POINTER_UP：多指触摸，表示屏幕上已经有多个手指，抬起其中一只手指后触发的事件 几种常用触摸的类型就这么多，最后两种是多指触摸的情况下才会收到的事件类型，本文我们不打算讨论多指触摸（包括 TouchTarget），所以后面会忽略掉 在一次事件分发中，以每个 DOWN 事件为开始， UP / CANCEL 事件为停止，在 DOWN -&gt; MOVE -&gt; MOVE -&gt; UP / CANCEL 整个过程看做是一个事件序列 ViewGroup 的消费、分发、拦截与放行 在进入 ViewGroup 的源码之前，我们先来思考一个问题：什么是事件分发？ 我们都知道，在 Android 图形系统中，主要绘图的任务是交给 View 去完成的，ViewGroup 是作为管理视图的容器，它的任务是按照一定的规则摆放子 View，自身则基本不参与绘图操作 但是在触摸事件的分发中，ViewGroup 对触摸事件的态度就变了，因为它和子 View 一样，都可能需要响应触摸事件 1、ViewGroup 四种场景 举个例子，有一个可以纵向滑动的 ViewGroup ，里面摆满了 TextView ，用户在滑动屏幕时，肯定是期望展示更多内容的。那么这时候，就需要 ViewGroup 对子 View 重新布局摆放，将隐藏在屏幕底部的子 View 显示出来 图片来源：自己录的 上面的场景中，ViewGroup 必须要拿到用户滑动屏幕的数据，才能计算展示多少视图才算合适 即，ViewGroup 需要消费触摸事件 再举个例子，在一个不支持滑动的 ViewGroup 中，有个居中显示的 Button 按钮 图片来源：自己录的 用户按下屏幕后，ViewGroup 肯定比自己的子 View 要优先拿到触摸事件 而 ViewGroup 自身又不需要这个事件，那么，它就需要根据触摸位置去查找，有没有子 View 需要该事件 经过计算，如果发现用户按偏了，没点到 Button ，那就不管了，dispatchTouchEvent() 返回 false ，爱谁消费谁消费，反正我不要 如果发现用户按到了中间的 Button ，这时候 ViewGroup 就需要把这个事件交给 Button ，询问子 View 要不要消费 即， ViewGroup 需要分发事件 再再举个例子，在一个支持纵向滑动的 ViewGroup 中，有个居中显示的 Button 按钮 现在，用户按下了屏幕中的 Button ，ViewGroup 觉得不是滑动事件，就把这个事件分发给了 Button 但是用户在按下 Button 后，接着又开始滑动屏幕了 图片来源：自己录的 此时的 ViewGroup 需要计算滑动距离，所以是需要这个触摸事件的，那只能对不起 Button 了，ViewGroup 会把本来准备分发给 Button 的事件拦截消费掉 即，ViewGroup 需要拦截事件 另外，我们还需要考虑一种极端情况：如果子 View 和 ViewGroup 都需要触摸事件，应该怎么处理？ 按正常的拦截逻辑，ViewGroup 先拿到事件，自己又有消费的需求，肯定是紧着自己用 但是，总会有场景需要将事件优先分发给子视图，比如： 在一个支持纵向滚动的 ViewGroup ，它的两个子 View 同样是支持纵向滚动的 ViewGroup ，两个子 View 分别都包含若干 TextView 现在的需求是：长按某一个 TextView 时，允许该 TextView 上下自由拖动 图片来源：自己录的 当用户长按 TextView 移动时，预期是移动这个 TextView，理论上这个移动事件应该被 TextView 的爸爸消费掉，因为需要重新布局绘制； 但实际上是 TextView 的爷爷消费掉的，因为爷爷觉得用户是在滑动屏幕，要把屏幕下方更多的视图显示出来 ViewGroup 和 ViewGroup 中的子 View 都想要消费事件（滑动冲突），这时候该怎么办？ 很简单，我们需要创建一种机制，让 ViewGroup 知道子 View 也需要这个事件 我们暂且把这套机制称之为 “请求放行” 好了 ViewGroup 为子 View 开放一个请求放行的接口，当 ViewGroup 收到来自子 View 的放行请求时，优先将事件分发给子 View，这样，问题就解决了 触摸事件的消费、拦截、放行与分发，这四种情况几乎覆盖了 ViewGroup 对触摸事件处理（单指）的所有场景 好，现在 ViewGroup 的需求基本上了解清楚了，接下来我们来看源码中， Google 是怎么进行代码设计的 2、事件的放行和拦截 第二章结束时，最终调用停在了 ViewGroup#dispatchTouchEvent() 方法，这也是整个 View / ViewGroup 事件分发的起源 /frameworks/base/core/java/android/view/ViewGroup.java class ViewGroup extends View { public boolean dispatchTouchEvent(MotionEvent ev) { int actionMasked = ev.getAction() &amp; MotionEvent.ACTION_MASK; TouchTarget newTouchTarget = null; boolean intercepted; boolean handled = false; if (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null) { // 检查子视图是否调用了 requestDisallowInterceptTouchEvent(true) 请求放行 boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); // 子视图未请求放行，询问 ViewGroup 自身是否需要消费 } else { intercepted = false; } } else { intercepted = true; // 如果 mFirstTouchTarget 为空，并且事件类型不为 DOWN ，表示先前的事件也是 ViewGroup 自己消费的，无需执行分发，再次交给自己执行即可 } return handled; } public boolean onInterceptTouchEvent(MotionEvent ev) { //询问 ViewGroup 自身是否需要处理事件 return false; } public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } } } ViewGroup 的几种场景我们已经在上面介绍过了，接下来就是对照源码解释的过程，比较轻松 在事件分发的开始，先是判断了事件是否是 DOWN 类型，或者 mFirstTouchTarget 变量是否不为空（mFirstTouchTarget 记录的是消费上一次 DOWN 事件的是谁） 满足条件则进入 “检查放行” 和 “检查是否要拦截” 的逻辑 disallowIntercept 为 true ，表示子视图是否调用了 requestDisallowInterceptTouchEvent(true) 方法请求放行，将 intercepted 标识置为false ，并且，本次事件将不询问 ViewGroup 自身是否要消费 ViewGroup#requestDisallowInterceptTouchEvent() 方法就是之前介绍过的，开放给子 View 请求放行的一套机制 如果子视图没有请求放行，那么调用 onInterceptTouchEvent() 询问自己要不要拦截消费，不需要消费事件会继续分发，我们后面会讲到 如果 mFirstTouchTarget 为空，并且事件类型不为 DOWN ，表示先前的事件也是 ViewGroup 自己消费的，无需执行分发，再次交给自己执行即可，将 intercepted 变量置为 true 上面这段代码解释完了，我们来总结一下得到的信息： 只要子 View 没有调用 requestDisallowInterceptTouchEvent() 方法请求放行，ViewGroup 有权在任何情况下，通过调用 onInterceptTouchEvent() 返回 true 的方式，拦截任一触摸事件 我们在继承 ViewGroup 以后，首先要重写 onInterceptTouchEvent() 方法，然后我们根据自己的需求，判断要不要消费某个事件 true 表示自身需要消费，该事件将会被拦截，并会在下一步发送到 ViewGroup 自身的 onTouchEvent() 方法中，不会继续向下分发 false 表示不消费，继续向下分发事件 ViewGroup 的放行机制和拦截就结束了，我们继续看代码，下一步该执行事件的分发了 3、事件的分发 如果子视图没有请求放行，ViewGroup 自身也不消费，那么 intercepted 标识为 false ，进入分发流程 /frameworks/base/core/java/android/view/ViewGroup.java class ViewGroup extends View { public boolean dispatchTouchEvent(MotionEvent ev) { ... // 子视图未请求放行，ViewGroup 自身也不消费，进入分发流程 if (!intercepted) { if (actionMasked == MotionEvent.ACTION_DOWN) { for (int i = mChildrenCount - 1; i &gt;= 0; i--) { ...// 检查子 View 是否可触摸，是否在触摸区域内等等，过程略 // 找到合适的子 View 后，调用 dispatchTransformedTouchEvent() 执行事件分发，如果返回 true，记录本次分发 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { newTouchTarget = addTouchTarget(child, idBitsToAssign); // 生成一个新的 TouchTarget 对象，用于记录消费的 View break; } } // 没有新的需要触摸事件的视图，那么，把链表尾部的 TouchTarget 拿出来，在下一步把事件分发给它 if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } } } } return handled; } private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,View child, int desiredPointerIdBits) { boolean handled; if (child == null) { handled = super.dispatchTouchEvent(event); // ViewGroup 继承自 View ，这里调用的是 View#dispatchTouchEvent() } else { handled = child.dispatchTouchEvent(event); } return handled; } } 分发的过程是将所有符合条件的子 View 都询问一遍 在上面这段代码中，使用 for 循环遍历所有的子 View ，检查每个子 View 是否在触摸区域，是否可以被触摸等等 如果找到合适的子 View ，调用 dispatchTransformedTouchEvent() 执行分发，并记录消费的结果 所有的子 View 遍历一遍后，如果发现没有消费的视图，并且，当前 mFirstTouchTarget 不为空，那直接将保留着上一次消费的 View 最近的一个 TouchTarget 拿出来，等待下一步执行 4、事件的消费 事件的消费代码比较简单： /frameworks/base/core/java/android/view/ViewGroup.java class ViewGroup extends View { public boolean dispatchTouchEvent(MotionEvent ev) { ... // 跑到这，如果 mFirstTouchTarget 还是为空 ，表示这个事件 ViewGroup 自身要消费 if (mFirstTouchTarget == null) { handled = dispatchTransformedTouchEvent(ev,canceled,null,TouchTarget.ALL_POINTER_IDS); } else { TouchTarget target = mFirstTouchTarget; // 遍历 TouchTarget 链表，执行事件分发，代码有去重操作，被我删了，即之前分发过的新添加的节点，不再执行分发 while (target != null) { final TouchTarget next = target.next; if (dispatchTransformedTouchEvent(ev, cancelChild,target.child, target.pointerIdBits)) { handled = true; } target = next; } } return handled; } private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,View child, int desiredPointerIdBits) { boolean handled; if (child == null) { handled = super.dispatchTouchEvent(event); // ViewGroup 继承自 View ，这里调用的是 View#dispatchTouchEvent() } else { handled = child.dispatchTouchEvent(event); } return handled; } } 如果 mFirstTouchTarget 为空 ，表示这个事件 ViewGroup 自身要消费，调用 dispatchTransformedTouchEvent() 方法 在 dispatchTransformedTouchEvent() 方法中，如果 child 参数为空，表示是 ViewGroup 要消费，那么调用 ViewGroup 的父类： View#dispatchTouchEvent() dispatchTouchEvent() 方法最终把事件传递给 onTouchEvent() ，我们马上就能看到 View 的消费流程了 如果 mFirstTouchTarget 对象不为空，说明有其他子 View 消费了事件（可能有多个），依旧调用 dispatchTransformedTouchEvent() 执行分发 好了，ViewGroup 的 消费、分发、拦截与放行，到这里就结束了，接下来我们看 View#dispatchTouchEvent() 的流程 View 的消费 聊完了 ViewGroup 对触摸事件的处理，我们接着来聊 View 这边是怎么处理触摸事件的 在上一节的 dispatchTransformedTouchEvent() 方法中，无论执行的是 super.dispatchTouchEvent(event) 方法，还是 child.dispatchTouchEvent(event) 方法，最终都是调用到 View#dispatchTouchEvent() 中 View#dispatchTouchEvent() 逻辑比较少，重要代码只有一句，调用了 onTouchEvent() 消费事件，除此之外 View 的事件分发就没什么好聊的了 //frameworks/base/core/java/android/view/View.java class View { public boolean dispatchTouchEvent(MotionEvent event) { boolean result = onTouchEvent(event); return result; } public boolean onTouchEvent(MotionEvent event) { return false; } } 好了，View / ViewGroup 的事件分发到这里就结束了，当然我们看到的是非常精简的版本了，只有三两个关键函数，并且几乎没有任何细节 因为 View / ViewGroup 的事件分发比较简单，不像 Framework 的逻辑，绕来绕去的，事件分发的逻辑大部分时间都在内部做跳转，感兴趣的朋友自己去跟一遍源码很快就了解清楚了 四、结语 本篇文章稍微有点长，从硬件驱动，系统内核，到 Framework 都有涉及。其中，了解 IMS 的实现原理，APP 和 IMS 通信的建立，以及 ViewGroup 的 dispatchTouchEvent() 方法的事件派发逻辑，是本篇文章比较重要的内容 在文章的最后，我们用张大伟老师《深入理解Android 卷III》书中的一段话作为本文总结： 简单来说，内核将原始事件写入到设备文件中，InputReader 不断地通过 EventHub 将原始事件取出来，解析加工成 KeyEvent、MotionEvent 事件，然后交给 InputDispatcher InputDispatcher 根据 WMS 提供的窗口信息将事件交给合适的窗口 接着，窗口的 ViewRootImpl 对象再沿着控件树将事件派发给感兴趣的控件，控件对其收到的事件作出响应，更新自己的画面、执行特定的动作 所有这些参与者以 IMS 为核心，构建了 Android 庞大而复杂的输入体系。 好了，本篇文章到这里就全部结束了。文中提到的硬件驱动和系统内核这两块暂时还不是我擅长的领域，所以如果各位大佬发现本文有写的不对的地方，还望及时指出，我会第一时间改正，感谢 另外，欢迎各位大佬给我留言，我们一起来探讨技术问题 全文完 五、参考资料 《深入理解Android 卷III - 张大伟》 电阻屏已经被智能手机抛弃，还有哪些应用场景？ 手机全贴合屏幕技术解析 【Linux驱动】I2C子系统与触摸屏驱动 - @hongZ 【Linux驱动】input子系统与按键驱动 - @hongZ Linux驱动开发|input子系统 - 安迪西 从 0 开始学 Linux 驱动开发 - Hcamael Android(Linux) 输入子系统解析 - Andy Lee Android 如何上报 Touchevent 给应用层 - 董刚 这一次，带你彻底弄懂 Android 事件分发机制(外/内层责任链) - 伤心的猪大肠 Android 触摸事件分发机制（一）从内核到应用 一切的开始 - 吴迪 Android 触摸事件分发机制（二）原始事件消息传递与分发的开始 - 吴迪 Android事件分发机制二：核心分发逻辑源码解析 - 一只修仙的猿 InputChannel and InputDispatcher in Android ","link":"https://yibaoshan.github.io/post/android-graphics-input/"},{"title":"读书笔记：十天学会51单片机","content":" 点击跳转到掘金阅读 &quot;好记性不如烂笔头&quot;，读书笔记系列是为了记录自己的读书心得，文章内容一部分是摘抄原文，一部分是自己的理解和总结 本篇文章记录的是，来自郭天祥老师的《十天学会51单片机》视频课 一、写在前面 前段时间我在网上买了块 51 单片机开发板 接下来的两周，我每天下班回到家的第一件事就是，跟着郭天祥老师的《十天学会51单片机》视频鼓捣一会儿，那阵子在我们家天天都能听到蜂鸣器滴滴滴~滴滴滴的声音 我当时买开发版的初衷是想了解：单片机是如何执行代码的？ 了解单片机的执行过程，对下一阶段（操作系统）的学习有很大的帮助。因为操作系统最重要的任务之一，就是管理 CPU 执行多任务 但是，直到我能控制8位数码管显示数字以后，我才意识到，哦~ 原来这是偏实践类的课程，理论知识讲的比较少，这和我原定的目标相差甚远。 于是，后续课程的串口、液晶屏啥的我就没有继续学了，在网上查了单片机原理作为本节课的补充。 本篇文章共包含两部分内容： 一是课程简介，介绍郭天祥老师的《十天学会51单片机》每小讲的课程内容 二是课程总结，主要是想聊聊我个人非常疑惑的一个问题，单片机是如何执行代码的？ 接下来，我们先跟随郭天祥老师的脚步，一起来学习怎么控制单片机上的硬件 二、十天学会51单片机 郭天祥老师的《十天学会51单片机》课程一共有13讲，每一讲的内容都是基于配套的 TX-1C 开发板展开 因此，在介绍课程内容之前，我们有必要先来了解 TX-1C 开发板的构成 图片来源：拼夕夕卖家详情页 如图，从左到右分别是发光二极管、1602液晶屏接口和六位数码管，整块开发版的学习要点如下： 了解最小系统必要条件：电源、晶振、复位电路 控制任意I/O口：输出控制电平高低、输入检测电平高低 掌握定时器的用法 掌握外部中断、定时器中断、串口中断 串口通信：单片机与单片机、单片机与计算机通信 课程内容大致是这些，从目录来看还是比较简单的。当我们具备控制这些简单设备的能力以后，其他复杂的功能原理上也都差不多 好，接下来我们开始上课 点亮一个发光管 课程第一讲，老师先进行个人介绍，然后讲了单片机的发展史，以及介绍单片机能做什么？ 在课程结尾，老师带领我们点亮了一个发光二极管 点亮代码过于简单，我当时顺手把剩下的7个发光二极管一起点亮了，还做了一个流水灯的效果出来，代码如下： #include &lt;reg52.h&gt; sbit led1 = P1^0; ...// 中间还有 6 个灯，忽略重复代码 sbit led8 = P1^7; unsigned int index = 0; //轮到第几个 LED 灯 unsigned int toggle = 1; // 1 表示开灯 0 表示关灯 void main(){ while(1){ perform_once();// 控制发光二极管亮灭 delay();// 休眠一段时间，代码实现省略 } } void perform_once(){ if(index&gt;=8){ // 让每个发光二极管，一轮亮，一轮灭 index = 0; toggle = toggle == 1 ? 0 : 1; } switch(index){ case 0:led1 = toggle; ... case 8:led8 = toggle; } index++; // 控制下一个发光二极管 } 编写完上述代码以后，我们在 Kiel 中将 c 文件编译打包成 .hex 文件 再通过 STC_ISP 软件烧录到开发板中，将板子重新上电就可以看到代码运行效果了 图片来源：自己拍的 控制蜂鸣器发声 第二讲老师教了我们怎么控制蜂鸣器发声 不过，在学习蜂鸣器之前，老师先接着上节课的内容，带我们一起实现了发光二极管的流水灯效果 唉嘿，流水灯效果我在上节课就搞定了，我可真是个懂得未雨绸缪挖地道的好孩子，骄傲 讲完流水灯的实现，老师才教了我们怎么去控制蜂鸣器，再往后就是蜂鸣器发声实战了，代码也很简单 #include &lt;reg52.h&gt; sbit beep = P2^3; //蜂鸣器 void main(){ while(1){ perform_once();// 让蜂鸣器配合发光二极管，滴滴滴~ delay();// 休眠一段时间 } } void perform_once(){ if(index&gt;=8){ index = 0; toggle = toggle == 1 ? 0 : 1; } beep = toggle; } 我这儿偷了个懒，直接在原先控制发光二极管的基础上，增加了控制蜂鸣器的逻辑。让蜂鸣器当背景音乐，配合发光二极管流水灯一起发声 编写完上述代码以后，我们在 Kiel 中将 c 文件编译打包成 .hex 文件 再通过 STC_ISP 软件烧录到开发板中，将板子重新上电就可以看到代码运行效果了 图片来源：自己拍的 数码管、中断原理和定时器 第三讲的内容比较多，有中断、定时器的原理，还有数码管的控制显示，其中数码管的 ‘段选’ 和 ‘位选’ 让我反应了好一会才理解 接下来又是动手实践环节 我在之前的代码基础上加了数码管的显示逻辑，另外还单独写了一个检测外部中断的程序，这两段代码都比较长我就不放出来了，直接来看效果 图片来源：自己拍的 在后面的4 ~ 13讲的课程中，老师还教了：独立键盘、矩阵键盘的控制，串口通信，1602液晶屏显示，I2C总线等内容 不过这几节课的视频我全部开2倍速看完的，视频中的代码我也没有动手实践 开倍速和没有写代码是因为，在上完 1~3 讲以后，我已经学会了： 如何控制输出电平进而控制发光二极管、蜂鸣器 如何检测输入电平 如何使用中断、定时器 虽然东西不多，但学习目的已经达到了，再学会控制后面的几个元器件，对我来说意义不是很大 对剩下课程感兴趣的朋友，可以查看参考资料一栏中 “十天学会51单片机教程” 好了，课程简介部分到这里就先结束了 接下来的时间，我们来聊聊本篇文章中，我最感兴趣的话题：单片机是如何执行代码的？ 三、单片机是如何执行代码的？ 在之前几节课的实践过程中，不知道大家有没有注意到一个规律 我们每次写完代码，都需要先用 Kiel 软件，将 c 文件编译成 .hex 文件 再通过 STC_ISP 软件烧录到开发板中，然后板子重新上电，我们就能看到新代码运行的效果了 为什么简单操作几步就可以让单片机运行我们的新代码呢？ 我们把前后流程捋一下，可以发现上述的操作流程，大致可以分为：编码、编译、烧录、运行这四个阶段 想要了解单片机是怎么运行的，我们就需要知道，这几个阶段各自都做了哪些事情？ 我们先来看第一步，编码阶段 编码阶段 编码阶段指的是把我们人类的想法，转换为编程语言来实现 比如我想让板子上的第一个发光二极管亮起来，用代码实现的话可以这样写： #include &lt;reg52.h&gt; sbit led1 = P1^0; void main(){ led1 = 0; } 核心代码就一句话：'led1 = 0' ，非常的简单 编译阶段 当我们的需求（点亮第一个二极管）用编程语言实现了以后，接下来就是要把这段逻辑代码，翻译给单片机去执行 怎么翻译呢？ 这就是编译器做的事情，大致流程是，先把源代码进行语法解析，然后再转化为各个平台的机器代码 具体到 51 单片机，Kiel 集成了编译器的功能，我们写完代码后，将工程的目标指令集设置为 MCS-51，然后就可以一键打包成 .hex 可执行文件，等待下一阶段烧录到单片机 这里有两个比较关键的点，什么是指令集，以及什么是 hex 文件？ 我们先来看第一点，什么是指令集？ 1、什么是指令集 我们都知道，芯片是由无数个功能不同的电路组合而来，而电路又只能通过开关来控制 那么，芯片厂商就需要告诉其他人，应该通过什么样的开关组合规则，才来控制这个芯片上不同的电路 控制芯片的规则，就被称为指令集。 比如，51单片机使用的是 MCS-51 指令集，这套指令集包含了：数据传送、位操作、逻辑运算及转移、算术运算、控制转移5个大类，共计111条指令 每条指令都是 0101010 这样的 01 组合，一条指令有多少位0和1，要看具体用什么指令 在51单片机的111条指令中，1字节指令共有49条，2字节指令共有45条，3字节指令共有17条 详细的指令集可以查看参考资料 2、什么是 hex 文件 至于 Kiel 打包生成的 .hex 文件，我们可以用文本编辑器打开看看 图片来源：课程视频截图 其实 hex 文件已经是编译过后得到的二进制组合了，里面的内容就是我们用 C51 写的业务代码，不过是被转换为一行行0和1，我们看不懂罢了 至于为什么显示的是十六进制，这是因为文本编辑器是以四个二进制当作一个单位读的，烧录到单片机还是以二进制来执行的 烧录阶段 在上一步的编译阶段，所有需要执行的指令都已经准备好，保存在 .hex 文件中 接下来，我们只需要使用 STC-ISP 软件，把这些二进制数据，传输给单片机的存储单元（EEPROM）就完事了 烧录的过程和原理我也不是很清楚，我个人是这样理解的，单片机存储单元是由许多电池组成的。烧录电路在碰到 0 时，就对电池放电；碰到 1 时，就对电池充电 对烧录原理感兴趣的朋友可以查看参考资料列出的，STC 51单片机烧录协议分析 和 单片机为什么能直接烧录程序？这两篇文章 运行阶段 好，经过上一步的烧录后，现在单片机的 ROM 存储了是无数个高低电平，等待被执行 接着，我们按下开发板的电源键，板子上电， PC 寄存器电路默认指向 0000H 地址，通过传输电路，寻址寄存器得到第一条指令地址 然后，寻址寄存器从 ROM 取出第一条指令，传输给指令编码器解析 51的指令类型前面提过了，一共分为5大类： 数据传送：内部 RAM 或寄存器之间的数据传送、累加器A与外部 RAM 间的数据传送等等 位操作：位状态控制、位条件转移等等 逻辑预算及转移：与、或、亦或、循环移位、累加器清零等等 算术运算：带/不带进位的加法、带借位的加法、加1剪1、乘除等等 控制转移：子程序调用与返回、空操作、条件转移等等 指令编码器根据指令类型，调用不同的电路来执行任务。一条指令执行结束后，再次重复上述流程，根据 PC 寄存器指向的下一条指令地址，继续取指执行，永不停歇.. 至此，编码、编译、烧录、运行这四个阶段我们都已经分析完成，单片机的运行流程到这里就讲完了。 四、结语 在文章的结尾，我们来对本文的两部分内容做个总结 先说《十天学会51单片机》视频课程 对于我不熟悉的领域，我的期望通常是讲的越简单，越入门越好 这一点我觉得《十天学会51单片机》这节课做到了，老师讲的非常好，简单易懂，并且只需要有一点点语言基础就可以直接上手 但是，课程内容对单片机内部电路介绍的比较少，如果没有模电、数电、计组的基础，全部跟下来可能会觉得有点吃力 总的来说，郭天祥老师的《十天学会51单片机》课程，更适合已经有理论基础的科班学生上手实践 如果像我一样，妄想通过这门课来学习《微机原理及接口技术》的同学，可以放弃了，老老实实看书吧 再来看第二个部分，单片机是怎么执行代码的？ 我们把单片机的运行流程分为编码、编译、烧录、运行四个阶段，每个阶段做的事情在正文里都已经分析过了，我们这里再简单总结一下： 编码阶段，将业务逻辑解释成代码实现 编译阶段，将代码解释成目标平台的机器语言，也就是 01 组合 烧录阶段，把编译结果的 01 组合，传输到机器的存储单元，每个 01 都被存储为高低电平。此阶段是'虚拟世界'转向'物理世界'的转折点 运行阶段，接下来的事情全部发生在物理电路层面上。在振荡器电路的驱动下，芯片开始取指、译指、执行，根据执行结果，或修改寄存器改变时序电路逻辑，或刷新主存等其他操作，然后继续取指、译指、执行，无限循环，直到断电 好了，本篇文章到这里就全部结束了。各位大佬如果发现本文有写的不对的地方，还望及时指出，我会第一时间改正，感谢 全文完 五、参考资料 十天学会51单片机视频（郭天祥高清完整版）- 小破站 MCS-51 汇编语言指令集 51单片机（一）单片机发展概述 - 果果小师弟 51单片机（二）单片机结构和原理 - 果果小师弟 51单片机（三）80C51的指令系统 - 果果小师弟 51单片机（四）80C51的程序设计 - 果果小师弟 单片机为什么能直接烧录程序？- 知乎 既生Bin 何生Hex ？- 光豆儿 STC 51单片机烧录协议分析 - 电型金刚 基于51单片机的多线程操作系统设计 - 卖水果的 宏晶 STC89C52RC 微控制器实用笔记 - Hank 51单片机运行过程 - 清酒与水 ","link":"https://yibaoshan.github.io/post/book-notes-computers-microcomputer-8051/"},{"title":"读书笔记：穿越计算机的迷雾（下）","content":"&quot;好记性比如烂笔头&quot;，读书笔记系列是为了记录自己的读书心得，文章内容一部分是摘抄原文，一部分是自己的理解和总结 本篇文章记录的是，来自李忠老师的《穿越计算机的迷雾》第二版 一、写在前面 在上一篇文章中，我们学习了二进制怎么做加法、一个简单的全加器电路、电报和继电器的发明。 其中，继电器是我们需要关注的重点，计算机能够被创造出来，继电器可以说是最大的功臣 本篇文章主要介绍逻辑门电路，以及各种触发器，目标是做出一个简单的 CPU，大致路线如下： 用继电器制作逻辑门（与或非）电路 用非门电路制作振荡器 用或非门/与非门制作 RS 触发器、D 触发器、上升沿 D 触发器 用上升沿 D 触发器制作寄存器 制作传输门电路、加法器电路、控制器电路 看起来内容很容，实际上，也是真的很多~ 多的我懒癌都犯了，不想写本篇文章了，如何制作 CPU 可以看 BIT祝威 写的文章 继电器是如何成为CPU的（一） - BIT祝威 继电器是如何成为CPU的（二） - BIT祝威 再结合北京大学《计算机组成》公开课中的第五、七、八章视频，计组部分差不多就可以翻篇了 搞定，收工 ","link":"https://yibaoshan.github.io/post/book-notes-computers-lizhong-2/"},{"title":"读书笔记：穿越计算机的迷雾（上）","content":" 点击跳转到掘金阅读 &quot;好记性不如烂笔头&quot;，读书笔记系列是为了记录自己的读书心得，文章内容一部分是摘抄原文，一部分是自己的理解和总结 本篇文章记录的是，来自李忠老师的《穿越计算机的迷雾》第二版 一、写在前面 上周末终于看完了李忠老师的《穿越计算机的迷雾》，从十一假期到现在，算算日子，读完这本书用了将近一个月时间 读这本书的目的是想补计算机组成原理的基础。早在读《穿越计算机的迷雾》之前，计组方面我已经学过了： 北京大学陆俊林老师的《计算机组成》视频公开课，和徐文浩老师在极客时间发布的《深入浅出计算机组成原理》专栏 读完《穿越计算机的迷雾》以后，给我最大的感受是：这是一本非常棒的科普书籍！ 和之前的两个课程相比，它不会上来就讲原理，什么是冯·诺依曼结构、运算器、控制器、南桥北桥是什么、指令体系等等 而是从初中电学开始讲起，从电生磁到继电器的发明，从磁生电到电话的发明，一直讲到逻辑电路、触发器、布尔代数、寄存器、运算器等等 这本书让我明白，人类并不是一开始就知道：应该怎么去制造一台计算机的？ 计算机的发明，是由无数前人智慧的结晶一步步演变而来 接下来我们跟随李忠老师的脚步，一起来探究计算机内部的世界 ps：限于篇幅，本篇文章在内容上有删减，建议阅读原著 二、穿越计算机的迷雾（1~4） 书本的第一章，作者花了一整章的篇幅来温习初中的电学课程，这里我们简单过一遍： 能够导电的被称为 “导体”，金属、电解液、电离的气体、大地等都是导体 不能导电的被称为 “绝缘体”，干燥的木头、智障、塑料、陶瓷等都是绝缘体 导体能够导电的原因，是它具有大量可以自由移动的带电粒子。电压推动电子往一个方向流动，则被称为电流 在第一章的结尾，作者介绍了电路图的起源，并教我们画了一个基础的电路图 图 1.8 文中图片均来自于《穿越计算机的迷雾》，后续不再重复声明 这些符号我们应该都还认识，从左到右分别是电源、开关和两个灯泡💡 用电来表示数 有了电路图的基础，接下来我们来想象一下，凭空出现了一个能计算加法的 “加法运算部件” 这个加法运算部件提供了a、b两个输入端，好让它知道要算的数是什么。当这个加法运算部件完成计算后，它把结果从 o 端送出来，如 2.1 图所示 图 2.1 现在，我要利用它来计算加法，假设我们要计算 1 + 2 等于几？ 我们可以在 a 端加上 1V 的电压，在 b 端加上 2V 的电压，当运算完成后，用电压表测量 o 端就会得到 3V 的电压，这就表示 1 + 2 的结果等于 3。 如果我们计算的数值比较小，或者都是整数，上面的方案也未尝不可。但是，如果只是这样，那这个加法部件也没什么意义，我们必须想办法解决数值过大或者小数的情况 这时候，人们想起了德国佬，莱布尼茨。 莱布尼茨是伟大的哲学家和数学家，大约在1672—1676年的时间，他创建了二进制。二进制在创建之初，并非是为了电学服务的，只是无意间被创造了出来 在随后的历史进程中，人们发现可以用开关来表示二进制，就把二进制拿过来作为计算机的一部分 图 2.16 如上图 2.16，当开关断开时，电流被切断，这代表 0；当开关接通时，电路中有电流通过，这代表 1 有了二进制以后，之前的加法部件数值过大的问题就迎刃而解了 图 2.19 如图 2.19 所示，图中的灰色方框通常代表一个具有加法功能的电路，由于我们现在还不知道它的内部构造，所以这里用一个方框来表示 这个运算部件的左边和下面各有 5 个开关，分别用于输入两个参与运算的二进制数 右边输出的5根线各自连接一个灯泡，当灯泡亮时，表明这一比特是1，否则为0，通过观察亮灯的情况，再转为十进制，我们就能知道结果是几了 好了，第二章到这里就结束了，接下来的第三章，我们将开始探究学会二进制怎么做加法？并设计出一个全加器电路，它可是图 2.19 中的灰色方框中的重要组成部分 二进制怎么做加法？ 一个能够计算 5 bit 以内的的电路图在上一章节结束时已经画出来了 严格来说，因为结果端只有 5 个灯泡，所以上面的电路图最大只能得到的结果是 11111 ，也就是只能计算结果在 31 以内的加法 为了设计出能计算更大的数的电路，我们有必要来学习：二进制的加法 图 3.2 如图 3.2，和十进制的加法一样，二进制做加法时，也是要先把两个相加的数右对齐，然后从最右边的列开始计算 根据下面的口诀得到一个计算结果： 0加0等于0 0加1等于1 1加0等于1 1加1等于0，进1 比如图 3.2 演示的，110 + 11 = 1001 ，翻译成十进制就是，6 + 3 = 9 1、什么是全加器 在计算几个二进制加法以后，我们发现了一个规律：既然加法都是按列进行的，而且每一列的计算过程都一样 那么完全可以设计一个电路来完成每一列的相加过程，如图 3.7 所示 图 3.7 接下来，我们要开始上一点难度了，注意听讲！ 在图中， A 和 B 分别是来自‘被加数’和‘加数’的一个比特，它们正好在同一列上； Ci 是来自右边一列的进位； Co 是本列产生的进位； S 是本列的“和”； 为了表明这个电路的用途，我们在图的中间加了一个符号 “∑” 。在数学中，这个符号用来表示 “加” 既然是一个电路，它肯定有一个名字。是的，它叫全加器。这不是一个很容易理解的名字，特别是这个 “全” 字 2、什么是半加器 既然有全加器，是不是还应该有“半加器”？ 你别说，还真有半加器这东西。 但是，半加器仅仅是把来自被加数和加数的两个比特加起来，产生一个 “和” 以及一个进位，并不考虑从其他列来的进位 换句话说，它只是用电路来实现二进制加法口诀。全加器则不然，它真正实现了二进制加法中每一列的加法过程，所以它才叫做“全加器” 3、全加器的组合 有了全加器，解决了二进制加法过程中每一列的计算问题，那么，我们可以搞一大堆全加器，根据被加数和加数的比特数，把它们串联起来组成一个完整的加法电路，图 3.8 显示了这一过程 图 3.8 图中，参与相加的两个二进制数分别是 a2/a1/a0（左上三个开关） 和 b2/b1/b0（底部三个开关），组成它们的每一个比特都可以用开关的闭合与断开来得到 随着开关的闭合与断开，我们会得到一些二进制数，比如我们可以让 a2/a1/a0 = 110 因为被加数和加数各自用了3个开关，所以我们只能计算3比特的二进制数，比如110 + 101 如果我们仔细观察的话，会发现它很容易进行扩充，以计算更大的数，只需要串联更多的全加器即可 全新的开始，电与磁 全加器的事情到这里先告一段落，从第四章开始，作者将带领我们一起来回顾电与磁的历史 前几章介绍的二进制啊、全加器电路啊这些都先放一边，开始全新的旅程 1、电能生磁 老实说，尽管从表面上看计算机是神奇的、智慧的，但掩盖不了它实质上只是一种普通电器的事实 这也意味着，要想搞清楚它内部到底是怎么运作的，仅仅靠掌握一些简单的电学知识还不够，还必须了解另外一部叫做电磁学的历史。 没有它所提供的理论知识和电子零件，计算机的发展也就失去了最原始的基础 我们开始吧 1820年的一天，一个偶然的机会，奥斯特发现当电路接通时，离电线很近的磁针会发生偏转 奥斯特的偶然发现说明了一个事实，那就是，电流可以产生磁场 如果我们在一颗钉子上缠绕电线，通电以后这根钉子就会具有磁性，绕的圈数越多，磁力也就会越大，这被称为电磁铁，如图 4.1 所示 图 4.1 2、摩尔斯电码 电学发展的历史还在继续 电磁铁被发明出来以后，在1836年左右，美国发明家摩尔斯在此基础上发明了一种叫做电报的东西 它由不在一个地方的两个装置组成，用很长的电线连接起来 图 4.2 如图 4.2 所示，一旦开关闭合，电磁铁生效，衔铁臂（右上部分）就会被磁性吸引靠近电磁铁；当开关松开，电磁铁失去磁性，衔铁臂又在弹簧的牵引下回到原来的位置 摩尔斯在衔铁臂绑上了一支笔，并在笔的下面放一卷匀速前进的纸，当我们闭合开关时，在纸上打印出一个点 “· ”，闭合的时间稍微长一些，纸上留下一条线 “—” ，这称为“划” 我们可以不停的开合开关，在纸上打印出 &quot;·—··—·——·—···——··—·—&quot; 各种组合图案，再配上解析规则，比如，字母 “A” 是 ·—，字母 “V” 是 ···—，我们就可以通过这样的组合图案来发送信息了 这，就是摩尔斯电码的原理 3、继电器的发明 历史上第一份长途电报是在1844年5月24日发出的，这表明莫尔斯的发明已经具备了实用性 不过，如果线路太长，电阻就会变大。这样，在电报线路的那一头，微弱的电流将不能使电磁铁正常吸合，电报接收机也就不能正常工作 好在我们有继电器，继电器的发明其实比摩尔斯电码要更早一些 1831年，美国科学家约瑟夫·亨利用电磁铁发明了电动门铃，特别适合使用电线来进行长距离敲响门铃 然后于1835年发明电子继电器，它利用电磁铁在通电和断电下磁力产生和消失的现象，来控制高电压高电流的另一电路的开合 我们可以在发送电报的电线加装 N 台继电器，这样可以解决长距离输送，电流会变小的问题，如图 4.3 所示。继电器的数量，取决于电报的输送距离 图 4.3 继电器的本质是“续”电 4、磁也能生电 在奥斯特发现电流能产生磁场之后，人们想到，既然电流能够产生磁场，那么反过来，磁场能不能变成电流呢？ 1831年的一天，英国的物理学家法拉第做了一个实验 图 4.6 法拉第用来将磁变成电的装置 如图 4.6 所示，左边的电线接开关和电源，这实际上是把整个大铁圈变成了一个电磁铁。 当闭合开关的时候，线圈中有电流通过，大铁圈就产生了磁场，变成了一个磁铁。右边的那个线圈接电流计，当他在给左边的线圈通电时，在电源接通的一瞬间，电流计摆动了一下 就这样，法拉第发现了，当导体在磁场中运动的时候，就能产生电流，磁生电就此诞生 三、结语 电与磁的历史终于结束了，但其实，为了不让文章看起来太长，我故意漏掉了原著中4.4、4.5、4.6 这三个小节的内容，它们分别讲的是：电话的发明、爱迪生大战交流电以及无线电通信的开端 感兴趣的同学可以寄几购买原著翻一翻 从第五章开始，作者将带领我们正式学习和计算机有关的知识，我们下篇文章见 最后，引用作者李忠的一句话作为结尾 &quot;学习计算机就像是考古，我们学习知识不应该和游戏规则一样死记硬背，我更关心每个知识点背后的故事，知识怎么一步步来的&quot; 四、参考资料 《穿越计算机的迷雾》- 李忠 继电器是如何成为CPU的（一） - BIT祝威 继电器是如何成为CPU的（二） - BIT祝威 红石电路教程 - 我的世界官网 ","link":"https://yibaoshan.github.io/post/book-notes-computers-lizhong-1/"},{"title":"为什么会发生 Fragment not attached to Activity 异常？","content":" 点击跳转到掘金阅读 事情是这样的，前两天有位大佬在群里提了个问题，原文如下 一个 Fragment 在点击按钮跳转一个新的 Activity 的时候，报崩溃异常：Fragment not attached to Activity 问：复现路径可能是什么样的呢？ 一、回答问题前先审题 我们把这个问题的几个关键词圈出来 首先，可以点击 Fragment 上的按钮，证明这个 Fragment 是可以被看到的，那肯定是处于存活的状态的 其次，在跳转到新的 Activity 的时候发生崩溃，证明 Fragment 调用的是 startActivity() 方法 最后，来看异常信息：Fragment not attached to Activity 这个报错我们都已经很熟悉了，在 onAttach() 之前，或者 onDetach() 之后，调用任何和 Context 相关的方法，都会抛出 &quot; not attached to Activity &quot; 异常 发生的原因往往是因为异步任务导致的，比如一个网络请求回来以后，再调用了 startActivity() 进行页面跳转，或者调用 getResources() 获取资源文件等等 解决方案也非常简单：在 Fragment 调用了 Context 相关方法前，先通过 isAdded() 方法检查 Fragment 的存活状态就完事了 到这里，崩溃产生的原因找到了，解决方案也有了，似乎整篇文章就可以结束了 但是，楼主问的是：复现路径可能是什么样的呢？ 这勾起了我的好奇心，我也想知道可能的路径是怎样的 于是，在接下来的两个晚上，笔者开始了一场源码之旅.. 二、大胆假设，小心求证 审题结束我们就可以开始动手解答了，以下是群里的完整对话 大佬：一个 Fragment 在点击按钮跳转一个新的 Activity 的时候，报崩溃异常：Fragment not attached to Activity 。复现路径可能是什么样的呢？ 我：这个问题之前在项目中也有碰到过，当时的解决方案是，通过调用 isAdded() 来检查 Fragment 是否还活着，来避免因为上下文为空导致的崩溃 当时忙于做业务没有深入研究，现在趁着晚上有时间来研究一下下 首先，打开 Fragment 源码，路径在：frameworks/base/core/java/android/app/Fragment.java 用 “not attached to Activity” 作为关键字搜索，可以发现 getResources() 、getLoaderManager() 、startActivity() 等等共计 6 处地方，都可能抛出这个异常 题目明确提到，是跳转 Activity 时发生的错误，那我们直接来看 startActivity() 方法 class Fragment { void startActivity(){ if (mHost == null) throw new IllegalStateException(&quot;Fragment &quot; + this + &quot; not attached to Activity&quot;); } } 从上面代码可以看出，当 mHost 对象为空时，程序抛出 Fragment not attached to Activity 异常 好，现在我们的问题转变为: mHost 对象什么时候会被赋值？ 很显然，如果在赋值前调用了 startActivity() 方法，那程序必然会崩溃 mHost 对象赋值以后，可能会被置空吗？如果会，什么时候发生？ 我们都知道，Fragment 依赖 Activity 才能生存，那我们有理由怀疑： 当 Activity 执行 stop / destroy ，或者，配置发生变化（比如屏幕旋转）导致 Activity 重建，会不会将 mHost 对象也置空呢？ mHost 对象什么时候会被赋值？ 先来看第一个问题，mHost 对象什么时候会被赋值？ 平时我们使用 Fragment 开发时，通常都是直接 new 一个对象出来，然后再提交给 FragmentManager 去显示 创建 Fragment 对象的时候，不要求传入 mHost 参数，那 mHost 对象只能是 Android 系统帮我们赋值的了 得，又得去翻源码 打开 FragmentManager.java ，路径在：/frameworks/base/core/java/android/app/FragmentManager.java class FragmentManager { FragmentHostCallback mHost; // 内部持有 Context 对象，其本质是宿主 Activity void moveToState(f,newState){ switch(f.mState){ case Fragment.INITIALIZING: f.mHost = mHost; // 赋值 Fragment 的 mHost 对象 f.onAttach(mHost.getContext()); } f.mState = newState; } } 我们发现源码里只有一个地方会给 mHost 对象赋值，在 FragmetnManager#moveToState() 方法中 如果当前 Fragment 的状态是 INITIALIZING ，那么就把 FragmentManager 自身的 mHost 对象，赋值给 Fragment 的 mHost 对象 这里多说一句，在 Android 系统中，一个 Activity 只会对应一个 FragmentManager 管理者。而 FragmentManager 中的 mHost ，其本质上就是 Activity 宿主。 所以，这里把 FragmentManager 的 mHost 对象，赋值给了 Fragment ，就相当于 Fragment 也持有了宿主 Activity 这也解释了我们之所以能在 Fragment 中调用 getResource() 、startActivity() 等需要 context 的才能访问方法，实际使用的就是 Activity 的上下文 废话说完了，我们来聊正事 FragmentManager#moveToState() 方法会先去判断 Fragment 的状态，那我们首先得知道 Fragment 有哪几种状态 class Fragment { int INITIALIZING = 0; // Not yet created. int CREATED = 1; // Created. int ACTIVITY_CREATED = 2; // The activity has finished its creation. ... // 共6种标识 int mState = INITIALIZING; // 默认为 INITIALIZING } Google 为 Fragment 共声明了6个状态标识符，各个标识符的含义看注释即可 这里重点关注标识符下面的 mState 变量，它表示的是 Fragment 当前的状态，默认为 INITIALIZING 了解完 Fragment 的状态标识，我们回过头继续来看 FragmentManager#moveToState() 方法 class FragmentManager { void moveToState(f,newState){ switch(f.mState){ case Fragment.INITIALIZING: // 必走逻辑 f.mHost = mHost; // 赋值 Fragment 的 mHost 对象 f.onAttach(mHost.getContext()); } f.mState = newState; } } 在 moveToState() 方法中，只要当前 Fragment 状态为 INITIALIZING ，即执行 mHost 的赋值操作 巧了不是，前面刚说完，mState 默认值就是 INITIALIZING 也就是说，在第一次调用 moveToState() 方法时，不管接下来 Fragment 要转变成什么状态（根据 newState 的值来判断） 首先，它都得从 INITIALIZING 状态变过去！那么，case = Fragment.INITIALIZING 这个分支必然会被执行！！这时候，mHost 也必然会被赋值！！！ 再然后，才会有 onAttach() / onCreate() / onStart() 等等这些生命周期的回调！ 因此，我们的第一个猜想：在 mHost 对象赋值前，有没有可能调用 startActivity() 方法？ 答案显然是否定的 因为，根据楼主描述，点击按钮以后才发生的崩溃，视图能显示出来，说明 mHost 已经赋值过并且生命周期都正常走 那就只可能是点击按钮后，发生了什么事情，将 mHost 又置为 null 了 mHost 对象什么时候会被置空？ 继续，来看第二个问题：mHost 对象赋值以后，可能会被置空吗？如果会，什么时候发生？ 我们就不绕弯了，直接说答案，会！ 置空 mHost 的逻辑，同样藏在 FragmentManager 的源码里： class FragmentManager { void moveToState(f,newState){ if (f.mState &lt; newState) { switch(f.mState){ case Fragment.INITIALIZING: f.mHost = mHost; // mHost 对象赋值 } } else if (f.mState &gt; newState) { switch (f.mState) { case Fragment.CREATED: if (newState &lt; Fragment.CREATED) { f.performDetach(); // 调用 Fragment 的 onDetach() if (!f.mRetaining) { makeInactive(f); // 重点1号，这里会清空 mHost } else { f.mHost = null; // 重点2号，这里也会清空 mHost 对象 } } } } f.mState = newState; } void makeInactive(f) { f.initState(); // 此调用会清空 Fragment 全部状态，包括 mHost } } 看上面的代码，分发 Fragment 的 performDetach() 方法后，紧接着就会把 mHost 对象置空！ 标记为 &quot;重点1号&quot; 和 &quot;重点2号&quot; 的代码都会执行了置空 mHost 对象的逻辑，两者的区别是： Fragment 有一个保留实例的接口 setRetainInstance(bool) ，如果设置为 true ，那么在销毁重建 Activity 时，不会销毁该 Fragment 的实例对象 当然这不是本节的重点，我们只需要知道：执行完 performDetach() 方法后，无论如何，mHost 也都活不了了 那，什么动作会触发 performDetach() 方法？ 1、Activity 销毁重建 不管因为什么原因，只要 Activity 被销毁，Fragment 也不能独善其身，所有的 Fragment 都会被一起销毁，对应的生命周期如下： Activity#onDestroy() -&gt; Fragment#onDestroyView() - &gt; Fragment#onDestroy() - &gt;Fragment#onDetach() 2、调用 FragmentTransaction#remove() 方法移除 Fragment remove() 方法会移除当前的 Fragment 实例，如果这个 Fragment 正在屏幕上显示，那么 Android 会先移除视图，对应的生命周期如下： Fragment#onPause() -&gt; onStop() -&gt; onDestroyView() - &gt; onDestroy() - &gt;onDetach() 3、调用 FragmentTransaction#replace() 方法显示新的 Fragment replace() 方法会将所有的 Fragment 实例对象都移除掉，只会保留当前提交的 Fragment 对象，生命周期参考 remove() 方法 以上三种场景，是我自己做测试得出来的结果，应该还有其他没测出来的场景，欢迎大佬补充 另外，FragmentTransaction 中还有两个常用的 detach() / hide() 方法，它俩只会将视图移除或隐藏，而不会触发 performDetach() 方法 真相永远只有一个 好了，现在我们知道了 mHost 对象置空的时机，答案已经越来越近了 我们先来汇总下已有的线索 从 FragmentManager 源码来看，只要我们的 startActivity() 页面跳转逻辑写在： onAttach() 方法执行之后 ，onDetach() 方法执行之前 那结果一定总是能够跳转成功，不会报错！ 那么问题就来了 onAttach() 之前，视图不存在，onDetach() 之后，视图都已经销毁了，还点击哪门子按钮？ 这句话翻译一下就是： 视图在，Activity 在，点击事件正常响应 视图不在，按钮也不在了呀，也就不存在页面跳转了 这样看起来，似乎永远不会出现楼主说的错误嘛 除非。。。 执行 startActivity() 方法的时候，视图已经不在了！！！ 这听起来很熟悉，ummmmmm。。这不就是异步调用吗？ class Fragment { void onClick(){ //do something Handler().postDelayed(startActivity(),1000); } } 上面是一段异步调用的演示代码，为了省事我直接用 Handler 提交了延迟消息 当用户点击跳转按钮后，一旦发生 Activity 销毁重建，或者 Fragment 被移除的情况 等待 1s 执行 startActivity() 方法时，程序就会发生崩溃，这时候终于可以看到我们期待已久的异常：Fragment not attached to Activity 为什么会这样？熟悉 Java 的小伙伴这里肯定要说了，因为提交到 Handler 的 Runnable 会持有外部类呀，也就是宿主 Fragment 的引用。如果在执行 Runnable#run() 方法之前， Fragment 的 mHost 被清空，那程序肯定会发生崩溃的 那我们怎么样才能防止程序崩溃呢？ 要么，同步执行 Context 相关方法 要么，异步判空，用到 Context 前调用 isAdded() 方法检查 Fragment 存活状态 三、结语 呼~ 这下总算是理清了，我们来尝试回答楼主的问题：发生 not attached to Activity，可能路径是怎样的？ 首先，必然存在一个异步任务持有 Fragment 引用，并且内部调用了 startActivity() 方法。 在这个异步任务提交之后，执行之前，一旦发生了下面列表中，一个或多个的情况时，程序就会抛出 not attached to Activity 异常： 调用 finishXXX() 结束了 Activity，导致 Activity 为空 手动调用 Activity#recreate() 方法，导致 Activity 重建 旋转屏幕、键盘可用性改变、更改语言等配置更改，导致 Activity 重建 向 FragmentManager 提交 remove() / replace() 请求，导致 Fragment 实例被销毁 ... 最后，发生这个错误信息的本质，是在 Activity 、Fragment 销毁时，没有同步取消异步任务，这是内存泄漏啊 所以，除了使用 isAdded() 方法判空，避免程序崩溃外，更应该排查哪里可能会长时间引用该 Fragment 如果可能，在 Fragment 的 onDestroy() 方法中，取消异步任务，或者，把 Fragment 改为弱引用 四、参考资料 android-7.1 - Fragment android-7.1 - FragmentManager ","link":"https://yibaoshan.github.io/post/fragment-not-attached-to-activity-exception/"},{"title":"Android组件系列：再谈Handler机制（Native篇）","content":" 点击跳转到掘金阅读 笔者之前已经写过一篇关于 Java 层 Handler 机制的文章，从应用开发的角度出发，详细介绍了 Handler 机制的设计背景，以及如何自己如何手写一套 Handler 本篇文章我们将深入 Native 层，一起来探究 Looper#loop() 为什么不会卡死主线程背后的原因 以下，enjoy： 一、开篇 从 Android 2.3 开始，Google 把 Handler 的阻塞/唤醒方案从 Object#wait() / notify()，改成了用 Linux epoll 来实现 原因是 Native 层也引入了一套消息管理机制，用于提供给 C/C++ 开发者使用，而现有的阻塞/唤醒方案是为 Java 层准备的，只支持 Java，现在 Native 希望能够像 Java 一样： main 线程在没有消息时进入阻塞状态，有到期消息需要执行时，main 线程能及时醒过来处理，怎么办？有两种选择 要么，继续使用 Object#wait() / notify( )，Native 向消息队列添加新消息时，通知 Java 层自己需要什么时候被唤醒 要么，在 Native 层重新实现一套阻塞/唤醒方案，弃用 Object#wait() / notify() ，Java 通过 jni 调用 Native 进入阻塞态 结局我们都知道了，Google 选择了后者 其实如果只是将 Java 层的阻塞/唤醒移植到 Native 层，倒也不用祭出 epoll 这个大杀器 ，Native 调用 pthread_cond_wait 也能达到相同的效果 选择 epoll 的另一个原因是， Native 层支持监听 自定义 Fd （比如 Input 事件就是通过 epoll 监听 socketfd 来实现将事件转发到 APP 进程的），而一旦有监听多个流事件的需求，那就只能使用 Linux I/O 多路复用，epoll 就是 Linux I/O 多路复用的其中一个实现 理解 I/O多路复用之epoll 说了这么多，那到底什么是 epoll ？ epoll 全称 eventpoll，是 Linux 中的一种 I/O 多路复用技术，除了 epoll 外，还有 select 和 poll 两种不同的实现方式，我们这只讨论 epoll 要理解 epoll ，我们首先需要理解什么是 &quot;流&quot; 在 Linux 中，任何可以进行 I/O 操作的对象都可以看做是流，一个 文件， socket， pipe，我们都可以把他们看作流 接着我们来讨论流的 I/O 操作，通过调用 read() ，我们可以从流中读出数据；通过 write() ，我们可以往流 写入数据 现在假定一个情形，我们需要从流中读数据，但是流中还没有数据 int socketfd = socket(); connect(socketfd,serverAddr); int n = send(socketfd,'在吗'); n = recv(socketfd); //等待接受服务器端 发过来的信息 ...//处理服务器返回的数据 一个典型的例子为，客户端要从 socket 中读数据，但是服务器还没有把数据传回来，这时候该怎么办？ 阻塞：线程阻塞到 recv() 方法，直到读到数据后再继续向下执行 非阻塞：recv() 方法没读到数据立刻返回 -1 ，用户线程按照固定间隔轮询 recv() 方法，直到有数据返回 好，现在我们有了阻塞和非阻塞两种解决方案，接着我们同时发起100个网络请求，看看这两种方案各自会怎么处理 先说阻塞模式，在阻塞模式下，一个线程一次只能处理一个流的 I/O 事件，想要同时处理多个流，只能使用多线程 + 阻塞 I/O 的方案。但是，每个 socket 对应一个线程会造成很大的资源占用，尤其是对于长连接来说，线程资源一直不会释放，如果后面陆续有很多连接的话，很快就会把机器的内存跑完 在非阻塞模式下，我们发现单线程可以同时处理多个流了，只要不停的把所有流从头到尾的问一遍是否有返回（返回值大于-1 ）就可以得知哪些流有数据，但这样的做法效率也不高，因为如果所有的流都没有数据，那么只会白白浪费 CPU 发现问题了吗？只有阻塞和非阻塞这两种方案时，一旦有监听多个流事件的需求，用户程序只能选择，要么浪费线程资源（阻塞型 I/O），要么浪费 CPU 资源（非阻塞型 I/O），没有其他更高效的方案 并且在用户程序端这个问题是无解的，必须让内核创建某种机制，把这些流的监听事件接管过去，因为任何事件都必须通过内核读取转发，内核总是能在第一时间知晓事件发生 这种能够让用户程序拥有同时监听多个流读写事件的机制，就被称为 I/O 多路复用！ 然后我们来看 epoll 提供的函数： int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 一共有三个函数，epoll_create() 用于创建一个 epoll 池 epoll_ctl() 用来控制需要监听的 fd 的增删改操作，最后一个参数 event 是告诉内核需要监听什么事件，比如上面的 socketfd 监听的就是 可读事件，一旦接收到服务器返回的数据，监听 socketfd 的对象将会收到回调通知，表示 socket 中有数据可以读了 最后一个 epoll_wait() 方法是使用户线程阻塞的方法，它的第二个参数 events 接受的是一个集合对象，如果有多个事件同时发生，events 可以从内核得到发生的事件的集合 理解 Linux eventfd 理解了 epoll 后我们再来看 eventfd ，eventfd 是专门用来传递事件的 fd ，它提供的功能也非常简单：累计计数 int efd = eventfd(); write(efd, 1);//写入数字1 write(efd, 2);//再写入数字2 int res = read(efd); printf(res);//输出值为 3 通过 write() 函数，我们可以向 eventfd 中写入一个 int 类型的值，只要没有发生 read() 事件， eventfd 中的值将会一直累加 而一旦我们调用 read() 函数将 eventfd 保存的值读了出来，在没有新的值加入之前，再次调用 read() 方法时会发生阻塞，直到有人重新向 eventfd 写入值 eventfd 实现的是计数的功能，只要 eventfd 计数不为 0 ，那么表示 fd 是可读的。结合 epoll 的特性，我们可以使用非常轻松的创建一个生产者/消费者模型，消费者大部分时候处于阻塞休眠状态，而一旦有请求入队，消费者就立马唤醒处理 Handler 机制的底层逻辑就是 epoll + eventfd，好，有了 epoll 、 eventfd 基础，我们开始正式进入 Handler 的 Native 世界 二、进入Native Handler 绝大多数 Android 工程师都或多或少的了解过 Handler 机制，所以关于 Handler 的基本使用和实现的原理我们就不过多赘述了，直奔主题 我们来重点关注 MessageQueue 类中的几个 jni 方法：nativeInit()、nativePollOnce() 和 nativeWake()，它们分别对应了 Native 消息队列中的 初始化消息队列、 消息的循环与阻塞 以及 消息的分送与唤醒 这三大环节 /frameworks/base/core/java/android/os/MessageQueue.java class MessageQueue { private native static long nativeInit(); private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/ private native static void nativeWake(long ptr); } 消息队列的初始化 先来看第一步，消息队列的初始化流程 Java MessageQueue 构造函数中会调用 nativeInit() 方法，同步在 Native 层也会创建一个消息队列 NativeMessageQueue 对象，用于保存 Native 开发者发送的消息 /frameworks/base/core/java/android/os/MessageQueue.java MessageQueue(boolean quitAllowed) { mQuitAllowed = quitAllowed; mPtr = nativeInit(); } 在创建 NativeMessageQueue 对象时又会触发创建 Looper 对象 /frameworks/base/core/jni/android_os_MessageQueue.cpp class android_os_MessageQueue { void android_os_MessageQueue_nativeInit() { NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); } NativeMessageQueue() { mLooper = Looper::getForThread(); if (mLooper == NULL) { mLooper = new Looper(false); Looper::setForThread(mLooper); } } } 这里创建 Looper 对象的处理逻辑和 Java 一样，先去线程局部存储区获取 Looper 对象，如果为空，创建一个新的 Looper 对象并保存到线程局部存储区 我们继续，接着来看 Native Looper 初始化流程 /system/core/libutils/Looper.cpp class looper { Looper::Looper() { int mWakeEventFd = eventfd(); rebuildEpollLocked(); } void rebuildEpollLocked(){ int mEpollFd = epoll_create();//哎，这儿非常重要，在 Looper 初始化时创建了 epoll 对象 epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);//把用于唤醒消息队列的eventfd 添加到 epoll 池 } } 关键的地方来了！ Looper 的构造函数首先创建了 eventfd 类型的 fd ：mWakeEventFd，它的作用就是用来监听 MessageQueue 是否有新消息加入，这个对象非常重要，一定要记住它！ 随后调用的 rebuildEpollLocked() 方法中，又创建了 epoll 对象：mEpollFd，并将用来监听消息队列的 mWakeEventFd 添加到 epoll 池 这两步执行完成以后，任一生产者向 mWakeEventFd 写入值时，作为消费者，APP 进程的 main 线程都将会被唤醒 好了，Handler 两大核心对象 mEpollFd 和 mWakeEventFd 创建成功，我们来总结一下消息队列的初始化流程： Java 层初始化消息队列时，同步调用 nativeInit() 方法，在 native 层创建了一个 NativeMessageQueue 对象 Native 层消息队列被创建的同时，也会创建一个 Native Looper ，它用于处理三件事： native 注册的自定义 Fd 引起的事件消息、消息队列被唤醒和超时以及分发 Native 消息队列中的到期消息 在创建 Native Looper 的过程中，调用 eventfd() 生成 mWakeEventFd，它是后续用于唤醒消息队列的核心 初始化 Native Looper 的最后一步调用了 rebuildEpollLocked() 方法，在其中调用 epoll_create() 初始化了一个 epoll 实例 mEpollFd ，然后使用 epoll_ctl() 方法将 mEpollFd 注册到 epoll 池 至此，Native 层的消息队列初始化完成 消息的循环与阻塞 消息队列创建完以后，整个线程就会阻塞到 Looper#loop() 方法中，在 Java 层的的调用链大致是这样的： Looper#loop() -&gt; MessageQueue#next() -&gt; MessageQueue#nativePollOnce() } 最后一步调用的 nativePollOnce() 又是一个 jni 方法，我们接着往下跟，看看 Native 中做了些什么 /frameworks/base/core/jni/android_os_MessageQueue.cpp class android_os_MessageQueue { //jni方法，转到 NativeMessageQueue#pollOnce() void android_os_MessageQueue_nativePollOnce(){ nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis); } class NativeMessageQueue : MessageQueue { /转到 Looper#pollOnce() 方法 void pollOnce(){ mLooper-&gt;pollOnce(timeoutMillis); } } } 可以看到 NativeMessageQueue 中什么都没做，只是把 nativePollOnce() 方法请求转发给了 Looper 主要的逻辑都在 Looper 中，我们从 Looper#pollOnce() 方法接着往下看 //system/core/libutils/Looper.cpp class looper { int pollOnce(int timeoutMillis){ int result = 0; for (;;) { if (result != 0) { return result; } result = pollInner(timeoutMillis);//超时 } } int pollInner(int timeoutMillis){ int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);//调用 epoll_wait() 等待事件的产生 } } 看到了吗？ pollOnce() 方法中会不停的轮询检查 pollInner() 的返回值，不等于 0 就返回给上层，这里的 result 类型是在 Looper.h 文件中声明的枚举类，一共有4种结果： -1 表示在超时时间到期之前使用 wake() 唤醒了轮询，通常是有需要立刻执行的新消息加入了队列 -2 表示多个事件同时发生，有可能是新消息加入，也有可能是监听的 自定义 fd 发生了 I/O 事件 -3 表示设定的超时时间到期了 -4 表示错误，不知道哪里会用到 而如果消息队列中没消息，或者设定的超时时间没到期，再或者用户自定义 fd 没有事件发生，都会导致线程最终会阻塞到 pollInner() 方法中， pollInner() 中则是使用了 epoll_wait() 方法等待事件的产生 总结一下，消息队列在初始化成功以后，Java 层的 Looper#loop() 会开始无限轮询，不停的获取下一条消息。如果消息队列为空，调用 epoll_wait 使线程进入到阻塞态，让出 CPU 调度 从 Java 到 Native 整个调用流程大致是这样的： Looper#loop() -&gt; MessageQueue#next() -&gt; MessageQueue#nativePollOnce() -&gt; NativeMessageQueue#pollOnce() //注意，进入 Native 层 -&gt; Looper#pollOnce() -&gt; Looper#pollInner() -&gt; epoll_wait() 消息的发送/唤醒机制 好，现在的消息队列里面是空的，经过上一小节的分析，我们发现用户线程阻塞到了 native 层的 Looper#pollInner() 方法调用中，我们来向消息队列发送一条消息唤醒它 前面我们说了，Java 和 Native 都各自维护了一套消息队列，所以他们发送消息的入口也不一样 Java 开发使用 Handler#sendMessage() / post()，C/C++ 开发使用 Looper#sendMessage() 我们先来看 Java /frameworks/base/core/java/android/os/Handler.java class Handler { boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; return queue.enqueueMessage(msg, uptimeMillis); } } /frameworks/base/core/java/android/os/MessageQueue.java class MessageQueue { boolean enqueueMessage(Message msg, long when) { //...按照到期时间将消息插入消息队列 if (needWake) { nativeWake(mPtr); } } } 在使用 Handler 发送消息时，不管调用的是 sendMessage 还是 post，最后都是调用到 MessageQueue#enqueueMessage() 方法将消息入列，入列的顺序是按照执行时间先后排序 如果我们发送的消息需要马上被执行，那么将 needWake 变量置为 true，接着使用 nativeWake() 唤醒线程 nativeWake() 方法也是 jni 调用，请求经过层层转发，最终会调用到 Native Looper 中的 wake() 方法，在此过程中的调用链比较清晰而且非常简单，这里就不展示了 Java 发送消息的方式聊完了，然后我们看 Native 层如何发送消息 /system/core/libutils/Looper.cpp class looper { void Looper::sendMessageAtTime(uptime, handler,message) { int i = 0; int messageCount = mMessageEnvelopes.size(); while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) { i += 1; } mMessageEnvelopes.insertAt(messageEnvelope(uptime, handler, message), i, 1); // Wake the poll loop only when we enqueue a new message at the head. if (i == 0) { wake(); } } } Native 层通过 sendMessageAtTime() 方法向消息队列发送消息，添加消息的处理逻辑和 Java 处理逻辑是类似的，唯一有区别的一点是 Java 消息队列使用的链表结构，而 Native 层使用的是集合 按照时间的先后顺序添加到 mMessageEnvelopes 集合中，执行时间离得最近的消息被放在前面，如果发现需要唤醒线程，则调用 wake() 方法 我们发现，当需要唤醒线程时，Java 和 Native 都会执行到 Looper#wake() 方法 之前我们说Handler 机制的底层逻辑就是 epoll + eventfd，读者朋友不妨大胆猜一下，这里的线程是怎么被唤醒的？ /system/core/libutils/Looper.cpp class looper { void Looper::wake() { int inc = 1; write(mWakeEventFd, &amp;inc); } } 答案非常简单，write() 一行方法调用，向 mWakeEventFd 写入了一个 1（提醒一下，mWakeEventFd 的类型是 eventfd ） eventfd 被写入值后，状态会从 不可读 变成 可读，而 epoll 监听到 fd 状态发生变化后，将事件从内核返回给 epoll_wait() 调用，线程的阻塞态将会被取消，继续向下执行 好，我们来总结一下消息的发送与唤醒中几个关键的步骤： Java 层的 Handler 发送消息，会调用到消息队列的 enqueueMessage() 方法，如果消息需要马上执行，那么调用 nativeWake() 执行唤醒，由 Native 层的 Looper#wake() 响应最终的唤醒请求 Native 层通过 Looper#sentMessageAtTime() 来发送消息，处理逻辑与 Java 类似，如果需要唤醒线程，调用 Looper#wake() Looper#wake() 唤醒方法中，调用 write() 方法向 mWakeEventFd 写入 1 初始化队列时为 mWakeEventFd 注册了 epoll 监听，所以一旦有来自于 mWakeEventFd 的新内容， epoll_wait() 阻塞调用就会返回，这里就已经起到了唤醒队列的作用 消息的发送与唤醒的流程基本上结束了，接下来是 Handler 机制的重头戏：线程唤醒后的消息分发处理 唤醒后消息的分发处理 线程在没有消息需要处理时会阻塞在 Looper#pollInner() 方法调用，唤醒同样也是在 pollInner() 方法中执行 线程醒来以后，先判断自己为什么醒过来，再根据唤醒类型执行不同的逻辑 pollInner() 方法稍微有点长，关键步骤我作了标记，我们一点点来捋 /system/core/libutils/Looper.cpp class looper { int pollInner(int timeoutMillis){ int result = POLL_WAKE; // step 1，epoll_wait 方法返回 int eventCount = epoll_wait(mEpollFd, eventItems, timeoutMillis); if (eventCount == 0) { // 事件数量为0表示，达到设定的超时时间 result = POLL_TIMEOUT; } for (int i = 0; i &lt; eventCount; i++) { if (eventItems[i] == mWakeEventFd) { // step 2 ，清空 eventfd，使之重新变为可读监听的 fd awoken(); } else { // step 3 ，保存自定义fd触发的事件集合 mResponses.push(eventItems[i]); } } // step 4 ，执行 native 消息分发 while (mMessageEnvelopes.size() != 0) { if (messageEnvelope.uptime &lt;= now) { // 检查消息是否到期 messageEnvelope.handler-&gt;handleMessage(message); } } // step 5 ，执行 自定义 fd 回调 for (size_t i = 0; i &lt; mResponses.size(); i++) { response.request.callback-&gt;handleEvent(fd, events, data); } return result; } void awoken() { read(mWakeEventFd) ;// 重新变成可读事件 } } step 1 ： epoll_wait 方法返回说明有事件发生，返回值 eventCount 是发生事件的数量。如果为0，表示达到设定的超时时间，下面的判断逻辑都不会走，不为0，那么我们开始遍历内核返回的事件集合 eventItems，根据类型执行不同的逻辑 step 2 ： 如果事件类型是消息队列的 eventfd ，说明有人向消息队列提交了需要马上执行的消息，我们只需把消息队列的 eventfd 数据读出来，使他重新变成可以触发 可读事件 的 fd，然后等待方法结束就行了 step 3 ： 事件不是消息队列的 eventfd ，说明有其他地方注册了监听 fd，那么，我们将发生的事件保存到 mResponses 集合中，待会需要对这个事件做出响应，通知注册对象 step 4 ： 遍历 Native 的消息集合 mMessageEnvelopes，检查每个消息的到期时间，如果消息到期了，交给 handler 执行分发，分发逻辑参考 Java Handler step 5 ： 遍历 mResponses 集合，把其他地方注册的 自定义 fd 消费掉，响应它们的回调方法 唤醒以后执行的步骤稍微有点多哈，我们把关键流程总结一下： 用户线程被唤醒后，优先执行 Native 层的消息分发，紧接着，回调通知自定义 fd 发生的事件（如果有的话），然后 pollInner() 方法结束，返回到 Java 层 Looper#loop() 方法。在 Looper 中最后执行到 Java 层的消息分发，只有当 Java Handler 执行完消息分发，一次 loop() 循环才算是完成 再之后， Looper#loop() 会再一次进入循环，继续调用 next() 方法获取消息、阻塞到 pollInner() 、从 pollInner() 唤醒执行分发，执行结束接着进入下一次循环，无尽的轮回 main 线程的一生都将重复这一流程，直到 APP 进程结束运行.. 三、结语 以上就是 Handler Native 世界的全部内容，主要介绍了 Java MessageQueue 中几个关键的 jni 方法在底层是如何实现的 将全部的代码逻辑分析完以后，我们会发现 Native Handler 的实现不算复杂，关键的阻塞与唤醒部分是借助了 Linux 系统 epoll 机制来实现的 所以，我们只要理解了 epoll 机制，再打开源码看看 Looper#pollInner() 中的内部逻辑，就能明白整个 Handler 机制是怎么一回事了 本篇文章到这里就结束了，希望能对大家有帮助 全文完 四、参考资料 Scalable Event Multiplexing: epoll vs. kqueue epoll 或者 kqueue 的原理是什么？- 知乎 - 蓝形参的回答 Android 消息机制Native层消息机制 - 吴迪 Linux 网络编程的5种IO模型：阻塞IO与非阻塞IO ","link":"https://yibaoshan.github.io/post/android-components-handler-native/"},{"title":"Android图形系统（四）应用篇：自定义View/ViewGroup详解","content":" 点击跳转到掘金阅读 相信大多数的 Android 开发者都有过开发自定义 View 的经历，以我个人的工程经验来看，自定义 View 大体可以分为三种：改装、组合和自定义 改装指的是继承自某个控件，在原有功能的基础上进行增删改，比如：基于 ViewPager 打造一个无限循环的轮播图控件 组合指的是将2个以上的控件组合成一个控件，比如：基于 RelativeLayout + 多个 EditText 组合成一个密码输入控件 自定义指的是当 Android 官方控件不足以满足业务需求（比如统计图表中的饼状图/折线图）时，继承 View / ViewGroup 类，重写 onMeasure()、onLayout()、onDraw() 三大方法，从 0 到 1 创造一个新的控件 本篇是图形系列的第四篇文章，今天我们来聊聊在自定义 View / ViewGroup 过程中各个阶段发生的事情 一、测量阶段 在 Android 系统中，一个 View 的绘制显示必须要经过测量、布局和绘制这三个步骤 测量是为了计算每一个 View 需要的大小，View 和 ViewGroup 都需要重写 onMeasure() 方法来确定自己的尺寸 布局是为了计算每一个 View 的位置，通常只需要 ViewGroup 重写 onLayout() 方法，根据容器的属性合理的摆放子 View 绘制是最终绘图的阶段，所有的绘图操作都在 draw 阶段得到执行，通常需要 View 重写 onDraw() 方法 我们先来看第一步的测量流程 图片来源：自己画的 在上一篇文章中，我们介绍了测量流程是由 ViewRootImpl 类中的 performTraversals() 方法发起的，经过层层转发，最终会调用到每个 View 的 onMeasure() 方法 View 真正的尺寸信息就是在 onMeasure() 方法中被确定的 那么 View 是根据什么来确定自己应当具有多大的尺寸呢？不可能让子 View 自由地决定自己的大小吧，父 View 必然需要向子 View 传递信息来帮助子 View 来确定尺寸 什么是 MeasureSpec 查看 measure() 的方法签名： void measure(int widthMeasureSpec, int heightMeasureSpec) widthMeasureSpec 和 heightMeasureSpec 就是帮助子 View 确定大小的参数 它们的类型是 int，内部以高两位来存储测量的模式，低三十位为测量的大小，计算中使用了位运算来提高并优化效率 当然，我们不必使用位运算来获得对应的数值，MeasureSpec 类为我们提供了对应的方法 class MeasureSpec { int UNSPECIFIED;//未指定，不限制大小 int EXACTLY;//精确模式 int AT_MOST;//最大模式 int getMode(int measureSpec) return (measureSpec &amp; MODE_MASK); int getSize(int measureSpec) return (measureSpec &amp; ~MODE_MASK); } MeasureSpec 声明了三种测量模式： UNSPECIFIED ：未指定模式，也可以称为无限制模式。当你收到此模式时，表明父视图不关心你的尺寸大小，你可以随意设置自己的尺寸信息。什么情况下可能收到 UNSPECIFIED 呢？比如当你的父视图是可以纵向滚动的 ScrollView ，那子视图的高度大小对于父视图来说没有意义。无论你多高（即使超出屏幕），都可以通过滑动屏幕来查看（同理，如果是横向滚动那么宽度就没有意义） EXACTLY ：精确模式。当你收到此模式时，表示父视图希望你就这么大（不要小于或大于给定的大小），通常在 xml 中指定大小或者设为 match_parent 时会收到 EXACTLY 模式 AT_MOST ：最大模式。当你收到此模式时，表示你可以在父视图给定的范围内随意发挥，但最好不要超过父视图给你的大小，通常在 xml 中设为 wrap_content 时会收到 AT_MOST 模式 看到这里或许已经有同学发现了，View 的测量模式好像和我们在 xml 中指定的宽高有关： View 设置为 match_parent 或固定值时，将会收到 EXACTLY 精确模式 View 设置为 wrap_content 时，将会收到 AT_MOST 最大模式 事实真的如此吗？我们接着往下看 MeasureSpec 是由什么决定的 关于 View 测量模式的创建规则，网上有张图流传的比较广 图片来源：自己拍的 上图是任主席在2015年出版的 《Android开发艺术探索》 第四章的拍摄图，图中的表格非常详细了展示了一个 “普通 View” 的 MeasureSpec 的创建规则 如果你的自定义 View 的父视图是 FrameLayout 、LinearLayout 、RelativeLayout，恭喜你，这些规则适用于你 但如果你的父视图是 ScrollView、RecyclerView 等支持滚动的 ViewGroup，那么你收到的测量模式多半和上图描述的不符 接下来通过几组测试来验证一下我们的想法： 我们用 FrameLayout 和 ScrollView 作为测试的父视图，TextView 作为测试的子 View 然后对父视图和子 View 分别设置不同的 LayoutParams 属性，观察它们在不同宽高模式下的表现： 图片来源：自己截图 测试的代码可以点击这里查看，测试的详细数据可以点击这里查看 从测试的结果来看，我们可以得出几个比较有趣的结论： FrameLayout + TextView 的组合，子 View 得到的测量模式和预期表现相同 FrameLayout 为 wrap_content 时（第二轮第1组），如果子 View 设置为 match_parent，那子 View 将会收到两次测量，最终的 MeasureSpec 固定为 EXACTLY 在 FrameLayout 中，如果子 View 宽高设置为固定值，且期望大小超过了父视图（第三轮第3组测试）时，父视图返回的宽高是我们设定的值。同理，如果子 View 的设置的大小超过屏幕实际宽高系统，父视图返回的依旧是设定的值，即使它非常不合理 在 ScrollView 中，无论子 View 是 math_parent 、wrap_content 还是固定值，或者说不管子 View 申请的高度是大于父视图还是小于父视图的高度，ScrollView 统统指定为自身高度，Mode 为 UNSPECIFIED 我们发现一旦使用 ScrollView 作为父视图，那么 “match_parent / wrap_conent 对应 EXACTLY/ AT_MOST” 这套规则将不再适用 为什么 ScrollView 会如此特殊呢？ 原因也很简单，因为它不是调用 getChildMeasureSpec() 方法为子 View 生成的测量结果，而是直接调用 makeMeasureSpec() 方法为子 View 指定了测量模式与大小 void measureChild() { ViewGroup.LayoutParams lp = child.getLayoutParams(); int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,lp.width); int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(parentSize,MeasureSpec.UNSPECIFIED);//高度指定为parentSize child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 到这里，我们就可以来尝试回答小标题的问题：MeasureSpec 是由什么决定的？ 大多数情况下，父视图通过调用 getChildMeasureSpec() 方法为子 View 生成测量结果，那么子 View 的MeasureSpec 是由父视图的 SpecMode 和 子 View 自身的 LayoutParams 共同决定的 当父视图是调用 makeMeasureSpec() 方法为子 View 指定测量结果时（比如示例中的 ScrollView），子 View 的MeasureSpec 是由父视图的业务属性决定的！ 关于 MeasureSpec 的介绍暂时告一段落，接下来进入本小节正题：View 的测量 View 的测量过程 View 的测量过程是自顶向下的过程，我们可以把 View 当做一棵以 DecorView 作为 root 节点的多叉树，测量事件会以深度优先的顺序遍历整棵树 View 的测量工作是在 onMeasure() 方法中进行的，我们在自定义 View 时需要重写 onMeasure() 方法并执行测量工作，接着再调用 setMeasuredDimension() 方法将测量的结果保存起来 我们也可以选择不重写 onMeasure() 方法，因为 Android 系统为我们提供了默认实现 /frameworks/base/core/java/android/view/View.java class View { void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int width = getDefaultSize(widthMeasureSpec); int height = getDefaultSize(heightMeasureSpec); setMeasuredDimension(width,height);//保存宽高值 } int getDefaultSize(int size, int measureSpec) { switch (specMode) { case MeasureSpec.UNSPECIFIED://注意，如果接收到未指定模式，一定要为View设置背景或者设置最小高度 result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result; } } 在默认实现的 onMeasure() 方法中，会先调用 getDefaultSize() 方法为自己生成宽高信息，接着会调用 setMeasuredDimension() 方法将刚刚获取的宽高值保存起来 getDefaultSize() 方法中是默认生成视图尺寸的规则： 如果你的 MeasureSpec 是 AT_MOST 或者 EXACTLY，那么你得到的 size 和父视图相同 如果你的 MeasureSpec 是 UNSPECIFIED，那么你的尺寸将会取背景尺寸或者最小宽高中最大的那个值 从 getDefaultSize() 方法代码逻辑来看，建议大家在自定义 View 时最好重写 onMeasure() 方法，最起码要处理 MeasureSpec 为 UNSPECIFIED 的情况，否则，一旦你的 MeasureSpec 被指定为 UNSPECIFIED，且 View 没有设置最小宽高，那么你将无法在屏幕上看到它，因为它的高度或者宽度为 0 ！ 总结一下 View 在测量流程完成的事情： 根据父视图传递的 MeasureSpec，合理的计算自己所需的尺寸大小 在确定了自身尺寸后，调用 setMeasuredDimension() 方法保存尺寸信息 ViewGroup 的测量过程 当 ViewGroup 中的所有子 View 全部测量完以后，接下来就该轮到 ViewGroup 为自己计算高度了 和 View 的测量过程相比，Android 并没有为 ViewGroup 的 onMeasure() 方法提供默认实现 这是因为不同的容器的业务逻辑都不一样，即使同一个容器，也可能因为适用场景的差别而使用不同的测量策略 拿 LinearLayout 来举例，在高度设置为 wrap_content 的情况下： 如果是横向布局，LinearLayout 的高度应该是最大子 View 的高度 如果是纵向布局，LinearLayout 的高度应该为所有子View的高度总和 虽然 ViewGroup 的 onMeasure() 方法没有默认实现，但是， Android 为 ViewGroup 准备了几个测量子 View 的方法，因为在大多数情况下各个子 View 的测量方式都是一样的，一起来看看 /frameworks/base/core/java/android/view/ViewGroup.java class ViewGroup extends View { //测量子视图 void measureChild() { LayoutParams lp = child.getLayoutParams(); int childWidthMeasureSpec = getChildMeasureSpec(); int childHeightMeasureSpec = getChildMeasureSpec(); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } //测量子视图并计算其Margin void measureChildWithMargins() { MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); int childWidthMeasureSpec = getChildMeasureSpec(); int childHeightMeasureSpec = getChildMeasureSpec(); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } //获取子View的MeasureSpec，对于ViewGroup来说，这是非常重要的一个方法！！！ int getChildMeasureSpec(int spec, int padding, int childDimension) { ... } } ViewGroup 类中默认提供了3个测量子 View 的方法： measureChild()：调用 getChildMeasureSpec() 方法生成子视图的 MeasureSpec ，成功后通知子视图执行 measure() 方法 measureChildWithMargins() ：调用 getChildMeasureSpec() 方法生成子视图的 MeasureSpec ，成功后通知子视图执行 measure() 方法 getChildMeasureSpec()：根据父视图的 MeasureSpec 和 子视图的 LayoutParams 属性来生成 子视图的 MeasureSpec measureChild() 和 measureChildWithMargins() 都调用了 getChildMeasureSpec() 方法来为子 View 生成 MeasureSpec，两个方法唯一区别是后者使用了 MarginLayoutParams，在计算子视图可用空间时会考虑到 Margin 的部分 什么是 MarginLayoutParams 呢？ 1、初识 LayoutParams View 有 top 、bottom 、left 、right 和 padding 这几个属性，记录的是这个 View 在屏幕坐标系中的绝对位置，但它这几个属性只有在 layout 阶段以后才会有具体的值 在没有确定 View 的绝对位置之前，Android 用 LayoutParams 来描述一个 View / ViewGroup 的宽高值 //描述View/ViewGroup的宽高值 class LayoutParams { int MATCH_PARENT = -1; int WRAP_CONTENT = -2; //视图的宽高属性，小于0表示为WRAP_CONTENT/MATCH_PARENT，大于0表示为具体的尺寸 int width; int height; } LayoutParams 使用 width 和 height 属性来描述宽高，如果小于0表示为 WRAP_CONTENT / MATCH_PARENT，大于0则表示为具体的尺寸 ViewGroup 中还有一个叫 MarginLayoutParams 的静态内部类，它继承自 LayoutParams 并在其基础上增加了上下左右间距值 我们日常使用的 ViewGroup 中凡是支持设置 margin 属性的都是继承自 MarginLayoutParams，如果你想要在代码中动态的修改 View 的 margin 属性，记得强转为 MarginLayoutParams 类型再进行操作 //在宽高值的基础上增加了上下左右间距值，凡是支持设置margin的容器都是继承自MarginLayoutParams class MarginLayoutParams extends ViewGroup.LayoutParams { leftMargin; topMargin; rightMargin; bottomMargin; ... } MarginLayoutParams 虽然是 View 的属性之一，但它描述的间距值并不算在 View 的可用空间，在计算视图大小时，margin 是算到父视图的可用空间里，只有 padding 才是算到自己的可用空间 2、生成 ChildView MeasureSpec 关于 LayoutParams 暂时先告一段落，在后面 layout 阶段会再次介绍，它是 ViewGroup 能够正确摆放子视图的重要依据 接下来我们开始 ViewGroup 最核心的逻辑，如何为子 View 生成 MeasureSpec ？ 前面说了 Android 虽然没有为 ViewGroup 提供 onMeasure() 方法的默认实现，但 Android 为 ViewGroup 准备了几个测量子 View 的方法 在这几个测量子 View 的方法中，最重要的当属 getChildMeasureSpec() 方法 /frameworks/base/core/java/android/view/ViewGroup.java class ViewGroup extends View { int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec);//父视图的 SpecMode int specSize = MeasureSpec.getSize(spec);//父视图的大小 int size = Math.max(0, specSize - padding);//子视图可用空间大小为：父视图大小 - 父视图 padding - 子视图 margin int resultSize = 0; int resultMode = 0; switch (specMode) { case MeasureSpec.EXACTLY: // 父视图为 EXACTLY 时 if (childDimension &gt;= 0) resultSize = childDimension;// 子视图设置的大小为固定值时，听子视图的，我不管你，爱多大就多大，模式也给你精确模式 EXACTLY resultMode = MeasureSpec.EXACTLY;/ if (childDimension == LayoutParams.MATCH_PARENT) { resultSize = size;// 子视图为 MATCH_PARENT ，把你的大小设置和父视图相同，值固定了，模式给你精确模式 EXACTLY resultMode = MeasureSpec.EXACTLY; if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = size;// 子视图为 WRAP_CONTENT，爸爸也不知道你要多大，把我的全部都给你，模式指定为最大模式，你在这个范围内随意发挥 resultMode = MeasureSpec.AT_MOST; case MeasureSpec.AT_MOST: // 父视图为 AT_MOST 时 if (childDimension &gt;= 0) { resultSize = childDimension;// 同上，子视图设置的大小为固定值时，听子视图的，我不管你，爱多大就多大，模式也给你精确模式 EXACTLY resultMode = MeasureSpec.EXACTLY; if (childDimension == LayoutParams.MATCH_PARENT) { resultSize = size;// 虽然子视图是 MATCH_PARENT 但父视图我自个是 AT_MOST，那怎么办？我多大你多大呗，将模式指定为最大模式，在我给你这个范围内随意发挥好了 resultMode = MeasureSpec.AT_MOST; if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = size;// 同上，把父视图的全部都给你，模式指定为最大模式，你在这个范围内随意发挥 resultMode = MeasureSpec.AT_MOST; case MeasureSpec.UNSPECIFIED: // 父视图为 UNSPECIFIED 时 if (childDimension &gt;= 0) { resultSize = childDimension;// 不管父视图我是什么模式，只要你设置了具体值，你爱多大多大 resultMode = MeasureSpec.EXACTLY; if (childDimension == LayoutParams.MATCH_PARENT) { resultSize = sUseZeroUnspecifiedMeasureSpec ? 0 : size;// 子视图想和我一样大？ 满足你，模式给你 UNSPECIFIED，ps：sUseZeroUnspecifiedMeasureSpec 默认为false resultMode = MeasureSpec.UNSPECIFIED; //mode为 if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = sUseZeroUnspecifiedMeasureSpec ? 0 : size;// 你也不知道自己多大，那我就把自己的尺寸给你，模式也给你我的模式 UNSPECIFIED resultMode = MeasureSpec.UNSPECIFIED; } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } } getChildMeasureSpec() 中的逻辑是根据父视图的 MeasureSpec 和 子 View 的 LayoutParams 来生成 MeasureSpec，规则如下： 父视图为 EXACTLY 时 子视图设置的大小为固定值，听子视图的，我不管你，爱多大就多大，模式也给你精确模式 EXACTLY 子视图为 MATCH_PARENT ，把你的大小设置和父视图相同，值固定了，模式给你精确模式 EXACTLY 子视图为 WRAP_CONTENT，爸爸也不知道你要多大，把我的全部都给你，模式指定为最大模式，你在这个范围内随意发挥 父视图为 AT_MOST 时 子视图设置的大小为固定值，听子视图的，我不管你，爱多大就多大，模式也给你精确模式 EXACTLY 子视图为 MATCH_PARENT，虽然子视图是 MATCH_PARENT 但父视图我自个是 AT_MOST，那怎么办？我多大你多大呗，将模式指定为最大模式，在我给你这个范围内随意发挥好了 子视图为 WRAP_CONTENT，把父视图的全部都给你，模式指定为最大模式，你在这个范围内随意发挥 父视图为 UNSPECIFIED 时 子视图设置的大小为固定值，不管父视图我是什么模式，只要你设置了具体值，你爱多大多大 子视图为 MATCH_PARENT，子视图想和我一样大？ 满足你，模式给你 UNSPECIFIED 子视图为 WRAP_CONTENT，你也不知道自己多大，那我就把自己的尺寸给你，模式也给你我的模式 UNSPECIFIED 我们将 getChildMeasureSpec() 方法中 ChildView MeasureSpec 的生成规则统计起来（见下图）就是 《Android开发艺术探索》 中表格的内容 图片来源：https://www.yuque.com/docs/share/c2296195-b016-49d3-a7d4-30775b2c0f3f 接下来我们通过一段示例代码来演示一下 getChildMeasureSpec() 方法在 LinearLayout 中的实战使用 /frameworks/base/core/java/android/widget/LinearLayout.java class LinearLayout extends ViewGroup { int mTotalLength = 0; void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int maxWidth =0; for (int i = 0; i &lt; count; ++i) { measureChildWithMargins(child);//为每个子 View 创建 MeasureSpec并通知执行 measure maxWidth = Math.max(maxWidth,child.getWidth());// 更新 LinearLayout 的最大宽度 mTotalLength += child.getHeight();// 获取每个View高度，累加结果 LinearLayout 的高度 } setMeasuredDimension(maxWidth,mTotalLength);//设置自身尺寸 } void measureChildWithMargins(View child) { int width = getChildMeasureSpec(); int height = getChildMeasureSpec(); child.measure(width, height);// 通知子 View 执行 measure } void getChildMeasureSpec();//为子 View 生成 MeasureSpec } 示例代码演示的是一个纵向的 LinearLayout 测量过程： 调用了 measureChildWithMargins() 方法为每个子 View 创建 MeasureSpec 并通知其执行 measure 子 View 测量完成后，获取每个子 View 的高度累加到成员变量 mTotalLength ，同时不断更新最大宽度的子 View，它的宽度就是 LinearLayout 将来的宽度 循环结束表示所有子 View 全都测量完成，调用 setMeasuredDimension() 方法保存自身尺寸信息 当 LinearLayout 的测量工作结束后，会开始执行它的父视图的测量流程，直到最顶部的 DecorView 的 measure 方法执行结束，到那时，整个视图所依附的 Window 的大小才可以确定下来 onMeasure() 执行多次的原因 有过自定义 View / ViewGroup 开发经验的小伙伴肯定知道，View 的 onMeasure() 方法可能会存在被多次调用的情况 尤其在首次加载 Activity 时，每个 View 最少也会执行2次 onMeasure() 方法 这2次调用都发生在 ViewRootImpl 类的 performTraversals() 方法中，其他的几次调用有的也还是发生在 ViewRootImpl 中，有的则是 ViewGroup 的个人行为，我们接着往下看 1、创建 Surface 引起的二次调用 上一篇文章中我们知道了 ViewRootImpl 里面管理着一个 Surface 对象 View 必须依托 Surface 对象才能够显示绘制，所以，在 View 执行测量工作之前，Surface 的大小必须先确定下来 Surface 的大小什么时候确定的呢？我们来看 ViewRootImpl#performTraversals() 方法中的逻辑 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { void performTraversals() { if(layoutRequested){//APP发起requestLayout请求 boolean 视图尺寸发生变化 = measureHierarchy();//① 执行日常测量工作 } if(首次添加视图/视图尺寸发生变化等){ relayoutWindow();//Window大小确定下来以后，去sf申请对应大小的surface performMeasure();//② 申请到surface后再次测量，此方法结束后，该window的大小将会被确定，除非window的尺寸发生改变，否则不会再次执行该方法 } } boolean measureHierarchy(){//执行测量，并返回和缓存的窗口大小比，新的测量尺寸是否发生变化 performMeasure(); } void performMeasure() { mView.measure(); } } 在 performTraversals() 方法中可以看到，当我们发起 requestLayout 请求时，最终是由 measureHierarchy() 方法来执行测量工作 测量工作结束后，接着判断是不是首次添加视图或者测量得到的结果与缓存窗口尺寸不符 如果是首次添加视图，说明 Surface 之前不存在，需要重新创建 如果调用 measureHierarchy() 方法得到的测量结果与缓存不符，说明 Window 的大小发生变化，需要重新申请Surface 只要满足以上条件，ViewRootImpl 便会携带测量得到的宽高值去调用 relayoutWindow() 方法，请求 SF 进程创建一个符合尺寸要求的 Surface 等到 relayoutWindow() 方法返回，一个和 DecorView 大小相同的 Surface 便创建成功。 在创建 Surface 的过程中，一共执行了两次测量（代码中标记为1/2号）： 第一次是在 measureHierarchy() 方法中调用了 performMeasure() 执行测量工作 第二次是在 relayoutWindow() 方法申请到 Surface 以后，再次调用 performMeasure() 发起的测量 这两次测量就是首次加载 Activity 时，View 都会执行2次 onMeasure() 方法的原因！ 2、Dialog 可能会引发多次调用 在了解创建 Surface 会导致二次调用 onMeasure() 方法的原因后，我们来看下面的这张表格： 图片来源：自己截图 测试代码点击这里查看，详细数据点击这里查看 这张表格的数据来自我自己做的一个小测试，测试的步骤很简单：自定义一个 ViewGroup 继承自 FrameLayout，在不同的 Activity 主题下，记录 onMeasure() 方法的执行次数 从测试的结果来看，普通的 Activity + FrameLayout 的组合，在首次加载 Activity 时 onMeasure() 方法被调用了2次，在我们手动请求 requestLayout() 以后 onMeasure() 方法执行了一次，测试结果符合我们的预期 但是，当我们把 Activity 的主题为 Dialog 以后，onMeasure() 方法的调用次数竟然达到了6次！ 再次修改测试条件，我们把根视图的宽度改为和屏幕实际宽度相同以后，发现 onMeasure() 方法的调用次数更是达到了惊人的12次！！ 为什么会发生这么多次的调用？跟踪 performMeasure() 方法的调用链可以发现，多出来的几次调用都是在 measureHierarchy() 方法内发起，那接下来我们就一起来看看 measureHierarchy() 方法里面都做了些什么 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { boolean measureHierarchy(int desiredWindowWidth, int desiredWindowHeight){ //宽度为 WRAP_CONTENT，通常表示是 Dialog 或者是 Dialog 主题的 Activity if (width == ViewGroup.LayoutParams.WRAP_CONTENT) { int baseSize = 读取系统预置的Dialog宽度; //既然是Dialog，Android不希望它充满屏幕，所以这里的宽度被设置为了预设宽度 childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);//高度依旧为屏幕高度，你想要多高自己定 //①进行首次测量 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); //测量结束后，发现视图期望的宽度没有超过预设宽度，goodMeasure设为true，在后续流程中不再执行测量工作，MEASURED_STATE_TOO_SMALL这个flag表示测量尺寸小于视图想要的空间 if ((host.getMeasuredWidthAndState() &amp; View.MEASURED_STATE_TOO_SMALL) == 0) { goodMeasure = true; } else { //视图期望的宽度超过了预置宽度，比如我在xml写死&quot;layout_width=10086px&quot;，那么把baseSize改大一些再次测量试一试 baseSize = (baseSize + desiredWindowWidth) / 2; //②再次执行测量 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); //同样的，在测量执行结束后查看宽度是否满足预期，满足则将goodMeasure设为true，在后续流程中不再执行测量工作 if ((host.getMeasuredWidthAndState() &amp; View.MEASURED_STATE_TOO_SMALL) == 0) { goodMeasure = true; } } } //方法能走到这有两种情况： //1. 该视图是普通的Activity，DecorView宽高不是 WRAP_CONTENT //2. 该视图是Dialog类型，且Dialog想要的宽度很大，系统预设的宽度不满足，再次扩容以后同样不满足，没办法，索性直接给它屏幕的实际宽高让它自己折腾去 if (!goodMeasure) { //③这里的测量方法如果得到执行，要么是第一次调用，要么是第三次调用 performMeasure(childWidthMeasureSpec,childHeightMeasureSpec); } return windowSizeMayChange;//返回和缓存的window相比，测量下来的视图大小是否发生变化 } } 在 measureHierarchy() 方法中，首先会判断 DecorView 的宽度是不是 WRAP_CONTENT，是的话表示该视图可能是个 Dialog 或者是 Dialog 主题的 Activity 如果是 Dialog 类型的视图，Android 不希望它充满屏幕，因此，视图的宽度将会从 屏幕实际宽度 更改为 Dialog 的 系统预设宽度 ，然后执行视图的测量工作 第一次测量完成后，如果该视图期望的宽度比系统预设宽度大，那就用系统预设宽度 + 屏幕实际宽度 / 2算出来的值当做新的宽度要求，再次执行测量工作（比如屏幕实际宽度为100，系统预设宽度为60，新的宽度为(100 + 60) / 2 = 80） 第二次测量完成后，如果扩容后的宽度大小仍然不满足该视图期望值，Android 系统将不再尝试再次测量，等待第三次的最终测量 第三次测量执行之前会先判断 goodMeasure 变量的值，只有当 goodMeasure 为 false 的情况下才会执行测量，什么时候值会为 false 呢？两种情况（看代码注释啊喂）： 视图是普通的 Activity，DecorView 宽不为 WRAP_CONTENT 的情况，那么标记为3号的 performMeasure() 方法将会被执行（第一次调用） 视图是 Dialog 类型，且 Dialog 想要的宽度很大，系统预设宽度不满足，再次扩容以后同样不满足，那么标记为3号的 performMeasure() 方法将会被执行（第三次调用） 在测试中我发现如果把 Activity 设置为 Dialog 主题后，每次 requestLayout() 都会执行3次 performTraversals() 方法，导致同一个调用链也会重复3遍，发生这种情况的原因我暂时不清楚，有了解这块的老哥可以在评论区留言 我们把数据手动去重以后，会发现去重后的调用链会完全符合 measureHierarchy() 方法中的代码逻辑 3、Window 权重导致多次调用 在 ViewRootImpl 的 performTraversals() 方法中，还有一种不怎么常见的场景同样会触发执行 onMeasure() 方法，直接来看代码 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { void performTraversals() { if (lp.horizontalWeight/lp.verticalWeight &gt; 0.0f){///WindowManager.LayoutParams中的垂直/水平方向的权重是否大于0，这玩意不知道在哪可以设置 measureAgain = true; } if(measureAgain)performMeasure(); } } 在 performTraversals() 方法中，会检查 WindowManager.LayoutParams 是否设置权重，如果设置了则会重新执行一次测量 我在源码中全局搜索后，发现只有 Toast 类中会设置 horizontalWeight / verticalWeight 属性，具体代码逻辑我没有深究，感兴趣的同学可以自己点击这里查看源码 到这里，ViewRootImpl 类中所有发起测量的地方我们都分析完了，performMeasure() 方法在源码中一共有5处调用 图片来源：自己截图 在 ViewRootImpl#measureHierarchy() 方法中被调用3次： 在1331行，视图为Dialog 类型时，将视图宽度设置为 Dialog 预置宽度，发起首次测量 在1344行，视图为 Dialog 类型时，预置宽度不满足视图期望值，扩容宽度后再次发起测量 在1358行，goodMeasure 变量为 false 的情况下，两种情况： 该视图是普通的 Activity，发起第一次测量 该视图是 Dialog，且 Dialog 想要的宽度很大，预设宽度和扩容宽度均不满足，给它屏幕实际尺寸发起第三次测量 在 ViewRootImpl#performTraversals() 方法中被调用了2次： 在2024行，每次申请到 Surface 以后，发起一次测量 在2050行，为 Window 设置权重时，再次发起一次测量 注：Android 不同版本代码行数也不同，笔者源码环境是：Android 7.0 4、由 ViewGroup 自身发起调用 除了 ViewRootImpl 入口处会发起多次调用外，各个 ViewGroup 自身的业务逻辑同样会导致 View 的 onMeasure() 方法被多次调用 这部分内容我们可以去看缘佬在 玩 Android 每日一问 onMeasure()多次执行原因？这个问题下的回答 搬一部分缘佬的回答：onMeasure 方法的回调次数，主要取决于它所在的容器的 onMeasure 逻辑，搭配不同 ViewGroup 和设置不同属性都会有影响 比如 LinearLayout 在设置权重属性后就会多执行一次测量流程，在整个测量过程中，LinearLayout 最少会经历1次测量，最多会经历3次 所以由 ViewGroup 自身发起调用次数很难有一个标准、统一的答案，我们这里就不展开讨论了 二、布局阶段 最难的测量任务在上一章节已经结束了，接下来的内容会轻松很多 如果说测量阶段的学习难度是100分的话，那布局阶段可以直接降一个数量级，降到10分（10分我都觉得高了） 布局阶段的任务量主要是在 ViewGroup 一侧，子 View 不参与布局过程，父视图负责把子 View 们按照LayoutParams 规则摆放好 图片来源：自己画的 再谈 LayoutParams 在 ViewGroup 的测量阶段我们认识了 LayoutParams 和 MarginLayoutParams，这里再来简单复习一下： LayoutParams 是 ViewGroup 的内部类，里面有 width / height 两个属性，用来描述一个 View 的宽高 MarginLayoutParams 同样是 ViewGroup 的内部类，继承自LayoutParams，增加了上下左右四个方向的 margin 属性 LayoutParams 是每个 ViewGroup 能够正确摆放子视图的重要依据，除了Android 为 ViewGroup 提供的这两个默认的 LayoutParams 外，每个 ViewGroup 也都会重写一个属于自己的 LayoutParams： FrameLayout.LayoutParams 继承自 MarginLayoutParams，在此基础上增加了 gravity 属性 LinearLayout.LayoutParams 继承自 MarginLayoutParams，在此基础上增加了 weight、gravity 等属性 RelativeLayout.LayoutParams 继承自 MarginLayoutParams，在此基础上增加了 above、below、alignXxx、toXxxOf 等属性 GridLayout.LayoutParams 继承自 MarginLayoutParams，在此基础上增加了 row、column、gravity 等属性 从几个常用布局的 LayoutParams 可以看到，凡是支持设置 margin 属性的都会选择继承自 MarginLayoutParams 想要了解某个 ViewGroup 支持哪些属性，我们可以在 xml 布局文件中直接点击 layot_xx 属性跳转到 attrs.xml 文件，在 attrs.xml 文件中，保存着所有 Android 官方控件支持的属性列表 ViewGroup 的布局过程 layout() 事件的起点和测量事件一样，都在 ViewRootImpl 类中触发，布局流程执行的顺序也和测量流程相同，以 DecorView 作为 View 多叉树的根节点，深度优先遍历整棵树 来看入口函数 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { void performTraversals() { if(发起requestLayout请求){ performLayout(); } } void performLayout(){ mView.layout(mView.getMeasuredWidth(), mView.getMeasuredHeight());//以DecorView的宽高作为起始坐标 } } ViewRootImpl 中判断是否有任一 View 发起过 requestLayout() 请求，有的话执行 performLayout() 方法，从 DecorView 开始向下分发 layout() 事件 接着看 ViewGroup 类收到 layout() 事件后的处理逻辑 /frameworks/base/core/java/android/view/ViewGroup.java class ViewGroup extends View { //View.java中的逻辑，被我挪到这了 void layout(int l, int t, int r, int b){ setFrame(); if(该视图执行了requestLayout()请求，或者视图的位置发生变化){ onLayout(); } } boolean setFrame(int left, int top, int right, int bottom) { //如果视图位置发生变化，保存新的上下左右坐标点位置 } abstract void onLayout(boolean changed,int l, int t, int r, int b); } ViewRootImpl 在向下分发布局事件的过程中，会通知到每个 View 的 layout() 方法，所以在 layout() 方法中，会先判断自己有没有发起过 requestLayout() 请求，没有发起请求说明不需要更新，就不执行 onLayout() 方法了 如果自己调用过 requestLayout() 请求，或者视图的位置发生变化，会将新的位置信息保存下来，然后调用自身的 onLayout() 方法执行布局 在 ViewGroup 中，onLayout() 方法是由 abstract 关键字修饰的空方法，这表示 Android 要求所有继承 ViewGroup 的类必须自行实现 onLayout() 方法 到这里，对于 Android 系统来说，整个布局流程已经执行完成了（开头说的布局很简单没骗你吧），接下来调用的 onLayout() 方法是各个 ViewGroup 自身的业务逻辑 手写一个斜着的线性布局 布局流程过于简单，接下来我准备手写一个可以斜着摆放子 View 的 线性布局 ，在一步步实现功能的过程中理解布局阶段在三部曲中的意义 先看效果 图片来源：自己录的 动图演示的是一个纵向居中排列的 线性布局 ，容器内包含5个 TextView 和 1个 ImageView，点击“ 启用倾斜属性 ”按钮后，ViewGroup 会按照一定的偏移量重新布局，把容器内所有的子 View 以左上到右下对角线的方式斜着摆放 SlantLinearLayout 实现的功能非常简单，代码量也不多，关键代码只有3行： class SlantLinearLayout extends LinearLayout { void onLayout(boolean changed, int l, int t, int r, int b) { for (int i = 0; i &lt; getChildCount(); i++) { int childLeft = (childSpace - childWidth) / 2;//根据父视图的padding和子View的margin、自身测量的宽高，计算每个子View起始位置 int childTop += lp.topMargin;//起始位置加上子View设定的顶部距离 int childOffset = offset * i - (count - i - 1) * offset;//如果用户启用倾斜属性，那么计算每个子View在原先的基础上的偏移量 child.layout(left, top, left + width, top + height);//通知子View执行布局 } } } SlantLinearLayout 的自身宽高和子 View 们的宽高都在测量阶段就已经确定下来了，所以我们直接根据测量的结果来计算每个子 View 所在的位置 childTop 表示每个 View 距离顶部的值，由于容器是纵向的线性排列，所以在确定了第一个距离顶部的高度后，接下来每次累加子 View 自身的高度作为下一个子 View 的起始高度就行了 childLeft 表示每个 View 距离左边的值，由于每个 View 宽度都不一样，所以 childLeft 要动态计算 childOffset 表示每个 View 距离左边的偏移量，如果用户启用倾斜属性，那么计算每个子 View 时需要在原先的基础上的加上设定的偏移量 SlantLinearLayout 的布局过程就是在不停的计算这3个变量的值，然后调用子 View 的 layout() 方法，将计算得到的上下左右位置信息（屏幕坐标系的绝对值）传递给子 View，点击[这里]查看源码 布局阶段结束后，开发者可以调用 getWidth() / getHeight() 方法来获取视图的宽高 三、绘制阶段 绘制流程和之前的测量/布局相比会显得有些特殊，体现在两个方面 一是绘制流程执行的顺序，测量和布局阶段都是先执行子 View 再执行 ViewGroup 自身，而绘制是先执行 ViewGroup 绘制流程，再执行子 View 的绘制流程 二是绘制流程涉及到其他硬件（GPU），启用硬件加速和关闭硬件加速方法走的是两条完全不同的路线，这就会导致绘制阶段的调用链要更复杂一些，在后续分析方法调用的时候要有心理准备 按照惯例，先来看绘制流程的入口： /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { void performTraversals() { performDraw(); } void performDraw(){ draw(); } void draw() { if(是否启用硬件绘制) ThreadedRenderer.draw(mView); else drawSoftware(); } } 依旧是 ViewRootImpl 作为绘制事件的最初发起者，经过 performDraw() 转发后，最终由 draw() 来执行绘制事件的分发 在 draw() 方法中，先判断应用是否了启用硬件加速，如果启用硬件加速的话就走 ThreadedRenderer#draw() 方法 如果没有启用硬件加速，调用 drawSoftware() 方法执行绘制事件分发 我们先来看没有启用硬件加速的情况 ViewGroup 的绘制过程 本章节的开头就提到了绘制流程的执行顺序问题，接下来我们就一起来看看 ViewGroup#draw() 方法的实现，从源码中找答案 /frameworks/base/core/java/android/view/ViewGroup.java class ViewGroup extends View { void draw(Canvas canvas) { drawBackground();//先画背景 onDraw(canvas);//不管是View还是ViewGroup，先把自己画出来 dispatchDraw(canvas);//通知子视图执行绘制，如果是视图是View，这个方法默认为空，只有ViewGroup有实现 onDrawForeground(canvas);//最后画前景 } void dispatchDraw(){ for (int i = 0; i &lt; childrenCount; i++) { draw();//简化过的路径 } } } ViewGroup 继承自 View ，所以我把 View#draw() 方法中的逻辑挪到了在 ViewGroup 中，在 ViewGroup#draw() 方法中一共完成了4件事： 调用 drawBackground() 方法画 ViewGroup 的背景 调用自身的 onDraw() 方法执行 Canvas 绘图逻辑 调用 dispatchDraw() 通知子 View 执行 draw() 调用 onDrawForeground() 方法画视图的前景 第1步和第4步的画背景/前景的方法实现我们这里就不展开了（但是方法执行顺序我们一定要记住），重点关注第2步和第3步 在第2步中，ViewGroup 会先执行自己的 onDraw() 方法执行绘图，之后才会执行第3步调用 dispatchDraw() 方法通知子 View 执行绘制流程 在 Android 系统中，先绘制的内容会被后绘制的内容覆盖掉，所以我们在自定义 View / ViewGroup 的时，了解绘制的前后调用顺序非常重要！ View 的绘制过程 View 的绘制流程和 ViewGroup 的绘制流程几乎一模一样，唯一的区别是 View 中的 dispatchDraw() 是空实现，因为它没有子视图 /frameworks/base/core/java/android/view/View.java class View { void draw(Canvas canvas) { drawBackground();//先画背景 onDraw(canvas);//不管是View还是ViewGroup，先把自己画出来 dispatchDraw(canvas);//空方法 onDrawForeground(canvas);//最后画前景 } void dispatchDraw();//空方法 } View 的绘制流程其实也是这4个步骤，只不过 dispatchDraw() 是方法罢了，没有实际作用 到这里，整个绘制流程已经执行完成了，接下来调用的 onDraw() 方法是各个 View 自身的业务逻辑 Android 通常在 onDraw() 方法中会执行绘图操作，但当我们选择开启硬件加速之后，实际的绘制操作就不在 onDraw() 方法中执行了，接着往下看 启用硬件加速 Android 4.0 以后对所有应用程序都默认开启硬件加速，再加上现在的 GPU 驱动对绘图指令支持的非常全面，所以，在绝大多数情况下，应用都是走硬件绘制这条路线的 启用硬件加速后，绘制的入口就会发生变化，主要逻辑在 ThreadedRenderer 类，它的任务是收集开发者在 onDraw() 方法中调用的绘制指令，然后启用 RenderThread 线程，在渲染线程中再调用 GPU 执行真正的绘图操作 /frameworks/base/core/java/android/view/ThreadedRenderer.java class ThreadedRenderer { void draw(DecorView view){ view.updateDisplayListIfDirty();//经过精简后的方法调用，直接调用View记录绘图指令 int syncResult = nSyncAndDrawFrame();//切换到render thread 执行真正的绘图指令！ } } ThreadedRenderer 类中的 draw() 方法一共完成了两件事： 调用 View 的 updateDisplayListIfDirty() 方法，收集绘制指令 调用 nSyncAndDrawFrame() 方法，将绘图指令同步给 RenderThread 线程去执行 渲染线程的绘图工作我们暂时不关心，本小节我们需要了解的是 View#updateDisplayListIfDirty() 方法是如何收集绘制指令的，来看 View 的源码： /frameworks/base/core/java/android/view/View.java class View { RenderNode updateDisplayListIfDirty(){ RenderNode renderNode; DisplayListCanvas canvas = renderNode.start();//开始记录绘制节点 draw(canvas);//执行常规的draw阶段，注意这里使用的canvas类型是DisplayListCanvas renderNode.end();//View 树遍历完成，结束记录 return renderNode;//将记录的节点返回给 ThreadedRenderer.java } } 在 View 的 updateDisplayListIfDirty() 方法中，首先调用了 RenderNode#start() 方法获取一个 DisplayListCanvas 对象，并同时开始记录绘制指令 接着调用 View 自身的 draw() 方法执行常规的绘制流程（注意这里使用的 Canvas 类型是 DisplayListCanvas），draw() 方法结束以后，将收集到的绘图指令返回给 ThreadedRenderer 执行实际的绘图操作 其中，DisplayListCanvas 对象是硬件绘制中最重要的知识点！！！注意看接下来的分析 /frameworks/base/libs/hwui/DisplayListCanvas.cpp class DisplayListCanvas { //以画圈指令为例，当开发者调用Canvas.drawCircle()方法绘图时，这个指令实际上被转发到addDrawOp()保存了起来 void DisplayListCanvas::drawCircle(float x, float y, float radius, const SkPaint&amp; paint) { addDrawOp(new (alloc()) DrawCircleOp(x, y, radius, refPaint(&amp;paint))); } size_t DisplayListCanvas::addDrawOp(DrawOp* op) { //保存指令，等待切换到 RenderThread 渲染线程时再取出执行 } } DisplayListCanvas 继承自 Canvas ，当我们使用 DisplayListCanvas 进行一系列绘图操作时，这些绘图指令会通过重定向的方式保存到 DisplayList 集合中，并不会实际执行 比如上面的代码块演示了普通的画圈指令，当我们调用 Canvas#drawCircle() 方法画圈时，这个指令实际上被转发到 addDrawOp() 方法保存了起来，直到 ThreadedRenderer 对象调用了 nSyncAndDrawFrame() 方法后才真正得到执行 总结一下，应用启用硬件加速以后，onDraw() 方法中的指令将不再被执行，而是被收集到 DisplayList 集合中，等到所有需要绘制的 View 的 draw() 方法执行结束后，这些指令将会被同步到 RenderThread 渲染线程执行真正的绘图工作 ps：启用硬件加速和关闭硬件加速对于开发者来说是无感的，onDraw() 方法的收集工作依旧是在 UI 线程中执行，代码写的垃该卡还是会卡 四、结语 本篇文章介绍了自定义 View / ViewGroup 最重要的三个流程：测量、布局、绘制 对于测量阶段，我们需要理解三种 MeasureSpec 的含义、ChildView MeasureSpec 的默认生成规则，以及了解 onMeasure() 方法会执行多次的原因 对于布局阶段，我们需要了解布局阶段在整个绘制流程中的作用以及 LayoutParams 对于 ViewGroup 的意义 对于绘制阶段，我们需要了解 View / ViewGroup 的绘制顺序，以及当应用启用硬件加速后 Android 系统都做了些什么 最后，自定义 View 需要掌握一些基础的 Canvas API，出于篇幅考虑这部分内容不再展开讨论，有需要的同学可以查看 GcsSloop 的[Android自定义View系列]文章 本篇文章到这里就全部结束了，希望能对大家有帮助 全文完 五、参考资料 《Android开发艺术探索》- 任玉刚 Android measure过程 - 吴迪 Android View的绘制流程 - Kelin View的测量布局绘制过程 - 奔波儿灞取经 玩Android 每日一问 | onMeasure()多次执行原因？ 玩Android 每日一问 详细的描述下自定义 View 测量时 MesureSpec.UNSPECIFIED 玩Android 每日一问 | 自定义控件测量模式真的和 match_parent，wrap_content 一一对应吗？ ","link":"https://yibaoshan.github.io/post/android-graphics-application/"},{"title":"Android图形系统（三）系统篇：渲染/合成的底层原理浅析","content":" 点击跳转到掘金阅读 对于应用开发工程师来说，虽然我们不需要写操作系统代码，但是了解View最终是如何显示到屏幕上还是非常有必要的 本篇是Android图形系列的第三篇文章，在之前的两篇文章中分别介绍了屏幕的“显示原理”和屏幕的“刷新原理”，今天我们来一起学习Android系统的图形架构设计，聊一聊输送到屏幕的画面数据是如何产生的 本文的目标是希望读者朋友建立一个Android图形子系统的框架，因此，文中不会包含太多的方法调用链以及代码逻辑，非Android开发工程师也可以放心食用 前排提醒：全文近2万字，建议阅读时长30分钟 一、开篇 “当我们点开‘微信’这个应用后，它是怎么在屏幕上显示出来的？” 这是一个非常复杂的问题，它的背后包含了由厂商驱动、Linux操作系统、HAL硬件抽象层和Android Framework框架层共同组建的一套非常庞大的Android图形子系统 想要给出这个问题的答案，就必须对Android图形子系统背后的运行流程有所了解 今天，我们从认识Android设备中的硬件开始，自下而上 一起来看看庞大的Android图形子系统是如何组建起来的 1、硬件驱动 雷总曾经说过，再复杂的系统设计，也离不开硬件的支持 在文章的开头，我们就先来了解一下：支撑应用程序绘图的硬件有哪些？ 图片来源：https://www.ednchina.com/technews/12082_3.html 上图是一张小米11的拆解图 从左到右分别是：屏幕、相机模组、主板IC以及手机外壳 小米11使用的是高通的”骁龙888“处理器，内存使用的是来自镁光的LPDDR5 8GB芯片（下图中1/2部分，处理器和内存使用堆叠封装，俯视图它俩是叠在一起的） 图片来源：https://www.laoyaoba.com/n/780219 剩下按序号分别是：海力士128GB闪存芯片、高通的射频收发芯片、高通WiFi6/BT芯片、两颗高通的快充芯片、伏达的无线充电芯片等等，和本篇文章关系不大 回到小米11的SOC处理器部分（图1/2） 高通骁龙888（见下图）内部集成了Kryo 680 CPU、Adreno 660 GPU、Spectra 580 ISP、X60 5G等多个处理器芯片 图片来源：https://www.dpreview.com/news/2969199244/qualcomm-snapdragon-888-soc 在骁龙888封装的众多芯片中，Adreno 660 GPU模块（见下图）是我们需要关心的重点 因为它封装了我们在图形系统中经常使用到的两块芯片： GPU（Graphics Processing Unit）和DPU（Display Processing Unit） 图片来源：https://www.dpreview.com/news/2969199244/qualcomm-snapdragon-888-soc 我们都知道，一幅图像的显示必须要经过渲染、合成、送显这三个阶段，才能展现给用户 GPU和DPU就是用于提供给应用程序渲染和合成能力的硬件设备，其中： GPU芯片负责执行图形显示流程中的“渲染”工作 DPU芯片负责执行图形显示流程中的“合成”工作 接下来的章节中，我们从驱动程序的角度来聊聊什么是渲染，以及什么是合成？ 图形渲染驱动 1. 什么是渲染 众所周知，渲染工作是由GPU负责，那么在聊GPU之前首先得知道什么是“渲染”？我们来举个例子感受一下 在系统中申请一块10*10大小的图层内存，执行下列几条指令： 1、把图层背景这玩意染成绿的 2、从左上（0,0）到右下（10,10）画一条宽度为1颜色为红色的直线 3、以坐标点（5,5）为中心，画一个半径为3的实心圆，颜色要蓝色 好了，接下来操作系统会把这些“绘图指令”同步给GPU去执行渲染任务 图片来源：自己画的 GPU完成渲染工作后，我们将会得到一个大小为10*10二维数组，数组中的每个元素都保存着坐标点的颜色信息、深度信息 对应着将来要显示到屏幕上的一个个像素点 把绘图指令转化为二维像素数组的过程，就叫做“渲染” 本章节举了一个很简单的2D绘图的小例子，主要目的是让我们了解渲染工作是做什么的 图像渲染是一个非常复杂的话题，关于渲染实现原理可以点击[这里] 2. 什么是GPU GPU全称是GraphicProcessing Unit，中文是图形处理器，其最大的作用就是进行各种绘制计算机图形所需的运算，包括顶点设置、光影、像素操作等 也就是用来执行我们开发者调用的一个个的“绘图指令” 所以，GPU实际上是多组图形函数API的集合，这些函数由硬件驱动实现 硬件厂商们遵循着不同协议的开发规范，比如OpenGL ES、Vulkan等等 图片来源：https://chiptechie.com/mobile-gpu/qualcomm-adreno-660/ 上图是Adreno 660 GPU的介绍页面，可以看到小米11使用的这块芯片支持OpenGL ES 3.2版本、OpenCL 2.0版本和Vulkan 1.1版本 另外，660还支持了微软家的DirectX，这就意味着在安装了Windows ARM版的小米11中，应用程序也可以使用骁龙GPU来加速图形的渲染 更多关于GPU的介绍请点击[这里] 图形合成驱动 图形渲染阶段结束以后，接下来就到了图形的合成阶段 图形合成我们可以简单理解为Photoshop中的图层合成： 每个图层都有不同的内容，点击合并图层以后电脑会计算重叠区域的像素变化，最终把多个图层合并为一个图层 这么说可能还是有点抽象，接下来我们通过一个例子来帮助理解什么是“合成”？ 1. 什么是合成 这是一张launcher桌面的截屏，它是由“壁纸”、“顶部的状态栏”、“桌面的应用列表”以及“底部导航栏”这4个图层组成 图片来源：https://blog.zhoujinjian.cn/posts/20210810 1、壁纸图层： 图片来源：https://blog.zhoujinjian.cn/posts/20210810 2、顶部状态栏图层（很小的一个横条）： 图片来源：https://blog.zhoujinjian.cn/posts/20210810 3、桌面应用列表： 图片来源：https://blog.zhoujinjian.cn/posts/20210810 4、底部导航栏： 图片来源：https://blog.zhoujinjian.cn/posts/20210810 这其中的每个图层，都是由上一步的GPU渲染出来的的成果 每个图层渲染完成以后，理论上可以直接送到屏幕上去显示了，但是 大多数情况下屏幕上都不止一个图层 一旦图层与图层之间发生重叠（比如launcher的状态栏、应用列表和导航栏这3个图层都是叠加在壁纸图层的上面），重叠部分的像素颜色就需要重新计算 将多个图层合并成一个图层的过程，被称为“合成” 2. 什么是DPU 合成工作的本质是执行计算“脏区域”、格式转换、处理缩放等操作，这些任务我们也可以调用GPU的接口来完成 当我们认真观察合成的流程会发现，在执行图层合成的过程中是不需要3D操作的，因为早在“图层渲染”那一步GPU就完成了所有的3D处理的工作 这样的话，我们只需要为合成流程单独配置一块2D渲染引擎就OK了 目前在绝大多数Andorid设备中，承担这一责任的就是DPU芯片了 DPU作为图形硬件的一部分，通常被封装在GPU模块当中，最主要的功能是将GPU渲染完成的图层输出到屏幕 兼任了合成功能以后，对于图层重叠的部分，DPU会自动计算出“脏区域”并更新像素颜色变化 不过，DPU虽然可以执行合成工作，但它有合成数量的限制 如下图，Arm Mali-DP550这款DPU最多能够支持7层的合成任务 图片来源：https://community.arm.com/cn/f/discussions/6104/arm-mali-gpu 3. 什么是HWC 上一节聊DPU的时候我们提到了，如果想把合成流程独立出来，只需要单独配置一块2D渲染芯片就行了 厂商可以选择将合成工作放在DPU中，也可以选择在板子上加一块2D渲染芯片，将合成工作放在这块芯片中 抠门一点的厂商，可以选择不单独配置合成芯片，只使用GPU进行合成 这就需要一个规范把合成工作抽象成一个接口，由厂商自由选择合成方案 Hardware Composer就是专门用来定义合成工作的抽象接口，它是Android Hardware Abstraction Layer（HAL）硬件抽象层的成员之一 在HWC中，厂商使用的是DPU还是其他的2D渲染芯片不重要，只需要实现HWC的接口即可 我们来看Google官网对于HWC的定义： 图片来源：https://source.android.com/devices/graphics/hwc 《每个字都认识就是不知道在说什么》系列，我把这段话按照标号翻译一下： 用DPU做合成比GPU要高效 第二点比较重要，里面包含了hwc的执行逻辑，大致流程是这样： sf进程：有6个渲染好的图层过来了，我全部塞给你，你自个儿处理完去送显？ hwc：不行，我最多只能处理4个图层的合并工作，剩余两个图层我标记为GPU合成了，你处理一下 sf进程：调用GPU完成另外2个图层的合成工作，并将合并后的图层交给hwc 第三点我不是很理解什么意思，因为理论上如果屏幕内容没有发生变化，sf不应该走合成流程， 超出hwc能力的图层会调用GPU合成，如果应用的图层太多会对性能产生影响，比如APP弹窗过多，每个Dialog都算一个图层 关于第二点我们可以使用adb shell dumpsys SurfaceFlinger命令查看当前图层的合成方式，DEVICE表示HWC合成，CLIENT表示GPU合成 图片来源：自己截的 另外，因为绝大多数情况下hwc的实现者是DPU，所以除了合成工作外，hwc模块还负责送显以及发送VSync信号 好了，hwc的部分到这里先告一段落，我们来总结一下“硬件驱动”小节的内容 本章节的重点是了解什么是渲染和合成以及渲染/合成使用的硬件设备是什么，渲染和合成之间的区别： 渲染，关注的是单个图层的内容，在当前图层的坐标系中，每个坐标点应该显示什么颜色 合成，关注的是多个图层的内容，将多个图层重新计算后得到一个图层，参考ps的合并图层功能 渲染、合成这两个阶段所需的硬件部分已经介绍完成，接下来我们一起看看Google为图形系统准备了哪些软件组件库 2、Google组件库 Andorid提供的低级别组件库更多是控制图形内存的流程以及内存结构的封装 比如CPU、GPU和HWC要共享同一块内存，那就需要一种格式让它们都能识别这块内存 另外，还需要一种机制保证数据的安全，防止发生某个硬件在使用过程中数据被其他硬件篡改的情况 图形系统中包含了[libui.so]和[libgui.so]两个低级别组件库，接下来一起来看看这两个库里面分别有什么 libui组件库 1. 什么是GraphicBuffer GraphicBuffer是整个图形系统的核心，所以的渲染操作都将在此对象上进行，包括同步给GPU和HWC 每当应用有显示需求时，应用会向系统申请一块GraphicBuffer内存，这块内存将会共享给GPU用于执行渲染工作，接着会同步给HWC用于合成和显示 我们可以把每一个GraphicBuffer对象看做是一个个渲染完成的图层，对应1.1.2.1小节中Launcher的各个图层 更多关于GraphicBuffer的介绍请点击[这里] 2. 什么是Fence机制 一个GraphicBuffer对象完整的生命周期大概是这样： 渲染阶段：应用有绘图需求了，由GPU分配一块内存给应用，应用调用GPU执行绘图，此时使用者是GPU 合成阶段：GPU渲染完成后将图层传递给sf进程，sf进程决定由谁来合成，hwc或者GPU 如果使用GPU合成，那么此时buffer的使用者依旧是GPU 如果使用hwc合成，那么此时buffer的使用者是hwc 显示阶段：所有的buffer在此阶段的使用者都是hwc，因为hwc控制着显示芯片 从生命周期可以看出GraphicBuffer对象在流转的过程中，会被GPU、CPU、DPU三个不同的硬件访问 如果同一块内存能够被多个硬件设备访问，就需要一个同步机制 在Android图形系统中，Fence机制就是用来保证跨硬件访问时的数据安全 Fence的底层逻辑可以参考Java的synchronized互斥锁机制，我们也可以把Fence理解为一把硬件的互斥锁 每个需要访问GraphicBuffer的角色，在使用前都要检查这把锁是否signaled了才能进行安全的操作，否则就要等待 active状态，该GraphicBuffer正在被占用 signaled状态，表明不再控制buffer 更多关于Fence同步机制的介绍请点击[这里] 3. 什么是Gralloc 移动设备的内部空间寸土寸金，不太可能像PC一样给GPU单独配个显存，因此移动端的&quot;图形内存&quot;都被分配在运行内存中 为了防止图形内存被滥用，Android抽象出Gralloc模块，规定了所有图形内存的申请与释放都需要通过该模块来操作，以此来规范图形内存的使用 更多关于Gralloc机制的介绍请点击[这里] 注意：Fence机制和Gralloc机制并不属于libui组件库，把它俩放到libui库展示是因为GraphicBuffer需要它们 libgui组件库 俗话说，越接近上层业务设计上就越复杂 libgui库虽说还没到业务层，但它里面的组件大多是对GraphicBuffer对象的封装，以满足不同的业务需求 1. 什么是BufferQueue 在Android 4.1（Project Butter）中引入了BufferQueue，它是黄油计划中“Triple Buffer”的执行者 黄油计划的重点是“Drawing with VSync”，也就是把VSync信号同步给APP进程 这样做的目的是将渲染和合成分成两步来执行，减少一个VSync周期内的任务量，以降低丢帧发生的概率 回到本章节的主题：BufferQueue 从名称就可以看出来，它是一个封装了GraphicBuffer的队列，BufferQueue对外提供了GraphicBuffer对象出列/入列的接口 另外，BufferQueue还为每个GraphicBuffer对象包装了几种不同的状态，它们分别是： FREE：闲置状态，任何进程都可以获取该buffer进行操作，通常表示为APP进程可以申请使用的内存 DEQUEUED：出列状态，通常是APP进程在绘图，使用者是GPU QUEUED：入列状态，表示APP绘图已经完成，等待从队列取出执行下一步合成，没有使用者 ACQUIRED：锁定状态，通常表示sf进程从队列取出，正在做合成工作，此时使用者可能是hwc也有可能是GPU SHARED：共享状态，7.0版本加入的新状态，没找到相关介绍资料，合成工作完成以后共享给录屏软件？ 设计上，BufferQueue使用了[生产者/消费者模式]，绝大多数的情况下，APP作为GraphicBuffer的生产者，sf进程作为GraphicBuffer的消费者，它们俩共同操作一个buffer队列 简单描述一下生产者消费者操作队列时状态转换的过程： 生产者：APP进程 1、producer-&gt;dequeueBuffer() ​ 从队列取出一个状态为“FREE”的buffer，此时该buffer状态变化为：FREE-&gt;DEQUEUED 2、producer-&gt;queueBuffer() ​ 将渲染完成的buffer入列，此时该buffer状态变化为：DEQUEUED-&gt;QUEUED 消费者：sf进程 1、consumer-&gt;acquireBuffer() ​ 从队列中取出一个状态为“QUEUED”的渲染完的buffer准备去合成送显，此时该buffer的状态变化为：QUEUED-&gt;ACQUIRED 2、consumer-&gt;releaseBuffer() ​ buffer内容已经显示过了，可以重新入列给APP使用了，此时该buffer的状态变化为：ACQUIRED-&gt;FREE 每个Buffer的一生，就是在不断地循环FREE-&gt;DEQUEUED-&gt;QUEUED-&gt;ACQUIRED-&gt;FREE这个过程，这中间有任何一个环节出现延迟，反应到屏幕上就是应用出现了卡顿 更多关于BufferQueue的介绍请点击[这里] 说明：BufferQueue核心代码由BufferQueueCore、BufferQueueProducer、BufferQueueConsumer这3个类组成 为了避免引入过多的角色导致文章的阅读体验下降，在后续的章节中，我会将这几个类统称为BufferQueue，包括接下来会出现的Surface、EventThread都是如此，只保留主干 2. 什么是Surface 在介绍libui库的时，我们提到了GraphicBuffer是整个图形系统的核心 但对于开发者来说，尤其是应用开发者，Surface才是我们看得见摸得着的核心类，应用中所有的绘图操作最终都是在Surface中执行的 Surface作为图像的生产者，持有BufferQueue的引用，并且封装了出列和入列两个方法 接下来我们通过一个例子来了解下日常开发中是如何调用到BufferQueue的： 我们都知道Android支持2D绘图，API使用的是[Canvas]，也支持3D绘图，API使用的是[OpenGL ES] 我们以2D绘图的流程来举例： 1、需要显示图形时，首先创建一个Surface对象 2、调用Surface#lockCanvas()获取Canvas对象 3、调用Canvas的draw开头的函数执行一系列的绘图操作 4、调用Surface#unlockCanvasAndPost()将绘制完成的图层提交，等待下一步合成显示 第二步的[lockCanvas()]方法返回了Canvas对象供开发者绘图使用，其内部就调用了BufferQueue#dequeueBuffer()申请一块图形buffer，后续所有的绘图结果都会写入这块内存中 第四步的[unlockCanvasAndPost()]方法内部调用了BufferQueue#queueBuffer()方法将绘制完成的Buffer入列，等待sf进程在下一次同步信号周期合成并完成送显 上面是使用Java开发的绘制流程，Surface除了给Java层提供绘图接口外，它还是ANativeWindow的实现类 ANativeWindow是用于提供给C/C++层开发的接口，和应用开发关系不大，点击[这里]了解一下它们之间的区别即可 简单来说，ANativeWindow和Surface一样，都封装了Buffer的出列和入列方法 3. 什么是DisplayEventReceiver DisplayEventReceiver对象看起来有点面生，但提到Choreographer我相信大部分读者应该都知道是干什么的 DisplayEventReceiver和Choreographer都是在黄油计划加入的新成员，它俩是一一对应的关系（DisplayEventReceiver是Choreographer中的一个成员变量） 简单来说，DisplayEventReceiver让Choreographer对象拥有了感知VSync信号的能力，了解即可 关于DisplayEventReceiver更多细节请点击这里 3、小结 呼~ 终于把硬件驱动和Google组件库介绍完了，用一张图来总结本章节内容： 图片来源：自己画的 最底层的硬件驱动由OEM厂商提供，也就是高通、ARM这些SOC厂商 如果设备中没有GPU/DPU这些硬件也没关系，Google为所有的驱动（包括HAL层）都提供了默认实现，也就是CPU实现，这也是为什么虚拟机能运行的原因 再往上是Google提供的组件库，里面都是一些常用的类，其中大部分成员我们都还是要了解它们各自是做什么的，因为只有把这些基础概念理解清楚，才能在后续阅读源码的过程中做到有的放矢 好了，Android图形系统的静态部分聊完了，接下来我们进入动态部分的内容 二、请求VSync信号 厂商驱动库和Google组件库作为Android图形系统的基石，为整个图形系统提供了强有力的支撑 在Android图形系统的动态部分，SurfaceFlinger作为系统的核心进程，在整个图形系统中起承上启下的作用 为图形系统服务的另外还有SystemServer进程，它和SurfaceFlinger进程一同支撑着整个系统的运转，其中： SurfaceFlinger进程负责接受来自APP进程的图形数据，调用hwc进行合成并完成最终的送显 SystemServer进程负责管理有哪些APP进程可以进行绘图操作以及各个图层的优先级 SurfaceFlinger进程和SystemServer进程都是在VSync信号的驱使下进行工作，在接下来的章节中我们将会分析这两大系统进程分别在VSync信号到来时做了哪些事情 不过，在此之前，我们需要先知道它们是如何请求VSync信号的？ 全文基于Android 7.1.2版本 1、启动surface_flinger进程 Android 7.0以后对init.rc脚本进行了重构，sf进程的启动从init.rc文件配置到了surfaceflinger.rc文件，依旧由init进程拉起 先来看main_surfaceflinger.cpp的启动函数： /frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp int main(int, char**) { //创建sf对象 sp&lt;SurfaceFlinger&gt; flinger = new SurfaceFlinger(); //调用init方法进行初始化 flinger-&gt;init(); //注册sf服务到servicemanager sp&lt;IServiceManager&gt; sm(defaultServiceManager()); sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false); //注册gpu服务到servicemanager sp&lt;GpuService&gt; gpuservice = new GpuService(); sm-&gt;addService(String16(GpuService::SERVICE_NAME), gpuservice, false); //调用run方法，进入休眠 flinger-&gt;run(); return 0; } main_surfaceflinger的入口函数的主要做了3件事： 创建flinger对象并调用init()方法执行初始化工作 注册sf服务和gpu服务到servicemanager 调用run()方法进入休眠 主要的工作是在flinger对象中的init()函数中完成的 我们继续向下跟SurfaceFlinger#init()函数： /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp //利用RefBase首次引用机制来做一些初始化工作，这里是初始化消息机制 //消息队列在sf进程中一共提供两个功能 //1. 执行sf进程请求VSync的工作 //2. VSync-sf信号到来后，执行合成工作 void SurfaceFlinger::onFirstRef() { mEventQueue.init(this); } //初始化-只截取了和VSync信号和图形合成有关的部分代码 void SurfaceFlinger::init() { { // start the EventThread //启动事件分发线程，提供给APP进程注册事件回调 //mPrimaryDispSync是用来控制 sp&lt;VSyncSource&gt; VSyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, VSyncPhaseOffsetNs, true, &quot;app&quot;); mEventThread = new EventThread(VSyncSrc, *this); //又启动一个事件分发线程，并将自己注册到hwc中，用于sf进程监听VSync信号 sp&lt;VSyncSource&gt; sfVSyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVSyncPhaseOffsetNs, true, &quot;sf&quot;); mSFEventThread = new EventThread(sfVSyncSrc, *this); mEventQueue.setEventThread(mSFEventThread); } // Drop the state lock while we initialize the hardware composer. We drop // the lock because on creation, it will call back into SurfaceFlinger to // initialize the primary display. //初始化HWC对象，加载hwcomposer.so的动作在HWComposer的初始化函数中 mHwc = new HWComposer(this); //将自己注册到hwc的回调函数中，其内部分别调用registerHotplugCallback、registerRefreshCallback、registerVSyncCallback三个回调方法 mHwc-&gt;setEventHandler(static_cast&lt;HWComposer::EventHandler*&gt;(this)); mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY); } //进入消息轮询 void SurfaceFlinger::run() { do { waitForEvent(); } while (true); } //等待消息唤醒 void SurfaceFlinger::waitForEvent() { do { IPCThreadState::self()-&gt;flushCommands(); int32_t ret = mLooper-&gt;pollOnce(-1); } while (true); } init()函数初始化流程稍微有点长，我们一步步拆开来看 初始化消息队列 //利用RefBase首次引用机制来做一些初始化工作，这里是初始化消息机制 //消息队列在sf进程中一共提供两个功能 //1. 执行sf进程请求VSync的工作 //2. VSync-sf信号到来后，执行合成工作 void SurfaceFlinger::onFirstRef() { mEventQueue.init(this); } 在SurfaceFlinger中，利用了RefBase首次引用机制来做一些初始化工作，这里是初始化消息队列 sf进程中的消息队列一共负责处理两种类型的消息： INVALIDATE：处理Layer属性变化以及buffer的更新 REFRESH：监听到VSync信号，执行合成工作 在接下来的文章分析中我们会发现，sf进程的一生都将围绕着这两件事展开 启动事件分发线程 /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp //初始化-只截取了和VSync信号和图形合成有关的部分代码 void SurfaceFlinger::init() { { // start the EventThread //启动事件分发线程，提供给APP进程注册事件回调 //VSyncPhaseOffsetNs用来控制APP进程的偏移量 sp&lt;VSyncSource&gt; VSyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, VSyncPhaseOffsetNs, true, &quot;app&quot;); mEventThread = new EventThread(VSyncSrc, *this); //又启动事件分发线程，提供给sf进程注册事件回调 //sfVSyncPhaseOffsetNs用来控制sf进程的偏移量 sp&lt;VSyncSource&gt; sfVSyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVSyncPhaseOffsetNs, true, &quot;sf&quot;); mSFEventThread = new EventThread(sfVSyncSrc, *this); mEventQueue.setEventThread(mSFEventThread); } //用于控制硬件VSync开关状态 mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY); } init()函数中第二步是启动事件分发线程 一共启动了3个线程，其中： mEventThread用于给APP进程提供VSync信号监听，通常称为VSYNC-app mSFEventThread用于给sf进提供VSync信号监听，通常称为VSYNC-sf mEventControlThread是总开关，用于控制硬件VSync信号的开启与关闭 1、2线程分别是“APP进程”和“sf进程的”VSync事件分发线程 把APP进程和sf进程的VSync分开管理的好处是：降低操控延时 什么是“降低操控延时”？我们先来看看正常的显示流程： VSync1：APP进程开始渲染，渲染完成后入列等待合成 VSync2：sf查找所有渲染完成的图层，调用hwc合成，合成完成调用drm/fb显示框架送显，等待显示 VSync3：为了防止画面撕裂，显示框架同样等待垂直同步信号到来时才切换framebuffer，此时用户看到更新的画面 一幅画面最起码要经过2个VSync周期（渲染、合成），在第3个VSync信号到来后才能展示给用户 如果是60HZ的屏幕，用户从按下按钮到到看到画面更新，最快要16.67ms*2 = 33.34ms 现在假设有这么个情况：我自己造了个硬件非常非常牛逼，再复杂的画面渲染也只要1ms，合成也只要1ms 那系统层面有没有一种机制能让用户更快的看到画面更新呢？ VSync offset：有 1. VSync offset 回头来看init()函数，在创建“APP进程”和“sf进程”的DispSyncSource对象时，分别传入了VSyncPhaseOffsetNs和sfVSyncPhaseOffsetNs两个变量 void SurfaceFlinger::init() { //VSyncPhaseOffsetNs - i'm here sp&lt;VSyncSource&gt; VSyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, VSyncPhaseOffsetNs, true, &quot;app&quot;); //sfVSyncPhaseOffsetNs sp&lt;VSyncSource&gt; sfVSyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVSyncPhaseOffsetNs, true, &quot;sf&quot;); } VSyncPhaseOffsetNs用来控制APP进程的偏移量 sfVSyncPhaseOffsetNs用来控制sf进程的偏移量 我们知道硬件垂直同步信号的发送周期是固定的 既然大家都在自己的进程里等待着VSync信号的到来，然后各司其职做自己的工作 那我们通过更改偏移量的方式把“APP进程”和“sf进程”接收到VSync信号的时间错开 就可以实现：在一个硬件VSync信号周期内完成“渲染”和“合成”两件事，具体方案如下： VSyncPhaseOffsetNs = 0，硬件VSync发生后，直接转发给app进程，让它开始绘制 sfVSyncPhaseOffsetNs ≥1，硬件VSync发生后，延迟几毫秒再转发给sf进程，因为app已经渲染完成，sf合成刚刚渲染的图层 好了，在一个硬件VSync周期16ms）内“渲染”和“合成”的工作都已经完成了，并且由于GPU性能过于牛逼，距离下次硬件VSync信号发送甚至还有14ms~ 等下一次硬件VSync信号到来时，显示框架完成画面切换 和之前的方案比，同样是60HZ的屏幕 用户从按下按钮到到看到画面更新，只需要等待1个VSync信号周期，也就是16.67ms 2. DispSync模型 还记得init()函数中启动的第3个线程吗？名称叫：mEventControlThread /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { void SurfaceFlinger::init() { //用于控制硬件VSync开关状态 mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY); } //接收来自hwc的硬件VSync信号 void SurfaceFlinger::onVSyncReceived(int32_t type, nsecs_t timestamp) { bool needsHwVSync = false; needsHwVSync = mPrimaryDispSync.addResyncSample(timestamp); if (needsHwVSync) { enableHardwareVSync(); } else { disableHardwareVSync(false); } } //启用硬件VSync信号 void SurfaceFlinger::enableHardwareVSync() { mPrimaryDispSync.beginResync(); mEventControlThread-&gt;setVSyncEnabled(true); } //关闭硬件VSync信号 void SurfaceFlinger::disableHardwareVSync(bool makeUnavailable) { mEventControlThread-&gt;setVSyncEnabled(false); mPrimaryDispSync.endResync(); } } mEventControlThread线程初始化之后被DispSync持有，用来启用和关闭硬件VSync的功能 在Android图形系统中，不管是硬件产生还是软件模拟的VSync信号，最终都交由DispSync来管理 VSync offset能够控制偏移量的背后就是DispSync模型 DispSync控制着这个系统的VSync信号出口，除了调整偏移量外，它的内部还有个预测机制 当接受到的硬件VSync信号量足够大时，DispSync会通过mEventControlThread关闭硬件VSync开关，通过预测的结果模拟VSync信号的产生，发送到app进程和sf进程 ps：我个人对DispSync模型仍然有疑问，这块理解的可能不太对，所以不敢妄下结论，建议阅读以下几篇文章进行学习： 《Analyze AOSP VSync model》、《DispSync解析》、《Android DispSync 详解》、《Android R VSync相关梳理》、《Android SurfaceFlinger SW VSync模型》 初始化HWComposer /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp void SurfaceFlinger::init() { ... //初始化HWC对象，加载hwcomposer.so的动作在HWComposer的初始化函数中 mHwc = new HWComposer(this); //将自己注册到hwc的回调函数中，其内部分别调用registerHotplugCallback、registerRefreshCallback、registerVSyncCallback三个回调方法 mHwc-&gt;setEventHandler(static_cast&lt;HWComposer::EventHandler*&gt;(this)); } 前面我们说sf进程的一生，就是在做“请求VSync”和“执行合成工作”这两件事 而HWComposer就是完成这两件事的关键，不管是接受硬件的VSync信号，还是完成图层合成工作，都和它有关 所以，HWComposer对象可以说是sf进程中的头号核心人物 sf进程在初始化HWComposer阶段一共做了两件事： 创建HWC对象，保存到mHwc成员变量 注意，这里创建的是标准的HWComposer对象，在HWComposer构造函数中，调用了内部的[loadHwcModule()]方法来加载厂测提供的so库 注册VSync回调 HWC对象创建完以后，第二步就调用了setEventHandler将自己注册到VSync信号监听 如果VSync信号发生变化，最终会调用到sf进程的[onVSyncReceived()]方法 进入睡眠 等待唤醒 /frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp int main(int, char**) { ... // run surface flinger in this thread flinger-&gt;run(); return 0; } /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp void SurfaceFlinger::run() { do { waitForEvent(); } while (true); } 在完成所有初始化工作后，sf进程进入睡眠状态，等待消息唤醒 总结一下，sf进程在图形处理相关方面一共做了两件事： 启动事件分发线程，内部由DispSync模型实现 初始化HWC对象，加载so库，注册VSync回调 2、启动system_server进程 [system_server进程中运行着AMS、WMS等常见服务，这些服务都是由java代码实现的，需要一个Java的运行环境 所以SystemServer进程必须要等到Zygote进程创建完DVM/ART虚拟机以后，再由Zygote进程fork而来： /frameworks/base/services/java/com/android/server/SystemServer.java class SystemServer { /** * The main entry point from zygote. */ public static void main(String[] args) { new SystemServer().run(); } private void run() { Looper.prepareMainLooper(); startBootstrapServices(); startOtherServices(); // Loop forever. Looper.loop(); } //启动AMS private void startBootstrapServices() { mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService(); // Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); } //启动WMS private void startOtherServices() { WindowManagerService wm = WindowManagerService.main(); //将wms注册到servicemanager ServiceManager.addService(Context.WINDOW_SERVICE, wm); mActivityManagerService.systemReady();// } } /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java class ActivityManagerService { //将自己注册到servicemanager中去 public void setSystemProcess() { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); } //启动launcher桌面 public void systemReady() { //aosp版本不同代码也不同，在7.0中最终调用startHomeActivityLocked()方法唤起launcher } } /frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java class WindowManagerService { public static WindowManagerService main(){ return new WindowManagerService(); } } Zygote进程是如何启动并拉起system_server进程这里不展开，我们来关注在SystemServer的run()函数中启动了两个服务：AMS和WMS 初始化ActivityManagerService ActivityManagerService是Android系统最为核心的服务之一，负责组件（主要是Activity）的启动、切换、调度工作，来看AMS的启动流程 /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java class ActivityManagerService { //将自己注册到servicemanager中去 public void setSystemProcess() { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); } //启动launcher桌面 public void systemReady() { //aosp版本不同代码也不同，在7.0中最终调用startHomeActivityLocked()方法唤起launcher } } AMS在SystemServer进程启动过程中做了两件事： 将自己注册到servicemanager中去 启动launcher桌面 在Android图形系统中，每个Activity页面都可以看做是一个Window对象，所以Activity的生命周期也会影响Window对象的状态 我们来思考一个问题：当我们启动一个透明背景的Activity页面或者是Dialog主题的Activity页面，原先的Activity会不会执行onStop()回调？ 答案是：不会 如果AMS触发了Activity的onStop()回调方法，同时也会调用WindowManagerGlobal#setStoppedState()来通知Window对象，那么此Window会停止绘制 这并不是用户希望看到的结果 初始化WindowManagerService WindowManagerService的启动函数非常简单，在SystemServer中创建完成以后就直接注册到了servicemanager /frameworks/base/services/java/com/android/server/SystemServer.java class SystemServer { //启动WMS private void startOtherServices() { WindowManagerService wm = WindowManagerService.main(); //将wms注册到servicemanager ServiceManager.addService(Context.WINDOW_SERVICE, wm); } } /frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java class WindowManagerService { public static WindowManagerService main(){ return new WindowManagerService(); } } WMS启动完成以后，最重要的任务就是等待处理来自各个进程创建/更新/销毁Window的工作 在应用开发中，除了Activity对应一个Window窗口外，每个Toast、Dialog也都是一个Window窗口 Android中将窗口的类型分为三种： Application Window（应用窗口）：对应的是Activity Sub Window（子窗口）：对应Dialog，特点是必须要依附父窗口才能显示 System Window（系统窗口）：对应Toast、微信的视频通话、视频小窗播放等 Looper.loop() 将一系列服务启动结束以后，SystemServer调用Looper#loop()方法进入循环，保证system_server进程不退出 /frameworks/base/services/java/com/android/server/SystemServer.java class SystemServer { private void run() { startBootstrapServices(); startOtherServices(); // Loop forever. Looper.loop(); } } 3、启动app进程 APP进程和SystemServer进程一样，都是从Zygote进程fork而来 启动APP进程的代码稍微有些长，有时间的同学建议点击[这里]打开源码对照着看效果更佳 /* 视图加载可以分为三个阶段：Activity对象的创建、视图对象的创建、ViewRootImpl的创建 在第一个阶段，ActivityThread.main() ActivityThread，入口函数中初始化handler机制 ApplicationThread，ams传话筒 Activity，开发者的主战场 PhoneWindow，空壳子 WindowManager，wms的代理对象 在第二个阶段，Activity.setContentView 调用PhoneWindow设置视图 根据不同主题，为DecorView设置不同的子View（无论使用哪种主题视图，其中必然包含名为content的FrameLayout） 将开发者的布局文件添加到子View名为content的FrameLayout当中 为PhoneWindow设置DecorView 在第三个阶段，创建ViewRootImpl 1. Choreographer让它能够感知事件 2. 保存DecorView让它能够在事件来临时控制视图 3. Surface让它拥有绘图的能力 通过addToDisplay()方法推送到wms **/ /frameworks/base/core/java/android/app/ActivityThread.java class ActivityThread { //zygote进程fork成功后调用入口函数 void main(){ Looper.prepareMainLooper(); attach();//attach方法和ams建立连接，提供给ams控制四大组件的句柄 Looper.loop(); } //分两步解释更容易理解 //1. 不管是从桌面点击图标进入还是adb命令启动，最终都交由ams发送启动请求给zygote进程，接着zygote孵化出该APP进程调用main方法 //2. APP进程启动将创建ApplicationThread对象，并发起IPC把此对象传递给ams，此后四大组件相关回到都将有ApplicationThread对象负责，最终转发给H类执行 void attach() { //获取ams代理并将ApplicationThread将给ams，这个对象以后将是ams的传声筒 IActivityManager mgr = ActivityManagerNative.getDefault(); mgr.attachApplication(new ApplicationThread()); } //ApplicationThreadNative封装一系列的关于四大组件回调方法的跨进程通信命令 //ApplicationThread对象所有操作几乎都由AMS发起调用 class ApplicationThread extends ApplicationThreadNative { void scheduleLaunchActivity(){ handleMessage(LAUNCH_ACTIVITY); } } class H extends Handler { //转发来自ApplicationThread的消息 void handleMessage(Message msg) { case LAUNCH_ACTIVITY::handleLaunchActivity(); case RESUME_ACTIVITY::handleResumeActivity(); } //转发来自handleMessage的消息 void handleLaunchActivity(){ performLaunchActivity(); handleResumeActivity(); } //转发来自handleMessage的消息 void handleResumeActivity(){ performResumeActivity() activity.makeVisible();//调用此方法说明第二阶段视图加载已经完成，准备提交到wms服务 } //执行创建Activity对象并回调生命周期 Activity performLaunchActivity(){ Activity activity = new Activity(); activity.attach();//回调attach activity.onCreate();//回调Activity return activity; } //执行回调生命周期 void performResumeActivity(){ activity.onResume(); } } } /frameworks/base/core/java/android/app/Activity.java class Activity { View mDecor;//用户设置的跟视图，通常会在ActivityThread中被赋值 Window mWindow;//Activity首次被创建调用attach()方法时同步创建，创建动作在Activity WindowManager mWindowManager;//在attach方法中被创建 //1. 创建PhoneWindow保存到变量mWindow，此时的Window还没有View视图 //2. 获取wms代理对象，塞到刚刚创建的window对象当中，同时保存到本地mWindowManager变量 void attach(Window window){ mWindow = new PhoneWindow(this, window); mWindow.setWindowManager(getSystemService(Context.WINDOW_SERVICE)); mWindowManager = mWindow.getWindowManager();//获取WindowManager动作在Activity中，获取完成接着设置给自己的局部变量，这我是真的没想到，找的好辛苦 } //至此，APP进程启动成功，第一阶段结束，准备进入第二阶段 void onCreate(){ setContentView(); } //第二阶段开始：加载视图文件并绑定到DecorView void setContentView(View view) { mWindow.setContentView(view); } //第二阶段已经完成，准备进入第三阶段 void onContentChanged(){ } //第三阶段开始：将视图传递给wms //makeVisible()在ActivityThread.H.handleResumeActivity()方法中被调用 //此阶段完成后会请求VSync信号，并在下一次VSync到来时绘制View树，在下下次sf进程合成，在下下下次展示给用户，整个流程如下： //VSync-&gt;view.draw() // vysnc-&gt;sf.compose() // VSync-&gt;drm.flip() 用户可以看到 void makeVisible() { mWindowManager.addView(mDecor); } } /frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java class PhoneWindow extends Window { DecorView mDecor; ViewGroup mContentParent; //1. 创建DecorView对象 //2. 将开发者设置的视图文件作为子View添加到mContentParent //3. 通知Activity中onContentChanged方法 void setContentView(View view) { mDecor = generateDecor(); mContentParent = generateLayout();//看generateLayout方法的注释 mContentParent.addView(view);//将开发者设置的视图添加为子View getCallback().onContentChanged();//回调Activity中onContentChanged()方法 } //创建一个空的DecorView，也就是FrameLayout，里面啥也没有 void generateDecor() { return new DecorView(this); } //1. 根据不同主题设置不同布局文件，加载该布局文件并设置成DecorView的子View //2. 返回子View中id为content的ViewGroup，通常还是个FrameLayout //以上两步执行完成以后，DecorView的布局变成： //&lt;FrameLayout&gt;//DecorView的根布局 // &lt;LinearLayout&gt;//开发者设置带有ActionBar的主题，注意，这里的视图可变的，根据主题来选择不同的视图 // &lt;ActionBar/&gt; // &lt;FrameLayout // android:id=&quot;@android:id/content&quot;/&gt;//这里的FrameLayout才是最终包含开发者在setContentView中设置的布局 // &lt;/LinearLayout&gt; //&lt;/FrameLayout&gt; void generateLayout() { //加载不同的theme主题的布局文件，比如我们在xml中指定android:theme=@style/NoActionBar View root = inflater.inflate(layoutResource); //将上一步解析的视图作为根布局添加到DecorView，常见的比如垂直方向的LinearLayout，这样布局DecorView mDecor.addView(root); //找到用来装用户视图的ViewGroup，通常还是个FrameLayout ViewGroup contentParent = mDecor.findViewById(R.id.content); return contentParent; } } //自身无逻辑，可以跳过 /frameworks/base/core/java/com/android/internal/policy/DecorView.java class DecorView extends FrameLayout { //DecorView和PhoneWindow互相持有，这代码写的，啧啧啧 PhoneWindow mWindow; DecorView(PhoneWindow window){ mWindow = window; } } //定义View操作接口，顶级接口 /frameworks/base/core/java/android/view/ViewManager.java public interface ViewManager { public void addView(); public void updateViewLayout(); public void removeView(); } //啥也不是 /frameworks/base/core/java/android/view/WindowManager.java public interface WindowManager extends ViewManager { } //WindowManager的最终实现 /frameworks/base/core/java/android/view/WindowManagerImpl.java public class WindowManagerImpl implements WindowManager { WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); void addView(View decorView) { mGlobal.addView(decorView); } } //全局单例，和WMS建立连接通信，也是APP进程中，所有窗口实际的管理者 //内部mViews和mRoots变量保存着所有创建的Activity对应的View和ViewRootImpl class WindowManagerGlobal { List&lt;View&gt; mViews; List&lt;ViewRootImpl&gt; mRoots; void addView(View decorView){ ViewRootImpl root = new ViewRootImpl(decorView); mViews.add(decorView); mRoots.add(root); // do this last because it fires off messages to start doing things root.setView(view); } } //对应一个Activity，关于视图的事件触发都在此 //1. Choreographer让它能够感知事件 //2. 保存DecorView让它能够在事件来临时控制视图 //3. Surface让它拥有绘图的能力 class ViewRootImpl { Choreographer mChoreographer;//构造函数中被创建 View mView;//保存DecorView final Surface mSurface = new Surface(); public ViewRootImpl(){ //可以感知VSync的原因可以追溯到libgui库中的DisplayEventReceiver类 mChoreographer = Choreographer.getInstance(); } //1. 请求VSync信号，等待VSync来临后绘图 //2. 创建binder代理对象传递给wms，此后wms将通过此代理对象来通知APP进程应该做什么事 void setView(View decorView){ mView = decorView;//将DecorView保存到ViewRootImpl的成员变量mView中 requestLayout();//请求VSync信号 //通过binder向wms添加窗口 res = mWindowSession.addToDisplay(); } } APP整个启动过程大致可以分为三步： 创建Activity并调用setContentView()绑定视图 请求VSync信号 进入睡眠 等待VSync信号唤醒 我们先来看第一步：创建Activity并调用setContentView()绑定视图 创建Activity 在Android开发中，第一步永远都是设置视图，而设置视图不外乎于两种方式：xml文件和Java编码 不管使用哪种方式，都需要调用setContentView()方法将视图绑定到Activity当中 经过一系列的方法调用，最终会执行到ViewRootImpl.setView()方法将视图同步给WMS 创建Activity的过程中要依赖三个关键的对象：Window、DecorView、ViewRootImpl，我们可以按照这三个对象把创建Activity也分成了三个阶段： 1、Window对象的创建 2、DecorView的创建 3、ViewRootImpl的创建 1. Window的创建 /frameworks/base/core/java/android/app/ActivityThread.java class ActivityThread { //zygote进程fork成功后调用入口函数 void main(){ Looper.prepareMainLooper(); attach();//attach方法和ams建立连接，提供给ams控制四大组件的句柄 Looper.loop(); } //分两步解释更容易理解 //1. 不管是从桌面点击图标进入还是adb命令启动，最终都交由ams发送启动请求给zygote进程，接着zygote孵化出该APP进程调用main方法 //2. APP进程启动将创建ApplicationThread对象，并发起IPC把此对象传递给ams，此后四大组件相关回到都将有ApplicationThread对象负责，最终转发给H类执行 void attach() { //获取ams代理并将ApplicationThread将给ams，这个对象以后将是ams的传声筒 IActivityManager mgr = ActivityManagerNative.getDefault(); mgr.attachApplication(new ApplicationThread()); } //ApplicationThreadNative封装一系列的关于四大组件回调方法的跨进程通信命令 //ApplicationThread对象所有操作几乎都由AMS发起调用 class ApplicationThread extends ApplicationThreadNative { void scheduleLaunchActivity(){ handleMessage(LAUNCH_ACTIVITY); } } class H extends Handler { //转发来自ApplicationThread的消息 void handleMessage(Message msg) { case LAUNCH_ACTIVITY::handleLaunchActivity(); case RESUME_ACTIVITY::handleResumeActivity(); } //转发来自handleMessage的消息 void handleLaunchActivity(){ performLaunchActivity(); handleResumeActivity(); } //执行创建Activity对象并回调生命周期 Activity performLaunchActivity(){ Activity activity = new Activity(); activity.attach();//回调attach activity.onCreate();//回调Activity return activity; } } } /frameworks/base/core/java/android/app/Activity.java class Activity { Window mWindow;//Activity首次被创建调用attach()方法时同步创建，创建动作在Activity WindowManager mWindowManager;//在attach方法中被创建 //1. 创建PhoneWindow保存到变量mWindow，此时的Window还没有View视图 //2. 获取wms代理对象，塞到刚刚创建的window对象当中，同时保存到本地mWindowManager变量 void attach(Window window){ mWindow = new PhoneWindow(this, window); mWindow.setWindowManager(getSystemService(Context.WINDOW_SERVICE)); mWindowManager = mWindow.getWindowManager();//获取WindowManager动作在Activity中，获取完成接着设置给自己的局部变量 } //至此，APP进程启动成功，第一阶段结束，准备进入第二阶段 void onCreate(){ setContentView(); } } ApplicationThread作为AMS控制手柄，接受到启动Activity的指令后会转发到H#handleMessage()方法，最终由ActivityThread#handleMessage()方法执行来创建Activity对象 Activity对象创建完成以后，紧接着就会调用Activity的attach()方法 在Activity的attach()方法完成的工作中，最重要的就是：创建了类型为PhoneWindow的Window实例对象 2. DecorView的创建 在ActivityThread中，调用完attach()方法后紧接着就会调用Activity#onCreate()方法 开发者通常会在onCreate()方法中调用setContentView()来设置视图文件 这就进入到第二个阶段：DecorView的创建 /frameworks/base/core/java/android/app/ActivityThread.java class ActivityThread { //执行创建Activity对象并回调生命周期 Activity performLaunchActivity(){ Activity activity = new Activity(); activity.attach();//回调attach activity.onCreate();//回调Activity return activity; } } /frameworks/base/core/java/android/app/Activity.java class Activity { Window mWindow;//Activity首次被创建调用attach()方法时同步创建，创建动作在Activity WindowManager mWindowManager;//在attach方法中被创建 //第二阶段开始：加载视图文件并绑定到DecorView void setContentView(View view) { mWindow.setContentView(view); } //第二阶段已经完成，准备进入第三阶段 void onContentChanged(){ } } /frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java class PhoneWindow extends Window { DecorView mDecor; ViewGroup mContentParent; //1. 创建DecorView对象 //2. 将开发者设置的视图文件作为子View添加到mContentParent //3. 通知Activity中onContentChanged方法 void setContentView(View view) { mDecor = generateDecor(); mContentParent = generateLayout();//看generateLayout方法的注释 mContentParent.addView(view);//将开发者设置的视图添加为子View getCallback().onContentChanged();//回调Activity中onContentChanged()方法 } //创建一个空的DecorView，也就是FrameLayout，里面啥也没有 void generateDecor() { return new DecorView(this); } //1. 根据不同主题设置不同布局文件，加载该布局文件并设置成DecorView的子View //2. 返回子View中id为content的ViewGroup，通常还是个FrameLayout //以上两步执行完成以后，DecorView的布局变成： //&lt;FrameLayout&gt;//DecorView的根布局 // &lt;LinearLayout&gt;//开发者设置带有ActionBar的主题，注意，这里的视图可变的，根据主题来选择不同的视图 // &lt;ActionBar/&gt; // &lt;FrameLayout // android:id=&quot;@android:id/content&quot;/&gt;//这里的FrameLayout才是最终包含开发者在setContentView中设置的布局 // &lt;/LinearLayout&gt; //&lt;/FrameLayout&gt; void generateLayout() { //加载不同的theme主题的布局文件，比如我们在xml中指定android:theme=@style/NoActionBar View root = inflater.inflate(layoutResource); //将上一步解析的视图作为根布局添加到DecorView，常见的比如垂直方向的LinearLayout，这样布局DecorView mDecor.addView(root); //找到用来装用户视图的ViewGroup，通常还是个FrameLayout ViewGroup contentParent = mDecor.findViewById(R.id.content); return contentParent; } } //自身无逻辑，可以跳过 /frameworks/base/core/java/com/android/internal/policy/DecorView.java class DecorView extends FrameLayout { //DecorView和PhoneWindow互相持有 PhoneWindow mWindow; DecorView(PhoneWindow window){ mWindow = window; } } //定义View操作接口，顶级接口 /frameworks/base/core/java/android/view/ViewManager.java public interface ViewManager { public void addView(); public void updateViewLayout(); public void removeView(); } //啥也不是 /frameworks/base/core/java/android/view/WindowManager.java public interface WindowManager extends ViewManager { } //WindowManager的最终实现 /frameworks/base/core/java/android/view/WindowManagerImpl.java public class WindowManagerImpl implements WindowManager { WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); void addView(View decorView) { mGlobal.addView(decorView); } } //全局单例，和WMS建立连接通信，也是APP进程中，所有窗口实际的管理者 //内部mViews和mRoots变量保存着所有创建的Activity对应的View和ViewRootImpl class WindowManagerGlobal { List&lt;View&gt; mViews; List&lt;ViewRootImpl&gt; mRoots; void addView(View decorView){ ViewRootImpl root = new ViewRootImpl(decorView); mViews.add(decorView); mRoots.add(root); // do this last because it fires off messages to start doing things root.setView(view); } } 我们都知道DecorView是顶级View，而且它自身是个FrameLayout，所以在mWindow#setContentView()中第一步就是将DecorView对象创建出来 创建完DecorView后，接着会加载Activity使用的主题文件，并且将该主题作为子View添加到DecorView，这个子View就是mContentParent 有了mContentParent，最后才是将我们设置的视图添加为mContentParent的子View 稍微有点绕，简单来说DecorView作为一个FrameLayout，通常内部会再包含一个子View：mContentParent mContentParent中，会有一个名为R.id.content的FrameLayout，这个里面才是包含我们设置的视图 void setContentView(View view) { //&lt;FrameLayout&gt;//DecorView的根布局 // &lt;LinearLayout&gt;//开发者设置带有ActionBar的主题，注意，这里的视图可变的，根据主题来选择不同的视图 // &lt;ActionBar/&gt; // &lt;FrameLayout // android:id=&quot;@android:id/content&quot;/&gt;//这个FrameLayout才是最终包含开发者在setContentView中设置的布局 // &lt;/LinearLayout&gt; //&lt;/FrameLayout&gt; mDecor = generateDecor(); mContentParent = generateLayout();//看generateLayout方法的注释 mContentParent.addView(view);//将开发者设置的视图添加为子View getCallback().onContentChanged();//回调Activity中onContentChanged()方法 } 把开发者设置的视图添加为子View的下一步是回调Activity中onContentChanged()方法 当我们在Activity收到onContentChanged()回调的这一刻，说明DecorView已经创建完成 3. ViewRootImpl的创建 第一阶段和第二阶段分别让我们拥有了一个Window对象和一个DecorView对象 Window对象中包含了DecorView对象，DecorView包含了我们设置的视图文件 接下来的任务就是把该Window对象传递给WMS 和前两个阶段不同的是，第三阶段是在Activity的onResume()回调中被触发的 在ActivityThread通知完onResume()的下一步调用了makeVisible()方法 makeVisible()方法中，将会调用WindowManager#addView(mDecor)将视图传递给WMS /frameworks/base/core/java/android/app/ActivityThread.java class ActivityThread { void handleResumeActivity(){ performResumeActivity() activity.makeVisible();//开始执行第三个阶段 } //执行回调生命周期 void performResumeActivity(){ activity.onResume(); } } /frameworks/base/core/java/android/app/Activity.java class Activity { //第三阶段开始：将视图传递给wms //makeVisible()在ActivityThread.H.handleResumeActivity()方法中被调用 void makeVisible() { mWindowManager.addView(mDecor); } } //WindowManager的最终实现 /frameworks/base/core/java/android/view/WindowManagerImpl.java public class WindowManagerImpl implements WindowManager { WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); void addView(View decorView) { mGlobal.addView(decorView); } } //全局单例，和WMS建立连接通信，也是APP进程中，所有窗口实际的管理者 //内部mViews和mRoots变量保存着所有创建的Activity对应的View和ViewRootImpl /frameworks/base/core/java/android/view/WindowManagerGlobal.java class WindowManagerGlobal { List&lt;View&gt; mViews; List&lt;ViewRootImpl&gt; mRoots; void addView(View decorView){ ViewRootImpl root = new ViewRootImpl(decorView); mViews.add(decorView); mRoots.add(root); // do this last because it fires off messages to start doing things root.setView(view); } } //对应一个Activity，关于视图的事件触发都在此 //1. Choreographer让它能够感知事件 //2. 保存DecorView让它能够在事件来临时控制视图 //3. Surface让它拥有绘图的能力 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { Choreographer mChoreographer;//构造函数中被创建 View mView;//保存DecorView final Surface mSurface = new Surface(); public ViewRootImpl(){ //可以感知VSync的原因可以追溯到libgui库中的DisplayEventReceiver类 mChoreographer = Choreographer.getInstance(); } //1. 请求VSync信号，等待VSync来临后绘图 //2. 创建binder代理对象传递给wms，此后wms将通过此代理对象来通知APP进程应该做什么事 void setView(View decorView){ mView = decorView;//将DecorView保存到ViewRootImpl的成员变量mView中 requestLayout();//请求VSync信号 //通过binder向wms添加窗口 res = mWindowSession.addToDisplay(); } } WindowManagerImpl是WindowManager的最终实现类，它会调用到WindowManagerGlobal#addView()方法 而WindowManagerGlobal是全局单例，每个进程有且只有一个，也就是说 所有的Activity对应的Window都由WindowManagerGlobal进行管理 因此，WindowManagerGlobal会有两个关键集合：mViews和mRoots mViews是保管着的DecorView的集合，mRoots是保管着ViewRootImpl的集合 保管着ViewRootImpl的集合？DecorView是每个Activity的跟视图，ViewRootImpl是什么？ //对应一个Activity，关于视图的事件触发都在此 //1. Choreographer让它能够感知事件 //2. 保存DecorView让它能够在事件来临时控制视图 //3. Surface让它拥有绘图的能力 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { Choreographer mChoreographer;//构造函数中被创建 View mView;//保存DecorView final Surface mSurface = new Surface(); public ViewRootImpl(){ //可以感知VSync的原因可以追溯到libgui库中的DisplayEventReceiver类 mChoreographer = Choreographer.getInstance(); } } 看看ViewRootImpl类中的三个成员变量： mView：DecorView让ViewRootImpl能够在事件来临时控制视图 mSurface：让Activity拥有绘图的能力 mChoreographer：让ViewRootImpl能够监听VSync信号 王炸！！！一个类几乎集齐了所有与视图相关的成员 我们接着往下跟： /frameworks/base/core/java/android/view/WindowManagerGlobal.java class WindowManagerGlobal { List&lt;ViewRootImpl&gt; mRoots; void addView(View decorView){ ViewRootImpl root = new ViewRootImpl(decorView); mRoots.add(root); root.setView(view); } } /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { //1. 请求VSync信号，等待VSync来临后绘图 //2. 创建binder代理对象传递给wms，此后wms将通过此代理对象来通知APP进程应该做什么事 void setView(View decorView){ mView = decorView;//将DecorView保存到ViewRootImpl的成员变量mView中 requestLayout();//请求VSync信号 //通过binder向wms添加窗口，这个方法背后又是一大堆方法调用，这里不展开讨论 res = mWindowSession.addToDisplay(); } } WindowManagerGlobal创建了ViewRootImpl对象后，把它保存到本地集合mRoots 接着调用ViewRootImpl#setView()方法添加视图，setView()中又调用addToDisplay()方法通过binder向WMS添加窗口 至此，Window对象的创建、DecorView的创建和ViewRootImpl的创建这三大阶段全部完成 我们来总结一下在创建Activity阶段发生的事情 图片来源：自己画的 Activity中，创建PhoneWindow类型的Window对象 Window中，创建DecorView对象，绑定setContentView传入的视图文件 调用WindowManager添加视图，准备把视图绑定到WMS 创建ViewRootImpl作为最终的执行者，将视图添加WMS 请求VSync信号 在视图相关的对象创建就绪后，APP开始正式请求VSync信号 首次请求VSync信号的动作是在ViewRootImpl#setView()方法中触发的 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { void setView(View decorView){ requestLayout();//请求VSync信号 } void requestLayout() { scheduleTraversals(); } //请求VSync，等待刷新 void scheduleTraversals() { //1. 发送同步屏障消息的意义在于，保证VSync信号到来时，第一时间执行ViewRootImpl.doTraversal()方法 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();//创建一个同步屏障（详见Android消息机制） //2. 发送一条异步消息，mTraversalRunnable是处理这条消息的回调 mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); } final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); class TraversalRunnable implements Runnable { public void run() { //执行绘制流程 doTraversal(); } } } setView()方法中调用了requestLayout()方法，接着调用scheduleTraversals()方法进行VSync信号的请求 我们在开发过程中调用的View#invalidate()/requestLayout()这两个方法，最终也都会调用到ViewRootImpl#scheduleTraversals()方法请求VSync信号 我们来看看scheduleTraversals()里面都做了些什么？ 1、向主线程发送一个同步屏障消息 2、通过Choreographer提交类型为CALLBACK_TRAVERSAL的Runnable 一是向主线程中的消息队列发送一条同步消息，发送同步屏障消息的意义在于，保证VSync信号到来时，第一时间执行ViewRootImpl#doTraversal()方法 二是提交了mTraversalRunnable，如果VSync信号到来后将会被执行，mTraversalRunnable内部封装的是doTraversal()方法用于执行绘制流程 进入睡眠 等待唤醒 当请求信号发出以后，APP进程就进入等待状态，等待VSync发生 /frameworks/base/core/java/android/app/ActivityThread.java class ActivityThread { //zygote进程fork成功后调用入口函数 void main(){ Looper.loop(); } } Choreographer运行在主线程，也就是ActivityThread所在的线程，它们共用一个消息队列 所以，VSync请求最终阻塞在ActivityThread#main()方法中 三、处理VSync信号 万事俱备，只欠东风，APP进程等待着VSync信号的到来，SF进程则需要再等一段时间 1、APP进程：绘制三部曲 VSync以异步消息的身份被发送到主线程消息队列，该消息处理者为Choreographer中的mHandler对象 经过处理以后，最终会调用到ViewRootImpl#doTraversal()方法执行绘制，也就是View绘制三部曲：measure、layout、draw /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { View mView;//保存DecorView //开始绘制 void doTraversal() { mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);//移除同步屏障 //由于同步屏障消息被移除，所以view的绘制工作和主线程的消息处理是一起在执行的 performTraversals();//View的绘制起点 } //绘图三部曲 void performTraversals(){ relayoutWindow();//向sf正式申请surface，在进入绘图之前为APP进程准备好一块surface内存 mAttachInfo.mHardwareRenderer.initialize(mSurface); performMeasure();//Ask host how big it wants to be performLayout(); performDraw(); } void performMeasure(){ mView.measure(); } void performLayout(){ mView.layout(); } void performDraw(){ mView.draw(); mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this); } //创建surface //viewrootimpl持有的surface是Java对象，并没有在native创建对应的surface //不过这一些对于APP进程来说是无感的，APP-&gt;WMS-&gt;SF-&gt;WMS-&gt;APP，在这个过程中APP //在此方法中，调用wms为其创建native层的surface对象，在surface创建的过程中，会通知sf进程，sf进程为surface创建对应的layer，创建layer的过程中，又会初始化BufferQueue对象 //surface中包含bufferqueue，所以sf进程除了为surface创建layer，还会为surface创建队列监听，当有新的视图变化，sf进程将会收到onFrameAvaliable()回调 int relayoutWindow(){ } } 在开始绘图之前，ViewRootImpl还做了两件事 一是移除同步屏障消息，View的绘制流程执行结束后，让我们开发者post的消息得以执行 二是调用了relayoutWindow()方法，向sf正式申请Surface，在进入绘图之前为APP进程准备好一块Surface内存 好了，接下来正式执行绘图流程 View#onMeasure() performMeasure()方法中调用了View#measure() ViewRootImpl成员变量mView保存的是DecorView对象，所以，measure()方法将会从跟视图一层层向下遍历 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { View mView;//保存DecorView void performMeasure(){ mView.measure(); } } 在遍历整个View树的过程中，会出现多次遍历才能确定View大小的情况，尤其对于ViewGoup来说，取决于测量模式和LayoutParams配置等参数 在本章节我们需要了解：measure()方法是为了计算每一个View需要的大小，measure()方法执行完成以后，各个View的大小也都确定了 View的绘制我打算另起一篇文章介绍，所以关于onMeasure()细节部分，比如测试模式touchMode以及焦点的处理等，这里暂时不展开，之后的layout和draw也都会一笔带过 View#onLayout() performLayout()方法中调用了View#layout() /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { View mView;//保存DecorView void performLayout(){ mView.layout(); } } 上一小节measure执行完以后，确定了各个View的大小 在本章节中，layout()方法是为了计算每一个View的位置，layout()方法执行完成以后，各个View的位置也都确定了 View#onDraw() performDraw()方法中调用了View#draw() draw是最终绘制的阶段，在View体系中，所有的绘图操作都在draw阶段得到执行 /frameworks/base/core/java/android/view/ViewRootImpl.java class ViewRootImpl { View mView;//保存DecorView void performDraw(){ mView.draw(); } } 在执行View#draw()时，逻辑会和measure、layout过程有一点点不一样 measure过程和layout过程都是发生在CPU，draw不同，如果开启硬件加速，那么draw的过程发生在GPU 并且，Android 5.0版本加入了RenderThread，开启硬件加速后，在执行draw的过程中，Android将单独启动一个渲染线程来执行绘制任务 不过对于开发者来说，这一切是无感的 /frameworks/base/core/java/android/view/View.java class View { /** * This method is called by ViewGroup.drawChild() to have each child view draw itself. * * This is where the View specializes rendering behavior based on layer type, * and hardware acceleration. */ boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) { final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated(); /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList. * * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't * HW accelerated, it can't handle drawing RenderNodes. */ } } 关于RenderThread资料并不多，我们只能从源码注释中看看能否得到一些有用的信息，如上文 如果启用硬件加速，此时每一步绘图操作都将以RenderNode的形式保存到DisplayList 然后同步给RenderThread执行实际的渲染工作 如果关闭硬件加速，在onDraw()阶段View将会直接调用Canvas API画图，此时的渲染工作执行在UI线程 启用渲染线程的好处网上倒是有现成的资料，我给大家念一念： 显示列表可以根据需要绘制任意多次，无需进一步与业务逻辑交互 可以对整个列表进行某些操作（如平移、缩放等），而无需重新发出任何绘图操作 一旦知道所有的绘图操作，就可以对其进行优化：例如，所有文本在可能的情况下一次绘制在一起 显示列表的处理可能会被分发到另一个线程中执行 来自于：《Understanding the RenderThread》 我个人理解下来单独启用渲染线程有两大好处： 一是去除重复绘图指令，比如多次setText只保留最后一次 二是减轻UI线程压力，一旦绘图指令收集完成，就可以同步给渲染线程执行，这样主线程剩余的时间就可以用来执行其他的消息，比如我们post的消息 不过，不管有没有开启硬件加速，绘制工作执行在哪个线程，整个渲染流程还是要控制在一个VSync信号周期内完成，否则，该丢帧还是会丢帧 特殊情况：SurfaceView 在游戏开发或其他需要展示3D图形时，多数情况是使用SurfaceView来绘制 SurfaceView作为DecorView跟视图的成员之一，和普通View一样能够接受到Input事件（覆写onTouchEvent方法） 不过，SurfaceView有普通View没有的能力：“自主上帧”的权利 什么“自主上帧”呢？ 我们都知道SurfaceView拥有单独的一块Surface，无论是使用Canvas进行2D开发还是OpenGL ES进行3D开发，最终的绘制结果都是保存在这块单独的Surface上 绘制完成以后，SurfaceView可以调用unlockCanvasAndPost()/eglSwapBuffers()将GraphicBuffer入列，提交给sf进程等待合成送显 SurfaceView让应用无需等待VSync信号的到来便可以执行绘制工作，这是它和普通View最大的区别 2、SF进程：合成五部曲 无论应用使用哪种API进行图形开发，在绘制流程结束后，APP作为图层的生产者总是会调用BufferQueue#queueBuffer()方法将GraphicBuffer入列 一旦有新的图层加入队列，就意味着作为图层消费者的SF进程可以开始工作了 sf进程请求VSync 由于VSync是注册制，因此，sf进程在工作之前必须先请求VSync信号 /frameworks/native/services/surfaceflinger/Layer.cpp class Layer { //当Surface发生变化以后，最终会调用onFrameAvailable()方法通知sf，让sf请求下一次VSync //这里需要注意，VSync信号是EventThread来分发的，APP和sf各自管理自己是否需要请求下一次VSync信号 void Layer::onFrameAvailable() { mFlinger-&gt;signalLayerUpdate(); } } /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { //queue内部调用了请求下一次VSync void SurfaceFlinger::signalLayerUpdate() { mEventQueue.invalidate(); } } /frameworks/native/services/surfaceflinger/MessageQueue.cpp class MessageQueue { //最终在MessageQueue类中执行了请求VSync信号的操作 void MessageQueue::invalidate() { mEvents-&gt;requestNextVSync(); } } 当APP端的Surface发生变化以后，Layer的onFrameAvailable()方法会被调用，经过层层转发，最终由MessageQueue#requestNextVSync()执行VSync信号的请求 Layer这个类之前好像没有出现过，简单介绍一下： APP进程中的每一个Surface对象，对应SF进程当中的一个Layer对象，它俩共享一个BufferQueue Surface作为图层的生产者，封装了出列入列的操作 Layer作为图层的消费者，封装了获取渲染图层和释放图层的操作 sf进程处理VSync sf进程使用MessageQueue类执行了请求VSync信号的动作，所以，VSync信号到来后的处理同样也是在MessageQueue类中 /frameworks/native/services/surfaceflinger/MessageQueue.cpp class MessageQueue { //接受来自DisplayEventReceiver的VSync信号 int MessageQueue::eventReceiver(int /*fd*/, int /*events*/) { mHandler-&gt;dispatchInvalidate(); return 1; } //收到VSync信号后，向sf进程中发送类型为&quot;INVALIDATE&quot;的消息 void MessageQueue::Handler::dispatchInvalidate() { mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE)); } //外部接口，用于向sf发送合成消息 void MessageQueue::refresh() { mHandler-&gt;dispatchRefresh(); } //给sf发送类型为REFRESH的消息，sf收到以后将会执行合成操作 void MessageQueue::Handler::dispatchRefresh() { mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::REFRESH)); } } /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { void SurfaceFlinger::onMessageReceived(){ //接收到VSync信号后，判断图层是否需要合成 case MessageQueue::INVALIDATE: { bool refreshNeeded = false; refreshNeeded = handleMessageTransaction(); refreshNeeded |= handleMessageInvalidate(); //如果需要合成，通知MessageQueue发送一条REFRESH类型的消息 if(refreshNeeded) signalRefresh(); } //将会执行最终的合成操作 case MessageQueue::REFRESH: { handleMessageRefresh();//合成并输出到屏幕 } } //调用mEventQueue给sf自己发送一条Refresh类型的消息 void SurfaceFlinger::signalRefresh() { mEventQueue.refresh(); } } MessageQueue#eventReceiver()收到VSync信号后发送INVALIDATE消息给sf进程 SurfaceFlinger##onMessageReceived()方法被触发 在case为INVALIDATE的方法中，调用handleMessageTransaction()、handleMessageInvalidate()检查是否需要执行下一步合成 如果需要执行合成，最终会执行到SurfaceFlinger#handleMessageRefresh()方法 sf进程执行合成 一旦调用到handleMessageRefresh()方法，意味着SF进程的合成工作正式开始 整个合成流程有五个步骤，所以可以取名叫做“合成五部曲” 接下来我们一起来看看“合成五部曲”都做了哪些事情： /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { //合成五部曲 void SurfaceFlinger::handleMessageRefresh(){ //合成之前的与处理，检查是否有新的图层变化，如果有，执行请求下一次VSync信号 preComposition(); //若Layer的位置/先后顺序/可见性发生变化，重新计算Layer的目标合成区域和先后顺序 rebuildLayerStacks(); //调用hwc的prepare方法询问每个图层是否支持硬件合成 setUpHWComposer(); //当打开开发者选项中的“显示Surface刷新”时，额外为产生变化的图层绘制闪烁动画 doDebugFlashRegions(); //如果不支持硬件合成，在该方法中会调用GPU合成，接着提交buffer doComposition(); //调Layer的onPostComposition方法，主要用于调试，可以忽略 postComposition(refreshStartTime); } void SurfaceFlinger::preComposition(){ bool needExtraInvalidate = false; const LayerVector&amp; layers(mDrawingState.layersSortedByZ); const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) { //因为在调用合成之前已经计算过脏区域，如果有图层在计算以后加入了队列，那么在预处理阶段要再次请求VSync信号 if (layers[i]-&gt;onPreComposition()) { needExtraInvalidate = true; } } //存在未处理的layer，执行请求下一次VSync信号，避免这段时间内的帧数据丢掉了 if (needExtraInvalidate) { signalLayerUpdate(); } } void SurfaceFlinger::rebuildLayerStacks(){ //获取当前应用程序所有按照z-order排列的layer const LayerVector&amp; layers(mDrawingState.layersSortedByZ); //遍历每一个显示屏 for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) { //z-order排列的layer hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ); //显示屏大小 hw-&gt;undefinedRegion.set(bounds); //减去不透明区域 hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion)); //累加脏区域 hw-&gt;dirtyRegion.orSelf(dirtyRegion); } } void SurfaceFlinger::setUpHWComposer() { //prepareFrame方法中调用了HWComposer::prepare方法 for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) { auto&amp; displayDevice = mDisplays[displayId]; if (!displayDevice-&gt;isDisplayOn()) { continue; } status_t result = displayDevice-&gt;prepareFrame(*mHwc); } } void SurfaceFlinger::doComposition(){ //遍历所有的DisplayDevice然后调用doDisplayComposition函数 for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) { const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); if (hw-&gt;isDisplayOn()) { //获得屏幕的脏区域，将脏区转换为该屏幕的座标空间 const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything)); //在此方法中将会调用到doComposeSurfaces()方法 //在doComposeSurfaces方法中，将会为被标记为不支持硬件合成的图层调用Layer#draw()方法使用OpenGL ES合成 doDisplayComposition(hw, dirtyRegion); } } postFramebuffer(); } //第五步：更新DispSync机制，详情参见 void SurfaceFlinger::postComposition(){ //更新DispSync机制，详情参见 } } 1. preComposition() 第一步是预处理阶段，调用每个layer的onPreComposition()方法询问是否需要合成 /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { void SurfaceFlinger::preComposition(){ bool needExtraInvalidate = false; const LayerVector&amp; layers(mDrawingState.layersSortedByZ); const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) { //因为在调用合成之前已经计算过脏区域，如果有图层在计算以后加入了队列，那么在预处理阶段要再次请求VSync信号 if (layers[i]-&gt;onPreComposition()) { needExtraInvalidate = true; } } //存在未处理的layer，执行请求下一次VSync信号，避免这段时间内的帧数据丢掉了 if (needExtraInvalidate) { signalLayerUpdate(); } } } 第一步执行完以后，根据needExtraInvalidate来确定是否有遗漏的图层，如果有就再次请求VSync信号，避免丢失帧数据 2. rebuildLayerStacks() 第二步：计算各个Layer的目标合成区域和先后顺序 /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { void SurfaceFlinger::rebuildLayerStacks(){ //获取当前应用程序所有按照z-order排列的layer const LayerVector&amp; layers(mDrawingState.layersSortedByZ); //遍历每一个显示屏 for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) { //z-order排列的layer hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ); //显示屏大小 hw-&gt;undefinedRegion.set(bounds); //减去不透明区域 hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion)); //累加脏区域 hw-&gt;dirtyRegion.orSelf(dirtyRegion); } } } 第二步执行完以后，确定了每个图层的可见区域和跟其他图层发生重叠部分的脏区域 3. setUpHWComposer() 第三步：更新HWComposer对象中图层对象列表以及图层属性 prepareFrame()方法中调用了HWComposer#prepare方法 在HWC的prepare()方法中，将会确定每一个图层使用哪种合成方式 /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { void SurfaceFlinger::setUpHWComposer() { //prepareFrame方法中调用了HWComposer::prepare方法 //在HWC的prepare方法中，将会确定每一个图层使用哪种合成方式 for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) { auto&amp; displayDevice = mDisplays[displayId]; if (!displayDevice-&gt;isDisplayOn()) { continue; } status_t result = displayDevice-&gt;prepareFrame(*mHwc); } } } 第三步执行完以后，确定了每个图层的合成方式 4. doComposition() 第四步：执行真正的合成工作 /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { void SurfaceFlinger::doComposition(){ //遍历所有的DisplayDevice然后调用doDisplayComposition函数 for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) { const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); if (hw-&gt;isDisplayOn()) { //获得屏幕的脏区域，将脏区转换为该屏幕的座标空间 const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything)); //在此方法中将会调用到doComposeSurfaces()方法 //在doComposeSurfaces方法中，将会为被标记为不支持硬件合成的图层调用Layer#draw()方法使用OpenGL ES合成 doDisplayComposition(hw, dirtyRegion); } } postFramebuffer(); } } 第四步执行完以后，完成了两件事： 将不支持硬件合成的图层进行GPU合成 在doComposeSurfaces()方法中，将会为被标记为不支持硬件合成的图层调用Layer#draw()方法使用OpenGL ES合成 调用postFramebuffer()进行送显 postFramebuffer()方法会将GPU合成后的图层和需要HWC合成的图层一起打包提交给HWC HWC最终会调用DRM框架进行送显，当下一次硬件VSync信号发生时交换Framebuffer 5. postComposition() 第五步：送显之后的善后工作 在Android 7.0版本中，postComposition()方法用来执行更正DispSync模型，可以忽略 /frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp class SurfaceFlinger { //第五步：更新DispSync机制，详情参见 void SurfaceFlinger::postComposition(){ //更新DispSync，详情参见DispSync模型一节 } } ps：关于SF进程合成部分的源码不方便调试，所以这里的结论没有得到验证不一定对 另外，合成部分大多数内容都来自于[这里，读者朋友可以去查找其他资料学习 3、小结 至此，APP绘制工作和SF合成工作已经全部完成，我们来画张图总结一下本章节内容 图片来源：自己画的 一个APP完整的显示流程大致分为三个阶段 app-请求 APP页面元素一旦发生变化，调用invalidate()/requestLayout()方法请求下一次VSync信号，此时sf什么都不做 app-VSync &amp; sf-请求 app-VSync信号到来后，APP进程执行绘图三部曲， 绘图流程结束后，sf收到onFrameAvailable()，sf进程请求VSync sf-VSync sf-VSync信号到来，sf进程执行合成五部曲，接着将结果提交给hwc 等待下次硬件VSync信号发生，切换Framebuffer展示给用户 四、结语 本文把Android图形子系统分为两个部分：静态部分和动态部分 在静态部分中，硬件驱动和Google组件库为应用提供了绘图的能力 在动态部分中，介绍了VSync信号是如何把系统打理的井井有条的，着重分析了各个进程是如何请求和处理VSync信号 有了这两部分的内容，我们来尝试解答一下文章的标题：当我们点击“微信”这个应用后，它是怎么在屏幕上显示出来的？ Launcher进程拉起微信的默认启动页：WeChatSplashActivity WeChatSplashActivity加载视图文件，AMS和WMS为Activity创建DecorView、Window、ViewRoot 视图文件准备就绪，请求VSync信号 app-VSync处理，执行绘制三部曲，绘制结束以后，通知sf进程 sf进程请求VSync信号 sf-VSync处理，执行合成五部曲，提交到hwc hw-VSync原始信号处理，显示框架执行交换图层数据，用户看到微信的启动图 最后，本篇文章之所以能够顺利产生，得益于各位前辈的无私分享（见参考资料） 希望本文能够起到抛砖引玉的效果，给各位读者朋友带来一点点帮助 全文完 五、参考资料 《深入理解Android内核设计思想》- 林学森 《深入理解Android 卷III》- 张大伟 《Weishu's Notes》- 田维术（太极/两仪作者） 《Android显示系列》- 努比亚团队 《Systrace系列》- 高爷 《Android 10 Display System源码分析》- ZHOUJINJIAN 《DRM与BufferQueue系列》- 何小龙 《Android图形显示系列》- 夕阳叹 《王小二的Android站》- 王小二（TCL王总） 《Silence.Slow.Simple专栏》- simowce 《Android SurfaceFlinger 学习之路》- windrunnerlihuan 《Android 12(S) 图像显示系统》- 二的次方 深入理解Flutter的图形图像绘制原理 - OPPO数智技术 Android性能优化：定性和定位Android图形性能问题 - 飞起来_飞过来 ","link":"https://yibaoshan.github.io/post/android-graphics-system/"},{"title":"Android图形系统（二）驱动篇：垂直同步到底要不要开？","content":" 点击跳转到掘金阅读 对于应用开发工程师来说，虽然我们不需要写驱动程序，但是了解View最终是如何显示到屏幕上还是非常有必要的 本篇是Android图形系列的第二篇文章，依旧是一些关于屏幕的名词解释，和Android系统本身没有太大关系，相较于第一篇文章，本篇重点在于介绍“屏幕刷新”和“垂直同步”相关的知识点 一、开篇 平时打游戏时会发现屏幕偶尔会出现“画面撕裂”的情况，屏幕的上半部分和下半部分的画面错开了 图片来源：自己拍的 去网上搜画面撕裂怎么办？有网友说打开游戏中的“垂直同步”选项可以解决了，但也有网友说不要开垂直同步，开了之后显卡会被“锁帧”，还会带来屏幕画面延迟，弊大于利 为什么两边的对于“垂直同步”的看法不一样？垂直同步到底是个什么东西？ 更加让人疑惑的是：显示器为什么会发生画面撕裂？ 这一切的一切都得从“刷新率”和“帧率”开始讲起 1、什么是刷新率 刷新率的概念诞生自CRT显示器 早期的CRT屏幕显示画面是靠电子束激发屏幕内表面的荧光粉来显示图像的，由于荧光粉被点亮后很快会熄灭，所以电子枪必须循环地不断激发这些点，电子束从左到右、从上到下点亮荧光粉的过程，被称为“逐行扫描”技术 在一秒钟内电子束能够扫描出一幅完整画面的速度，被称为屏幕的刷新率，表示单位为HZ 图片来源：http://electronicsgurukulam.blogspot.com/2012/04/how-television-screen-works.html 60HZ屏幕就是显示器一秒钟显示60次画面，即1/60秒内出一个画面 LCD液晶屏和OLED屏同样使用“逐行扫描”来刷新屏幕像素 不过由于显示原理发生了变化，屏幕的每个像素点都可以单独控制是否发光 所以LCD/OLED屏幕的“逐行刷新”和CRT显示器上的原理是不一样的，在现在的显示器中，“逐行刷新”指的是控制器单次会一行或者多行更新像素 这种技术被称为有源矩阵驱动，也就是市场上主流的TFT-LCD屏和AMOLED屏 图片来源：https://tech.sina.cn/2020-06-07/detail-iircuyvi7202205.d.html 屏幕超频？ 一块完整的显示设备主要由LCD或OLED显示器件、驱动电路、控制器这三部分组成，既然有驱动程序，那么我们就可以尝试修改屏幕的刷新率，即屏幕超频 图片来源：自己截的 我手里Pixel 3就被我用酷安大佬做的“RR屏幕刷新率”APP从60HZ超频到了61HZ 除了用APP超频外，Android端还可以通过adb命令修改frame rate值、刷系统内核的来修改刷新率，感兴趣的同学可以看这篇帖子：超屏幕刷新率所需的参数？ Windows系统下显示器超频更容易，可以在显卡的控制面板中自定义屏幕刷新率，笔记本用户可以下载Custom Resolution Utility(简称CRU)写入EDID信息来修改屏幕刷新率 超频的操作步骤很简单，但考虑到屏幕刷新率都是有上限的，不建议一次性超太高 对于LCD液晶屏和OLCD屏幕来说，刷新率的上限取决于两点： 一是屏幕自身素质，通常是指屏幕的“灰阶响应时间”，刷新率设置过高会像素颜色反应不过来，会导致屏幕偏色、拖影等问题 二是配套的硬件素质，比如屏幕供电、贷款总线等，刷新率过高可能导致屏幕无法正常工作，比如显示器黑屏、触摸屏失灵 现在的显示器一般都有扫描保护电路，但如果你的屏幕没有这一类保护电路的话，超频可能会损坏显示器内部电路，最终导致显示器报废 总之，超频有风险，刷机需谨慎 2、什么是帧率 帧率一直是视频领域中的概念，它的诞生最早可以追溯到1860年无声电影时代 在视频领域中，帧率可以分为拍摄和放映两部分： 在拍摄视频时，帧率指的是每秒钟记录的画面数量 在播放视频时，帧率指的是每秒钟输出的画面数量 1973年施乐公司发明出第一台带有图形用户界面（GUI）的计算机之后，帧率一词也沿用到计算机领域 在计算机中，帧率指的是每秒钟计算机能够渲染出的画面数量 帧率的概率很容易理解，它的难点在于当“帧率”和“刷新率”组合在一起时，情况就可能会变的复杂了一些，我们来看几个问题： 显卡每秒能生成250帧画面，但是显示器只有90HZ，多出来的160帧画面有没有意义？是不是白白浪费了显卡性能？ 新买了一台144HZ的显示器，但我的显卡性能很拉胯，玩游戏的平均帧率只有30FPS，显示器会帮我补帧吗？ 网友都说出现撕裂的根本原因在于显卡输出帧的速度比显示器快，买一台高刷显示器就可以避免画面撕裂，真的是这样吗？是不是一群卖显示器的商家挖的消费陷阱？ 这几个问题分别对应了“帧率大于刷新率”、“刷新率大于帧率”以及“帧率和刷新频率不匹配导致的画面撕裂”这三种情况 接下来我们就从显卡和显示器工作原理的角度来聊聊：当刷新率和帧率不匹配时，计算机会如何处理？ 显卡和显示器之间是如何协同工作的？ 首先我们要知道一点，显卡和显示器虽然在同一块主板上，但是它俩互相是不知道彼此的存在的，显卡和显示器完全有可能来自不同的厂家 操作系统启动后会开辟出一块内存专门用于画面显示，这块共享内存被称为“帧缓存区”，也就是我们经常听到的frame buffer，它可以位于显存，也可以位于内存，由操作系统决定如何分配 在不进行任何设置的前提下，操作系统通常使用的是双缓存策略： 显示控制器驱动正在读取的是一个帧缓存，我们称之为前缓存 显卡绘制后写入的另一个帧缓存，称之为后缓存，显卡绘制完一帧后通知CPU交换前后缓存的顺序 显示器刷新的过程，就是不停的切换由前后缓存组成的缓存队列 图片来源：自己画的 显示器负责从前缓存读数据，然后每次一行或多行更新像素颜色，显卡负责画图，向后缓存写数据，渲染完成后通知CPU交换帧缓存 仔细观察流程图会发现，在整个的工作流程中，显卡和显示器之间是没有任何联系的，这也是导致画面撕裂的原因 为什么会发生画面撕裂？ 下图模拟的是显示器正在刷新屏幕像素，其中上半部分的图像已经刷新完成 图片来源：自己做的 而此时显卡也刚好完成下一帧的渲染工作，并触发了交换帧缓存 显示器依旧按照当前的偏移量读取数据，屏幕最终得到的来自两个不同帧缓存拼接的画面，也就是画面发生了撕裂 图片来源：自己做的 重点来了！！屏幕像素点一旦刷新完成，下次刷新要等到16ms以后，刷新率越低等待的时间越长 这也是我们人眼能够察觉到“画面撕裂”的原因 综上，我们可以得出以下结论： 发生画面撕裂的原因：帧缓存的交换随时可能会发生，一旦显卡在不恰当的时机交换了帧缓存，屏幕就会发生画面撕裂 画面撕裂能被人眼感知的原因：撕裂的画面帧会在屏幕上停留十几毫秒的时间，如果画面连续发生撕裂，对于比较敏感的人来说是可以捕捉到的 二、垂直同步信号 既然画面撕裂的原因是显卡在不恰当的时机交换了帧缓存，那我们让显卡在显示器刷新的这段时间内，不触发交换frame butter的动作不就解决问题了 垂直同步就是用来做这样的事情的 1、什么是垂直同步 具体实现上，我们可以让显示控制器驱动在每次刷新屏幕之后，主动向CPU发起一个中断，代表显示器刷新完成 显卡画面渲染完成以后进入阻塞状态，等收到显示器的完成信号后再去交换帧缓存 图片来源：自己画的 显示器发送的中断信号，就被称为垂直同步（VSync）信号 通过增加垂直同步信号的方式，使得每次交换帧缓存的时机变得可控，大大降低了画面撕裂发生的概率 不过，垂直同步在“画面撕裂”的同时，也带来了两个新的问题.. 垂直同步的弊端 当显卡的垂直同步功能被置为TRUE以后，每一帧渲染完调用SwapBuffers函数时，都要等待下一次屏幕刷新的时刻到来，才能交换前后缓存并开始执行下一帧… 这就产生了两个新的问题： 一是显卡接收到VSync信号后才去工作，会导致显卡输出的帧率永远不可能大于屏幕的刷新率，可以简单理解为显卡锁帧 二是在等待垂直同步信号的这段时间内，鼠标、键盘等事件不能及时的显示到屏幕上，会导致画面延迟 问题一对大部分人来说还可以接受，显卡性能足够的情况下可以稳定输出60帧，非竞技类游戏的话影响不是很大 但是问题二的画面延迟就很难接受了，60HZ的显示器最大延迟能达到十几毫秒，如果玩的是CSGO、PUBG、穿越火线等FPS游戏，十几毫秒的延迟还是很客观的 那有没有什么方法能够解决垂直同步信号带来的弊端呢？ 有，就是经常跟垂直同步一起出现的另一个词：三重缓存 2、什么是三重缓存 三重缓存是指在开启了垂直同步的基础上，再增加一个中缓存，和原有的前后缓存组成缓存队列 中缓存保证任何时候都有一帧完整的画画数据等待着交换，显示器读取数据的是前缓存，VSync信号到来后前缓冲和中缓存发生交换 显卡正在写入数据的是后缓存，显卡渲染完一帧画面后，后缓存只和中缓存发生交换 图片来源：自己画的 三重缓存让我们有开启垂直同步时的所有好处，我们得到了流畅且没有撕裂的画面，同时，我们还拥有近似关闭垂直同步时那样低的输入显示延迟 那是不是在打游戏时把三重缓存选项都打开就可以解决画面延迟了呢？ 得分情况，在Windows系统下的游戏不建议打开 DirectX是微软提供的多媒体编程接口，绝大多数PC端游戏都是使用DirectX框架进行开发，DX的“三重缓存”和这里的三重缓存不是一个意思，DX中的那个是先进先出的帧缓存队列 显卡绘制完之后不会和前缓存发生交换，而是将帧数据存入帧缓存队列，当显卡接受到垂直同步信号之后把最顶端的帧数据交给屏幕显示 最新的画面帧永远都在队列的最底端，队列的长度越长，画面的延迟就越明显，这也是为什么PC端的游戏能单独启用“三重缓冲”功能，以及为什么打开“三重缓存”选项后会感觉延迟变高的原因 解决方法也很简单，N卡驱动程序中有个超低延迟模式，打开之后会将Max_Prerendered_Frame设为1，就是将缓存队列的最大长度设置为1，再搭配上垂直同步技术，就能够大大改善画面撕裂以及画面延迟的情况 3、什么是自适应刷新 自适应刷新也是一种解决“画面撕裂”的方案，算是“垂直同步”的改良版本 英伟达的G-SYNC、AMD的FreeSync以及苹果的ProMotion技术都可以理解为是自适应刷新技术 自适应刷新在保留垂直同步信号的基础上又增加了一个中断信号，这个中断信号是由显卡发起的，表示显卡渲染完一帧画面 显示器在没有接受到显卡完成的信号之前，不刷新屏幕或者以极低的速率去刷新 图片来源：自己画的 由于加入了新的同步信号，所以显示器在没有新的画面帧产生之前，也可以进入等待状态，不必按照固定速率去刷新屏幕 我们实际看到的帧率就变成了，超过屏幕最大刷新率，按照屏幕最高刷新率来显示；否则，按照显卡输出的帧率来显示，这也是“自适应刷新”名称的由来 在桌面端，自适应刷新能够在最大限度的保证画面无撕裂的同时还可以做到几乎忽略不计的输入延迟，在移动端，除了以上的有点外，自适应刷新还可以降低能耗 所以，在可预见的将来，自适应刷新一定会成为标准技术，应用到每一台计算机上 三、结语 回顾垂直同步和自适应刷新的发展史，会发现本质是显卡和显示器一步步建立通信的发展史 显卡和显示器对于CPU来说都属于是I/O外设，在没有建立通信之前，它俩是各忙各的 因为显卡随时可能去交换帧缓存导致画面发生撕裂，于是加入了垂直同步信号，让显示器每次刷新完通知显卡一声 这就建立了单向通信，显卡可以监听显示器的活动了 后来发现显卡偶尔渲染一帧画面耗时比较久，而显示器那边还在按照固定速率不停的在刷新，在没有产生新的画面帧的前提下，显示器的刷新动作是没有意义的，于是让显卡也可以发送信号，每次渲染完成通知显示器一声，显示器接收到信号再去刷新屏幕 这就建立了双向通信，显卡可以监听显示器的活动，显示器也可以监听显卡的活动 最后，回到文章的标题：垂直同步到底要不要开？ 如果玩主机游戏，建议打开垂直同步，毕竟都玩3A了肯定沉浸式体验游戏剧情最重要，你也不想在玩游戏时画面发生撕裂吧 如果玩竞技类游戏，尤其是FPS游戏，建议关闭垂直同步，竞技类游戏玩的就是抢时间，而开启垂直同步就意外着有延迟，哪怕再开启“三重缓存”选项也只能是减缓延迟 如果你有一台144HZ高刷电竞显示器，那开不开垂直同步影响不是很大，看你心情 虽然高刷屏依旧会发生画面撕裂，但下一次屏幕刷新会很快到来，屏幕会被新的画面帧覆盖，所以只要不是连续在同一位置发生撕裂，人眼很难察觉到屏幕发生了撕裂 全文完 四、参考资料 Triple Buffering: Why We Love It 《计算机图形学基础（第3版）》-陆枫, 何云峰 《彩色液晶显示》-（日）堀 浩雄 【硬核科普】奇妙的帧率增加了！ ","link":"https://yibaoshan.github.io/post/android-graphics-driver/"},{"title":"Android图形系统（一）硬件篇：LCD和OLED怎么选？","content":" 点击跳转到掘金阅读 对于应用开发工程师来说，虽然我们不需要写驱动程序，但是了解View是最终如何显示到屏幕上还是非常有必要的 本篇是View系列的第一篇文章，主要讨论的是Android手机屏幕的种类以及和屏幕相关的技术名词 一、开篇 手机屏幕发展至今，市场上在售手机的屏幕类型基本可以分为两种：LCD屏和OLED屏 其实不只是手机屏幕，电脑和电视屏幕面板基本也就这两种 我们平时在买屏幕时看到的IPS屏，TN屏等都属于LCD屏阵营，他们的区别只是液晶层结构或者背光模组结构不同 OLED屏幕因为价格比较贵，寿命也比不过LCD屏，所以OLED在显示器和电视机领域还没有大面积应用 但在手机圈，各大厂商自2020年之后生产的旗舰机，几乎都标配OLED屏幕 相较于LCD屏幕 OLED屏幕支持更高的亮度、对比度以及更艳丽的色彩 更快的响应速度，高刷体验更好 不需要背光板，采用COP方案封装，理论上可以去掉宽下巴 在手机屏幕追求超高屏占比的时代，LCD被彻底的抛下车 但是，虽然OLED屏有许多LCD无法比拟的优势，但它同时也带了两个新的问题：烧屏和低频PWM调光 1、OLED屏缺陷：烧屏 烧屏指的是手机屏幕长时间停留在某个静止画面，特别是极个别高对比度画面，再切换到其他画面时仍然能看到原来画面的残影，而且残影不会消失 比如我之前在拼多多上买的二手Pixel 3就发现老化烧屏的现象 仔细观察**“位置信息”**一栏会发现，在屏幕上残留的有谷歌邮箱的图标icon 如今厂商用各种方案为OLED延长使用寿命，例如定期改变虚拟导航栏的位置、定期调节色温等等，但是现阶段烧屏问题还是会普遍存在的OLED屏幕上 烧屏是一个不可逆的过程，一旦手机出现烧屏，会严重影响日常的使用体验，不能忍的话只能换屏幕或者换手机 图片来源：B站评论：全网最简洁易懂的OLED与LCD屏幕工作原理与优劣科普 为什么OLED会烧屏？ 讨论这个问题之前我们先来看LCD屏和OLED屏的结构组成 LCD是由背光模组，下偏光片，液晶层，滤光层和上偏光片组成，通过改变施加在液晶层上的电压大小来控制每个像素点颜色 图片来源：https://zhuanlan.zhihu.com/p/30201452 OLED是有机发光材料作发光层，发光层上方有一层低功函数的金属电极，构成如三明治的结构，通过改变施加在自发光二极管上的电压大小来控制每个红黄蓝子像素亮度，进而改变每个像素点的颜色 图片来源：https://zhuanlan.zhihu.com/p/30201452 对OLED发光原理感兴趣的可以看这篇文章《OLED发光原理和OLED面板结构及OLED关键技术深度图文解析》，文中从发光原理介绍到屏幕驱动技术再到制造和封装等360度无死角覆盖 LCD屏幕基板是无机玻璃材料，所以几乎不会发生老化，而OLED基板是有机塑料材料，就意味着它会渐渐老化 LCD要么全亮要么全灭，所以就算老化，也是全部老化，你也看不出来 OLED由于每个像素点是自发光，而不是LCD那样整块全部亮，这就会导致OLED每个像素点工作的时间不一样 有的像素点显示蓝色的时间长，那么他的蓝色衰减就会比其他像素点多，日后再显示蓝色的时候这一个像素点的蓝色就要比其余的淡一点，同样的红色和绿色也是一样 所以OLED屏幕非常容易发生一个现象就是烧屏，其本质就是屏幕老化不均匀导致的残留 如何减缓烧屏过程 既然OLED烧屏不可避免，作为消费者我们可以做些什么来减缓烧屏现象呢？ 除了定期更换壁纸、调短屏幕自动锁定的时间等手段外，我个人发现了一个更好的方案，能够从根本上解决烧屏的可能性： read more books, read more newspapers, eat less snacks and sleep more 2、OLED屏缺陷：低频PWM调光 低频PWM调光是OLED屏上另一个经常被人诟病的问题，所谓的低频调光说得通俗点就是**“频闪”** 图片来源：https://www.igao7.com/news/201807/oJMDaPCKHbeufGdI.html 眼睛长期暴露在**“频闪”**环境中会造成头痛和眼疲劳、导致视力下降和注意力分散等问题 观看低频的频闪画面还可能会引发光敏性癫痫病，近代最著名的“频闪事故”当属1997年日本电视台的“3D龙事件” 在宝可梦第38话中，为了渲染电脑世界中的战斗，大量使用12Hz的红蓝闪光展示爆炸场面，直接导致日本全国出现了700例癫痫症(650例是儿童) 图片来源：https://www.igao7.com/news/201807/oJMDaPCKHbeufGdI.html 无独有偶，2007年的伦敦2012年宣传预告片、2011年的《暮光之城：破晓》都有过“因色块闪烁，导致观众癫痫发作”的事件 注：不建议读者尝试，笔者在写这篇文章时只是看GIF动图都觉得头晕恶心，无法按捺好奇心的同学身边一定要有人陪同再去观看原片，不开玩笑 PWM是什么？ 回到我们的主角PWM调光。PWM，全称Pulse Width Modulation，翻译过来就是脉冲宽度调制，说到底，就是种把模拟信号调制成脉波的技术，它已经是应用非常广泛的显示器/光源的亮度控制方案 此外，还有我们后面会提到的DC直流调光(LED领域的CCR恒流调光，为方便表示，后续用DC调光代称) 进入主题前我们需要了解什么是**“视觉暂留”**现象： 当人看到一幅画面快速闪过时，这幅画面产生的视觉刺激会在大脑中停留几十到几百毫秒时间，亮度越亮，停留的时间越长，这一特征我们称为“视觉暂留” PWM就是利用人眼的视觉暂停现象来实现亮度调节的，具体原理可以去B站看“硬件茶谈”的《全网最简洁易懂的OLED与LCD屏幕工作原理与优劣科普》这期节目 简单总结一下就是： 在PWM调光屏幕上，调节亮度并不靠改变功率，而是靠屏幕的亮、灭交替显示来改变亮度 屏幕亮度为100%时，自发光二极管一直亮，亮度为80%时，一个PWM周期内亮80%的时间在亮，剩下的20%的时间是灭的，屏幕会不停地点亮、熄灭，当交替速度够快时，肉眼就会认为手机一直在亮 PWM相关参数 这里多出了一个PWM周期的概念，解释一下 使用PWM调光的手机通常都标有调光频率参数，以我手里的Pixel 3举例，调光频率为245HZ 1. PWM频率： 频率是指1秒钟内信号从高电平到低电平再回到高电平的次数(一个周期)，表示单位：HZ 2. PWM周期： 一次脉冲周期的时间，Pixel 3调光频率最高245HZ，换算成一个PWM周期为：1s/245≈4ms 3. 占空比 一次PWM周期中，高电平与整个周期时间的比例。依旧以Pixel 3举例，高电平时间为2ms时，占空比 = 2ms/4ms=50% 从这几个关于PWM的参数可以看出来，调光频率越高，人眼发觉频闪的机会就越小，对眼睛的伤害也就越小 所以手机厂商近些年推出的机型都宣传自己使用高频PWM调光技术，没钱换新手机的同学也不用担心OLED屏幕伤眼，平日使用手机时尽量把亮度调高，让高电平持续的时间变长，同样也可以起到降低**“频闪”**，保护眼睛的效果 注：对自己手机屏幕参数感兴趣的同学可以去这个网站查询：www.notebookcheck.net 如何分辨是DC调光还是PWM调光 讲完了PWM调光，接下来我们介绍一下如何分辨手机是DC调光还是PWM调光 1.1小节介绍了LCD屏幕的结构组成，知道了LCD屏幕背后是一整块的背光模组，所以调整屏幕亮度只需要调整**“背光模组”的亮度即可，这就是“DC调光”** PWM调光则是利用人眼的**“视觉残留”现象，通过调节“占空比”**来控制屏幕的亮度 去应用商店下载一个可以调节快门速度的第三方相机，调高快门速度拍手机屏幕，被拍摄的手机屏幕亮度别太高，调到50%左右 如下图，有条纹的就是**“PWM调光”，没有条纹则是“DC调光”** 我们看到的黑色条纹其实就是PWM周期中低电平的时间，也就是像素点熄灭的时间 二、结语 OLED屏幕烧屏和低频PWM调光都已经介绍完了，目前市面上大多数OLED屏幕使用的都是PWM调光，LCD屏幕则大部分使用DC调光 但我们还是要把屏幕的材质和调光方式区分开来，因为并非所有的OLED屏幕都是PWM调光，同样的，也不是所有的LCD屏幕都是DC调光，例如采用LCD屏幕的荣耀Play使用的就是PWM调光 回到我们的标题，LCD和OLED屏幕该怎么选？ 就我个人经验来看，我是偏向OLED屏幕的，从iPhone X到现在的iPhone 12Pro，OLED的频闪对我没什么影响，反而还挺喜欢OLED屏带来的更高的亮度，至于烧屏，我的主力机还没有遇到过，真正发生的时候大不了换个屏幕 不过人眼对频闪敏感程度不同，的确有些小伙伴使用OLED屏幕后出现眼睛干涩、眼疲劳等问题，这部分人群建议还是使用DC调光的屏幕 在文章的最后，还是建议大家少玩手机，多出去走走，闻一闻路边的野花，见一见想念的人，才能真正的保护眼睛 三、参考资料 CSDN-Z小旋-PWM频率与占空比详解：https://blog.csdn.net/as480133937/article/details/103439546 硬件茶谈-全网最简洁易懂的OLED与LCD屏幕工作原理与优劣科普：https://www.bilibili.com/video/BV1Wz411B7Tf PWM调光科普(上篇)-人类显示器的黑历史：https://www.igao7.com/news/201807/oJMDaPCKHbeufGdI.html 走进自带光芒的有机发光二极管（OLED）材料绚丽多彩世界，领悟前沿的研究进展：http://www.cailiaoniu.com/232822.html 有机发光二极管| 8优点和缺点：https://zh-cn.lambdageeks.com/organic-light-emitting-diodes/ OLED发光原理和OLED面板结构及OLED关键技术深度图文解析 ","link":"https://yibaoshan.github.io/post/android-graphics-first/"},{"title":"Android组件系列：Handler机制详解","content":" 点击跳转到掘金阅读 Overview 每个Android开发者都或多或少的了解过Android Handler机制，为了不浪费大家时间，在文章开始之前，我认为有必要说明一下本文的目标受众 适合人群： 1、Android新手开发，对Handler机制还不是很熟悉，想要了解Handler内部是如何运行的 2、其他客户端开发，比如iOS、Windows开发等，想要了解在Android系统中是如何在非UI线程更新界面的 不适合人群： 1、中高级工程师，对Handler机制了解的很深入了，这篇文章纯属浪费时间 2、觉得源码过于枯燥，想要找一篇文章对照着看，本文可能不是很合适，因为文章中并不会涉及太多的源码 一、前言 Android Handler机制是每个Android开发者成长道路上一道绕不过去的坎，了解Handler机制对于解决开发中的遇到的卡顿检测、ANR监控，以及了解APP组件是如何运行的等问题有着非常大的帮助 市面上已经有许多讲解Handler机制的文章，各种角度的都有，其中不乏有不少深度好文；本文不讲解源码(主要是讲不过其他文章)，从Android Handler机制的设计思想开始讲起，由浅入深，带你一步步走进Handler内部的实现原理 以下，enjoy： 二、Handler设计背景 在Android开发者官网对View的介绍有这样一句话： 图片来源：Android Developer 整个视图树是单线程的， 在任何视图上调用任何方法时，必须始终在 UI 线程上。如果在其他线程上工作并希望从该线程更新视图的状态，则应该使用Handler 不只是Android，在iOS开发者官网对UIKit介绍中同样有类似提示： 图片来源：Apple iOS Developer 除非另有说明，否则只能从应用程序的主线程或主调度队列中使用 UIKit 类。 此限制特别适用于从 UIResponder 派生的类或涉及以任何方式操作应用程序用户界面的类。 奇了怪了，Android和iOS作为一个有图形用户界面(Graphical User InterfaceI)的操作系统，为什么都要求在主线程(UI线程)操作页面？ 1、GUI为什么要设计成单线程？ 关于GUI为什么要设计成单线程这个问题，前Sun的副总裁Graham Hamilton在设计Java Swing时，曾经写过一篇文章专门聊过：Multithreaded toolkits: A failed dream? 最近有人提出一个问题，“我们是否应该让 Swing 库真正实现多线程？” 我个人觉得不应该，下面阐述理由。 无法实现的梦想（Failed Dream） 借用 Vernor Vinge 的术语，在计算机科学中，某些想法是“无法实现的梦想”。这种想法初步看来很好，人们隔一段时间就会重新冒出这种想法，并为此花费很多时间。通常在研究阶段，事情进展顺利，有一些让人感兴趣的成果，差不多可以应用到生产规模上了。只是总有些问题解决不了，解决了这边的问题，那边又有问题冒出来。 在我看来，多线程的 GUI 工具包，就是这种无法实现的梦想。在多线程环境中，任意一个线程都可以去更新按钮(Button)、文本字段(Text Field)等 GUI 状态，这似乎是理所当然、直截了当的做法。任意线程去更新 GUI 状态，无非是加一些锁，又有什么难的呢？实现过程中可能会有一些错误，但我们可以修复这些错误，对吧？可惜事实证明没有这样简单。 多线程的 GUI 有种不可思议的趋势，会不断发生死锁或者竞争条件。我第一次知道这趋势，是在 80 年代初期，从 Xerox PARC 的 Cedar GUI 库中工作的那些人中听来的。这批人都十分聪明，也真正了解多线程编程。他们的 GUI 代码时不时就有死锁问题，这件事本身就很有趣。单独这事不能说明什么，或者只是特殊情况。 只是这些年来不断重复这一模式。人们最开始采用多线程，慢慢地，他们转换到了事件队列模型。“最好让事件线程做 GUI 的工作。&quot; ...略 为什么这么难 我们使用抽象来编写代码，很自然地会在每个抽象层中单独上锁。于是很不幸地，我们就遇到经典的锁定顺序噩梦：有两种不同类型的活动，按照相反的顺序，试图获取锁。因而死锁不可避免。 ...略 来自：Multithreaded toolkits: A failed dream?，原网页已经404，查看原文可以点击下面两个链接 CSDN原文备份 知乎翻译：多线程 GUI 工具包：无法实现的梦想？ 简单来说，多线程操作一个UI，很容易导致，或者极其容易导致反向加锁和死锁问题 我们通过用户级的代码去改变界面，如TextView.setText走的是个自顶向下的流程： 图片来源：GUI为什么不设计为多线程 而系统底层发起的如键盘事件、点击事件走的是个自底向上的流程： 图片来源：GUI为什么不设计为多线程 这样就麻烦了，因为为了避免死锁，每个流程都要走一样的加锁顺序，而GUI中的这两个流程却是完全相反的，如果每一层都有一个锁的话加锁就是个难以完成的任务了，而如果每一层都共用一个锁的话，那就跟单线程没区别了。 综上，目前主流的带有用户界面(GUI)的操作系统，除了DOS外，几乎都是使用UI单线程模型的方案，即消息队列机制 2、什么是消息队列机制？ 提到消息队列，自然而然就会想到生产者-消费者模式，在《从Android源码角度谈设计模式（三）：行为型模式》一文中我们已经介绍过了生产者-消费者模式，还没有看过的同学可以先看完再回来，这里来简单回顾一下： 在一个生产者-消费者模式中，通常会有三个角色 消息队列(single) 负责保存消息，提供存取消息的功能 生产者(multiple) 负责生产消息，塞到共享的消息队列中 消费者(multiple) 负责从共享消息队列中取出消息，执行消息对应的任务 这三个角色中，因为生产者和消费者要从同一个消息队列取放消息，所以消息队列的数量要求是唯一的，生产者和消费者的数量可以任意 我们回到Android系统，GUI框架多数使用单线程设计，那么就要求所有的UI操作都只能发生在一个线程当中，即： 消费者线程只有一个，且消费者线程就是UI线程 到了这里，关于消息队列机制应该有个清晰的概念了，我们来总结一下： Android、Swing、iOS等的GUI库都使用消息队列机制来处理绘制界面、事件响应等消息 在这种设计中，每个待处理的任务都被封装成一个消息添加到消息队列里 消息队列是线程安全的（消息队列自己通过加锁等机制保证消息不会在多线程竞争中丢失），任何线程都可以添加消息到这个队列中 但是，只有主线程（UI线程）从中取出消息，并执行消息的响应函数，这就保证了只有主线程才去执行这些操作 小节完 3、Android中的消息队列：Handler 前两小节我们介绍了Android系统中为什么只能在UI线程更新界面的原因，最终发现不只是Android系统，其他大部分有GUI框架的操作系统都是采用单线程消息队列机制的设计。既然都是单线程设计，那么想要在子线程更新UI就必须要通知主线程 在Android系统中，Handler就是这么一套提供在任意线程都可以发消息给UI线程的线程间通信工具 从图中可以看到，Handler相当于消息的生产者，每个Handler都持有共享MessageQueue的引用 当调用Handler.sendMessage()方法发送消息时，Handler就会把消息保存到共享消息队列中 和普通消息队列机制不同的时，Android中的MessageQueue大小没有阈值上限，所以理论上可以一直发消息到队列，把内存撑爆~ 在Handler机制中，消息的消费者是Looper，严谨点是调用Looper.loop()所在的线程，因为Looper本质上只是封装对消息队列的操作，Looper.loop()方法负责取出共享消息队列里面的消息，然后交由Handler去执行 这里又有一点和普通消息队列机制不同，通常消息的消费者会去执行消息的响应函数；但在Android Handler机制中，消费者本身并不执行消息任务，而是将消息取出后，再重新分发给消息的发送者执行，也就是Handler，所以我们平时才说 在整个Handler的机制中，Handler首先是消息的生产者，其次才是消息的执行者 除了发消息外，Android还为Handler增加了一些其他功能，比如子线程提交同步任务、异步消息和同步屏障等等 本小节的目的是了解Handler的设计背景，关于Handler其他功能这里就不展开介绍，在Handler系列的下一篇文章中会详细剖析Handler内部源码 小结完 三、如何自己实现一套Handler机制？ 在上一章节中，我们介绍了Handler的设计背景，本章节将会尝试自己实现一套简单的Handler机制 我们假设读者已经有一定的开发经验，并且使用过Handler，那么接下来就是枯燥的代码时间 1、Handler成员介绍 在开撸之前，按照惯例，我们先来介绍一下组成Handler机制的几位成员，以及它们常用的方法 1.1 Handler类 Handler类是应用程序开发的入口，在消息队列机制中，扮演着生产者的角色，同时还肩负着消息执行者的重担，常用的方法有： 方法名称 说明 sendMessage()系列 发送普通消息、延迟消息，最终调用queue.enqueueMessage()方法将消息存入消息队列 post()系列 提交普通/延迟Runnable，随后封装成Message，调用sendMessage()存入消息队列 dispatchMessage(Message msg) 分发消息，优先执行msg.callback(也就是runnable)，其次mCallback.handleMessage()，最后handleMessage() 1.2 Looper类 Looper在消息队列机制中扮演消费者的角色，内部持有共享的消息队列，其本质是封装对消息队列的操作，常用的方法只有两个： 方法名称 说明 prepare() 创建消息队列 loop() 遍历消息队列，不停地从消息队列中取消息，消息队列为空则等待 1.3 MessageQueue类 实际的共享消息队列，提供保存和取出消息的功能，底层由链表实现，常用方法就一个： 方法名称 说明 next() 获取消息，三种情况 1. 有消息，且消息到期可以执行，返回消息 2. 有消息，消息未到期，进入限时等待状态 3. 没有消息，进入无限期等待状态，直到被唤醒 1.4 Message类 消息的承载类，使用享元模式设计，根据API不同缓冲池大小也不同，API 4时缓冲池大小为10，常用方法： 方法名称 说明 obtain()系列 获取一个消息实例 recycle() 回收消息实例 1.5 小结 至此，Handler的几个主要成员类都介绍完了，有同学可能已经发现了，成员介绍中没有包含ThreadLocal类？ 我个人认为ThreadLocal是属于Java并发模块的内容，Handler只是借用了ThreadLocal来保证MessageQueue在当前线程线程的唯一性，就算不适用ThreadLocal对整个Handler机制也没啥影响~ 小节完 2、基于Object.wait()/notifiy()实现Handler机制 3.1小节介绍了Handler的几个成员类，以及成员类中常用的方法，本章节将会用Java同步机制来实现Handler 话不多说，直接开撸 2.1 手写消息队列机制 前面的章节我们已经了解过消息队列机制的概念，这里直接来看代码 首先我们来创建一个生产者，生产者线程中，我们写了个死循环一直发送消息，来模拟用户操作；每次发完消息后，唤醒可能在等待状态的消费者线程，然后将自己个儿置入限时等待状态 然后再创建一个消费者，在消费者线程中，同样是死循环，不停的轮询消息队列，有消息就处理，没消息就将自己置入无限期等待的状态，直到被唤醒 接着就是共享的消息队列了，偷个懒，消息队列就使用的是Java集合包中的Queue好了，来看最终的测试代码： 打印结果： 在测试代码中，两个boss张三和李四时不时发指令给下属，两个下属小明和小红在不停的轮询等待上司的指令，一个简单的消息队列机制就完成了；在不考虑延迟消息的情况下，加上测试代码，整个消息队列机制不到100行代码就搞定了，还是比较简单的 2.2 手写Handler机制 2.1小节我们已经用Object.wait()/notifiy()实现了消息队列，实现Handler机制只需要在上面的消息队列的基础上稍微改动一下就能完成： 同学们注意，我要开始变形了！！！ 第一步，我们把消费者线程中的逻辑挪到Looper当中，把轮询的任务放到loop()方法中；若取到了消息，模拟Android Handler机制，将消息分发给消息所属的生产者者(Handler)去执行 接着，将消费者线程中获取消息的逻辑抽离出来，放到MessageQueue的next()方法中 和上面的消费者线程比较，这里加了一条逻辑：当发送的消息时延迟消息时，判断消息是否到期，到期返回给Looper去分发(这里偷懒使用了Java集合包中的优先级队列PriorityQueue，来保证时间最小的消息排在最前面) 然后，把生产者线程中直接将消息存入消息队列的操作的逻辑也抽出来，放到Handler的sendMessage()方法中 再然后，来看一眼Message类的设计，加了个Handle类型的成员变量target 好！大功告成，一起看看测试代码： 在main()方法中创建了handler1和handler2，模拟用户在主线程申请Handler的场景；随后开启俩子线程，让子线程代码使用刚刚创建的Handler发送消息，这样，子线程使用该Handler发送的消息就会添加到主线程的消息队列，等待主线程的Looper去处理 打印结果： 看，如果是普通任务，loop()方法里面就直接分发掉了，延迟任务因为使用的是PriorityQueue的缘故，会排到最后才放出来 到这里一个简单的Handler机制就完成了，没看懂的同学请在评论区扣1 关于此小节设计到的代码在这里 ps：把代码转图片是因为源码太长了我知道你们也懒得看~ 2.3 小结 前两小节分别介绍了如何手写消息队列机制和手写一个简单的Handler机制，我将上面的代码调用流程梳理了一下，总结出一张简版的流程图： 图中的每个成员类都只写了两个关键方法，Message类只是消息载体，所以就没放它，我觉得介绍Handler大致流程差不多这几个方法够了，觉得流程不够详细的同学可以下载源文件自行添加，流程图源文件已上传到GitHub 小节完 四、Handler机制详解 此小节设计之初的想法是要详细的剖析Handler机的内部源码，在写完了二、三章节后回头看才发现 除了同步屏障与异步消息、IdleHandler、Callback等没有讲以外，整个Handler机制好像已经讲的差不多了-.- 既然没太多可讲的，那本节索性换个目标，来聊一聊Android Handler除了实现消息队列机制外，还给我们提供了什么功能，它们是如何实现的，以及在使用Handler过程中我们有哪些需要特别注意的地方 1、除了提交消息到队列，Handler还提供了哪些功能？ 1.1 IdleHandler IdleHandler是在Handler机制诞生之初就实现的机制，其存在的意义在于，提交一个不重要的任务单独存放在MessageQueu中的mIdleHandlers变量中，当消息队列空闲时会执行此任务 /** * Callback interface for discovering when a thread is going to block * waiting for more messages. */ public static interface IdleHandler { /** * Called when the message queue has run out of messages and will now * wait for more. Return true to keep your idle handler active, false * to have it removed. This may be called if there are still messages * pending in the queue, but they are all scheduled to be dispatched * after the current time. */ boolean queueIdle(); } IdleHandler要求返回bool类型的值，返回false表示执行完该任务后会把它从集合中删除，返回true表示该任务可以重复执行 IdleHandler的处理逻辑在MessageQueue.next()方法中，我们来看一下Android 1.6版本中的处理逻辑： // There was no message so we are going to wait... but first, // if there are any idle handlers let them know. boolean didIdle = false; if (idlers != null) { for (Object idler : idlers) { boolean keep = false; try { didIdle = true; keep = ((IdleHandler)idler).queueIdle(); } catch (Throwable t) { } if (!keep) {//处理结果为false将其从集合中删除 synchronized (this) { mIdleHandlers.remove(idler); } } } } IdleHandler使用方法大家都已经很熟悉了，关注比较多的问题是：在什么场景下使用？ 这里举几个三方库和官方使用IdleHandler的例子，看看能不能从他们身上得到些启发 ActivityThread.GcIdler 直接看代码 final class GcIdler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { doGcIfNeeded(); return false; } } void doGcIfNeeded() { mGcIdlerScheduled = false; final long now = SystemClock.uptimeMillis(); //获取上次GC的时间 if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) &lt; now) { //Slog.i(TAG, &quot;**** WE DO, WE DO WANT TO GC!&quot;); BinderInternal.forceGc(&quot;bg&quot;); } } doGcIfNeeded方法理解起来很简单，就是获取上次GC的时间，判断是否需要GC操作 微信性能监控框架：Matrix Matrix有好几处使用到IdleHandler的地方，比如： IdleHandlerLagTracer.java WarmUpScheduler.java AndroidHeapDumper.java LooperMonitor.java 以LooperMoitor举例来说，这是监听Looper消息分发的类，微信这里利用IdlerHandler做了一个检查的工作 @Override public boolean queueIdle() { if (SystemClock.uptimeMillis() - lastCheckPrinterTime &gt;= CHECK_TIME) { resetPrinter(); lastCheckPrinterTime = SystemClock.uptimeMillis(); } return true; } 我们看到在queueIdle方法中返回了true，说明这个IdleHandler会被重复调用，每次调用queueIdle()方法时，会去调用resetPrinter方法来检查Looper中的printer对象是不是微信自定义的LooperPrinter 内存泄漏检测框架：LeakCanary LeakCanary在ReferenceCleaner中用到了IdleHandler，源码看起来是在onViewDetachedFromWindow()函数中注册了IdleaHandler，注册这个IdleHandler的目的是为了清除Android ims的bug，感兴趣的同学可以自己点进去看 1.2 异步消息与同步屏障 Android在API 16(4.1.1)增加了对异步消息和同步屏障消息的支持 所谓的同步屏障机制就是插入一个同步屏障消息到Looper的队列头部，准确的说是拆入一个当前时间的消息到队列，如果队列中有消息到期了但是还没执行，那么该同步屏障的消息会排在它后面；当Looper调用next()获取消息时候，发现队列头部是一个同步屏障信息，就会跳过所有同步消息，寻找所有的异步消息执行，所以异步消息机制实质上是一个对消息队列的优先级重新排列的机制 ps：关于异步消息与同步屏障在Handler、MessageQueue、Looper中处理逻辑这里没讲，全部加进来太长了，感兴趣的同学可以去网上找其他文章 1.3 Handler Callback机制 简单来说，就是Handler在分发消息时，提供了消息分发优先级的选项给使用者，我们来看一下消息的分发逻辑： /** * Handle system messages here. */ public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 优先执行msg.callback(也就是runnable)，其次mCallback.handleMessage()，若callback返回false，最后执行handleMessage()方法 2、使用Handler的注意事项 2.1 内存泄漏 Handler引发的内存泄漏是老生常谈的话题，追根溯源的话其实和Handler本身没关系，其本质是生命周期长的组件引用生命周期短的组件，导致声明周期短的组件明明已经结束了，实例对象却不能被回收 在Activity中直接创建Handler，因为是内部类的关系，该Handler会持有Activity的引用，若使用该Handler发送延时消息后销毁Activity会发现，在延时消息未执行前，Activity包括其引用的对象都不会被释放的 解决方案也比较简单，声明一个静态内部类即可，代码如下： public static class InternalHandler extends Handler { private WeakReference&lt;Context&gt; contextReference; public InternalHandler(WeakReference&lt;Context&gt; contextReference) { this.contextReference = contextReference; } } 2.2 享元模式的坑 Handler中的Message类使用享元模式设计，在《从Android源码角度谈设计模式（二）：结构型模式》一文中已经解释了享元模式本身会带来数据不一致的问题 简单来说，当你将一个享元对象传递给子线程，因为Java是值传递，所以当子线程使用到传递进来的享元对象时，这个对象可能正在回收池中，也可能已经被取出供其他方法使用 体现在Handler机制中则是，Looper.loop()执行完消息的分发后，会调用msg.recycle()将该消息实例对象回收，这时候就会有个问题，来看代码： public static class InternalHandler extends Handler{ @Override public void handleMessage(Message msg) { if (msg.what == 250){ //新建异步线程处理逻辑 new Thread(() -&gt; { Thread.sleep(100*1000);//模拟耗时 System.out.println(msg.obj);//模拟消息使用 }).start(); } } } 如上，我们在拿到msg后，新起了一个线程去处理消息 来看Looper这边的逻辑，loop()方法里面调用完msg.target.dispatchMessage()方法后紧接着就会回收消息对象实例 那么我们在子线程中拿到的对象引用，里面内容的实际是空的，或者是该对象引用又已经被其他线程在使用了，总之，在子线程中的消息不是原来的消息了 3、Handler有哪些妙用 3.1 永不崩溃的APP 1. 使用方法 利用Handler机制拦截异常前两年在网上还小火了一把，笔者刚知道Handler还可以这样用的时候很开心，不会因为未捕获异常导致APP崩溃了，我的绩效有救了~ 当然，说永不崩溃言过其实了，它只能拦截Java层异常，native异常是没办法捕获的，接下来我们来了解一下如何实现的 首先，先来看一下使用的方法，很简单，我们在Application随便找个方法加入以下代码： new Handler(Looper.getMainLooper()).post(() -&gt; { while (true) { try { Looper.loop(); } catch (Exception e) { //保存日志并上报.. } // }catch (Throwable throwable){ }//想要连Error(如OOM)都一起拦截就用Throwable } }); 如上，只需短短几行代码，就可以捕获Java层所有异常，怎么做到的？ 2. 实现原理 在介绍实现原理之前，我们先来复习一下Java异常处理机制，当一个异常发生时： 虚拟机会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理 如果当前方法异常表不为空，并且异常符合处理者的 from 和 to 节点，并且 type 也匹配，则虚拟机调用位于 target的调用者来处理 如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目 如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作 如果所有的栈帧被弹出，仍然没有处理，则抛给当前的 Thread，Thread 则会终止 如果当前 Thread 为最后一个非守护线程，且未处理异常，则会导致虚拟机终止运行 Exception table: from to target type 0 3 6 Class java/lang/Exception 我们来做个实验，在Activity主动抛出一个异常，看一下方法调用链，重点关注有没有可以手动try catch的地方 java.lang.RuntimeException: 我崩溃了 at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3639) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3796) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:103) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2214) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loopOnce(Looper.java:201)//point 2 at android.os.Looper.loop(Looper.java:288)//point 1 at android.app.ActivityThread.main(ActivityThread.java:7842) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1003) Caused by: java.lang.RuntimeException: 我崩溃了 从下往上找，最下面几个，什么ZygoteInit、RuntimeInit这些系统的类听起来就没法操作 直到看到point 1位置的Looper.loop()方法，回顾一下第三章2.3小节中流程图，loop()方法里面执行的是死循环，一直在轮询消息队列 那么我们再丢一个同样执行死循环，并且调用Looper.loop()方法轮询消息队列的消息进去，只要保证提交的这个消息不出错，就永远不会出现上面的异常堆栈信息 并且，由于我在消息中调用了Looper.loop()方法，相当于dispatch消息的代码执行在我提交的这个消息中，也就是说只要try catch住调用loop()的地方，在应用内任务Java异常我都可以捕获了 好了，大概的实现原理已经解释清楚了，接下来看一下在msg中重复调用Looper.loop()方法后的方法栈调用链： //原先的方法调用链 ZygoteInit.main() -&gt; RuntimeInit.MethodAndArgsCaller.run() -&gt; ActivityThread.main() -&gt; Looper.loop() -&gt; MessageQueue.next() //再次调用Looper.loop()方法后，调用链变成： ZygoteInit.main() -&gt; RuntimeInit.MethodAndArgsCaller.run() -&gt; Activity.main() -&gt; LooperThread.loop() { //因为是同一个线程内调用，相当于在Looper.loop方法上包了一层 -&gt; Looper.loop() -&gt; MessageQueue.next() } 3. 小结 本小节介绍了让Java代码永不崩溃的实现原理，这套方案看起来比较牛逼，但是 不建议在生产环境中使用！！！ 在我刚知道这套方案时，立马就在项目中进行了测试，测试结果和介绍的效果是一样的，当时真的觉得很牛逼，于是便兴高采烈的发到生产环境 发版没几天就陆续收到反馈，页面白屏没数据、点击没反应等等问题 后来查看上报日志，发现出问题的页面的确存在bug，但是因为被拦截了导致了功能不能正常执行，才会导致用户操作没反应等 简单来说，若某个生产数据的功能无法正常使用后，接下来依赖该数据的页面都会产生一系列的问题 这反而会让应用中产生更多的不可控因素 最后经过内部讨论后还是把这套方案放弃了，不能用这种蛮横的方式对待bug 一刀切的方案过于野蛮，GitHub有个开源库提供了更完善的解决方案，https://github.com/android-notes/Cockroach 小结完 3.2 ANR监控 详情可参考微信客户端技术团队的文章： 微信Android客户端的ANR监控方案 微信Android客户端的卡顿监控方案 五、Handler发展历程 在文章的最后，我们来认识一下Handler的发展历史 下面的表格记录了Handler从Android 1.6 (API 3) 一直到Android 12 (API 31)的演变过程： Android 1.6(API 4) 这也许是你能找到最老版本的Handler源码，此时Handler的完成度已经很高了，特点是： 1、队列空闲时等待以及唤醒方案用的是Java的Object.wait()/notfity() 调用MessageQueue的next方法获取消息，这时候检查队列有没有消息 没有消息调用this.wait()无限期等待 有消息但消息未到期调用this.wait()传入到期时间 调用MessageQueue.enqueueMessage()添加消息，消息加入队列后会调用this.notifity()唤醒next()方法，这里有个bug是没有判断添加的消息要什么时候执行，延迟消息也会唤醒 2、MessageQueue支持IdleHandler IdleHandler是MessageQueue的内部类，调用addIdleHandler(handler)方法将一个IdleHandler添加到mIdleHandlers集合中，消息队列空闲时才会执行 3、不支持异步消息和同步屏障消息 所有消息一视同仁，这也是早期Android设备体验不好的原因之一 4、Handler支持Callback回调 提到这个方法是因为它比较重要，先来看一下消息分发的先后顺序： 优先执行msg.callback(也就是runnable)，其次mCallback.handleMessage()，最后handleMessage() 其中，调用mCallback.handleMessage()方法时会要求返回bool类型的值，这个值为true就不会向下分发给Handler的handleMessage()方法，为false会继续向下分发 知道了分发逻辑之后我们就可以hook掉ActivityThread中的H类，传入callback拦截我们想要的信息，进而做组件化或监控方面的工作 Android 2.3(API 9) 2.3比较大的变化是增加了native层的Handler消息机制 1、MessageQueue支持处理native层消息 MessageQueue通过mPtr变量保存NativeMessageQueue对象，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息 关于native层的Handler想要了解更多的同学看这里： 袁辉辉老师的文章：Android消息机制2-Handler(Native层) native的MessageQueue源码：android-2.3_r1/core/jni/android_os_MessageQueue 2、MessageQueue.next()方法中，空闲时等待方案从Object.wait()改为nativePollOnce()实现 由于加入native层Handler，队列空闲时不能只判断Java层的MessageQueue，MessageQueue将原先的this.wait()方法改成了调用native的nativePollOnce()方法，若大家都空闲，方法会阻塞到native的epoll_wait()方法中，等待唤醒 3、MessageQueue.enqueueMessage()方法中，唤醒方案从Object.notify()改为nativeWake()实现 参考上一小节，这里还有个小细节，Android 2.3之前只要调用enqueueMessage()方法就会调用this.notify()唤醒线程，哪怕加入的这个消息是个延迟消息要求一万年后才执行，在2.3的版本中的enqueueMessage()方法中修复了这个问题 Android 4.0(API 14) 1、Message增加flags属性，用于标识该消息是否已经消费过了，防止同一消息无限次提交 调用isInUse()方法可以查询当前消息是否使用过，这个flags后续也还会加入更多的含义 Android 4.1.1(API 16) 4.1.1版本变化略微大一些，主要是增加了对异步消息和同步屏障消息的支持 1、Message支持设置为异步消息，@hide修饰 调用setAsynchronous(true)方法可以将Message设置为异步消息，判断是否为异步消息的标识保存在Message的成员变量flags中 2、MessageQueue支持处理异步消息 主要是在enqueueMessage()方法和next()方法中增加异步消息的处理逻辑 3、MessageQueue支持添加/删除同步屏障消息 对应方法为：enqueueSyncBarrier()和removeSyncBarrier() 在MessageQueue的next()方法中也增加了对同步屏障消息的处理逻辑 4、MessageQueue支持quit()方法 4.1.1版本的退出逻辑是将MessageQueue的成员变量mQuiting设置为true，在调用MessageQueue.next()方法时检查mQuiting变量值，为true则返回null给Lopper，Looper.loop()方法中判断时null值直接结束当前循环 注意这里并不会清空MessageQueue中的消息，也就是说若消息持有外部的强引用，那么会造成内存泄漏 5、Lopper删除成员变量mRun 这货本来就没啥用~，早期打印msg执行日志的时候会带上它 Android 4.2 (API 17) 1、Handler支持设置为异步Handler，@hide修饰 如下，新增Handler(boolean async)构造函数，使用该Handler发送的消息均为异步消息 public Handler(boolean async) { mAsynchronous = async; } 2、Handler支持子线程提交同步任务，新增runWithScissors()方法，@hide修饰 runWithScissors()方法接受一个Runnable和超时时间，调用此方法提交一个任务后： 1、若消息发送线程和Handler创建线程是同一线程，那么执行Runnable的run方法 2、若消息发送线程和Handler创建线程不在同一线程，可以理解为子线程向主线程提交了一个任务，任务提交后，子线程会进入休眠状态等待唤醒，一直等到任务执行结束 注意！！！该方法不但被@hide修饰，在代码注释也向开发者告知这是个危险方法，不建议使用，因为runWithScissors()方法有两个严重缺陷： 1、无法取消已提交的任务，即使消息的发送线程已经死亡，主线程仍然会取出消息队列的任务执行，但这时候运行的程序是不符合我们的预期的 2、可能会造成死锁：子线程向主线程(创建Handler的线程)提交了延迟任务后，子线程是处于等待被唤醒的状态，此时若主线程退出了loop循环并清空了消息队列，那子线程提交的任务就永远不会被唤醒执行，该任务持有的锁永远不会被释放，造成死锁 Android 4.3 (API 18) 1、MessageQueue支持安全退出，quit(safe)方法 新增以下两个方法，safe参数为true时调用removeAllFutureMessagesLocked() removeAllMessagesLocked() ：清空所有消息 removeAllFutureMessagesLocked()：清空延迟消息，到期消息交给Handler分发 Android 6.0 (API 23) 1、MessageQueue支持监听文件描述符，对应方法：addOnFileDescriptorEventListener() 这部分代码我没懂，目前的知识储备不足以让我看懂~ /哭唧唧.jpg 2、MessageQueue发送同步屏障消息方法改名，从enqueueSyncBarrier()改为postSyncBarrier() 我很认真的确认过，主要逻辑没动过，真的只是改个名 Android 8.0 (API 26) 1、Handler增加getMain()方法，用于获取运行在UI线程的Handler实例，@hide修饰 getMain()检查成员变量MAIN_THREAD_HANDLER是否已经保存了Handler实例，若MAIN_THREAD_HANDLER为空，则使用Looper.getManLooper()创建一个新的Hnadler实例，赋值给MAIN_THREAD_HANDLER变量，最后返回结果 注意，该方法只是返回一个运行在UI线程的Handler，并不是ActivityThread中的成员变量mH！！！ Android 9.0 (API 28) 1、Handler增加executeOrSendMessage()方法，@hide修饰 这个方法比较简单，提供的功能和字面意思相同 判断消息发送线程和消息消费线程是同一线程，是的话调用Handler.dispatchMessage()方法分发消息，否则塞进消息队列等待被分发 2、Handler允许APP创建异步Handler 增加了静态方法createAsync()，调用该方法会返回一个Handler实例，这个Handler实例就是异步Handler Android 10.0 (API 29) 1、Looper增加setObserver(observer)方法，监听消息分发过程，@hide修饰 一共有3个方法 Object messageDispatchStarting()：发送消息前调用 messageDispatched(token, msg)：当消息被 Handler 处理时调用 dispatchingThrewException(token, msg, exception)：在处理消息时抛出异常时调用 至此，Handler历代更新的内容都已梳理完成，每个方法都进行了标注，标题中也加入了链接，有阅读源码需求的同学可以点击查看 ps：个人整理难免会有疏漏，欢迎在留言区补充 六、总结 本文将Handler机制拆成了三个部分 第一部分是介绍Handler诞生的背景，Android为什么要设计出Handler 第二部分主要讲如何手写一套Handler机制，使用的是Java同步方法Object.wait()/notifiy() 第三部分介绍的是Handler除了实现消息队列外，还提供了哪些功能？以及开发中使用Handler有哪些需要注意的地方 希望每位同学在看完本篇文章后都能够有所收获 -.- 全文完 七、参考资料 CSDN-liuqiaoyu080512：GUI为什么不设计为多线程 ","link":"https://yibaoshan.github.io/post/android-components-handler/"},{"title":"Android组件系列：LocalBroadcastManager源码解析","content":" 点击跳转到掘金阅读 Overview 一、LocalBroadcastManager介绍 1、LocalBroadcastManager是什么 在Android中，Broadcast是一种广泛运用的在应用之间传输信息的方式 Broadcast本身是进程间通信，发送的消息其他APP可以监听，同时其他应用也可以通过不断的发送广播来攻击你的APP，应用的安全性无法保证 为了解决这个问题，LocalBroadcastManager就应运而生了 LocalBroadcastManager是Android X库中提供的工具包，和Broadcast相比较，它的优点在于： 1、无需进行进程间通信，效率更高 2、只在应用内传播，无需考虑其他应用在收发我的广播时带来的任何安全问题 综上，如果只是想在应用内通信，那么可以选择本地广播作为应用的事件总线 2、LocalBroadcastManager使用方式 LocalBroadcastManager对象的创建 LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance( context ) ; 注册广播接收器 LocalBroadcastManager.registerReceiver( broadcastReceiver , intentFilter ); 发送广播 LocalBroadcastManager.sendBroadcast( intent ) ; 发送同步广播 LocalBroadcastManager.sendBroadcastSync ( intent ) ; 取消注册广播接收器 LocalBroadcastManager.unregisterReceiver( broadcastReceiver ); 二、LocalBroadcastManager源码解析 LocalBroadcastManager是基于发布/订阅模式来设计的，LocalBroadcastManager本身是发布订阅中心，提供订阅、取消订阅、发布消息的功能，后续的文章中提到的订阅者即表示的是广播接收器，消息事件指的是过滤器的Action 在开始阅读LocalBroadcastManager源码之前，让我们先来认识一下LocalBroadcastManager的成员属性，理解各个成员属性的含义，对接下来源码的阅读会有非常大的帮助 1、LocalBroadcastManager成员属性 1. LocalBroadcastManager的成员变量 类型 名称 说明 Context mAppContext Application的Context HashMapBroadcastReceiver, ArrayList&gt; mReceivers 广播接收者/订阅者集合 HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions 订阅事件集合 ArrayList mPendingBroadcasts 待执行分发事件的集合 Handler mHandler 使用MainLoop创建的Handler int MSG_EXEC_PENDING_BROADCASTS Message的标识 在以上的成员变量中，我们需要重点关注的是mReceivers和mActions 1.1 mReceivers 上一节我们介绍了LocalBroadcastManager是基于发布/订阅模式设计的，事件发生时需要通知所有的订阅者，那么这里必然有一个保存所有订阅者的集合，在LocalBroadcastManager中这个集合就是mReceivers 到这里事情本该结束了，但当我们尝试发送一个事件时就会发现：一个订阅者可以订阅多个事件(Action)，不同的订阅者也可以订阅同一个事件(Action)。 当一个事件发生后，每次都要先去遍历订阅者集合(mReceivers)，再从每个订阅者订阅的事件集合(actions)中匹配是否订阅了正在发生的事件，伪代码： public void sendBroadcast(Intent intent){ //遍历订阅者集合 for(Receiver receiver :mReceivers){ //遍历订阅者订阅的事件集合 for(Action action : receiver.actions){ if(intent.action == action){ //do something } } } } 显然，这样做的时间效率并不高，为了解决这个问题，LocalBroadcastManager新增了一个事件集合：mActions 1.2 mActions 在LocalBroadcastManager中，mActions表示的就是事件集合；其中，事件Action作为集合的key，对应的value是订阅这个事件的订阅者们，这样，每次发送事件时，只需要去事件集合查找对应的订阅者们，通知它们即可，订阅者和事件(Action)的关系如下图： 2. 内部类：ReceiverRecord 类型 名称 说明 IntentFilter filter 广播接收的过滤器 BroadcastReceiver receiver 广播接收者 boolean broadcasting 无意义标识 boolean dead 描述订阅者状态，这个广播接收器是不是解除注册了 ReceiverRecord是LocalBroadcastManager的内部类，存在的意义是包装广播接收器，给广播接收器增加一些属性 3. 内部类：BroadcastRecord 类型 名称 说明 Intent intent 发送的广播 ArrayList receivers 已经匹配上的广播接收者集合 BroadcastRecord中记录的是待分发的订阅者元素 2、LocalBroadcastManager成员方法 在2.1小节中我们把LocalBroadcastManager的成员属性都介绍完了，这里再唠叨一下，重点关注mReceivers和mActions这两个集合，广播的注册和解除注册都是操作这俩集合 在2.2小节中，我们将会介绍LocalBroadcastManager的各个成员方法的功能以及如何实现的，LocalBroadcastManager方法数量不多，算上构造函数一共也才7个，接下来我们就先从构造函数开始讲起： 1. 构造方法 private LocalBroadcastManager(Context context) { mAppContext = context; mHandler = new Handler(context.getMainLooper()) { @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_EXEC_PENDING_BROADCASTS: executePendingBroadcasts(); break; default: super.handleMessage(msg); } } }; } LocalBroadcastManager被设计成全局单例，所以它的构造函数是private修饰的，在LocalBroadcastManager的构造函数中一共做了两件事： 保存Context，注意这里保存的是Application的上下文，接下来的getInstance方法介绍里也会提到这一点 创建Handler 注意看创建Handler的时候使用的是MainLooper，也就是说将来通过这个Handler提交的消息都会添加到主消息队列，然后再由MainLooper分发给当前Handler，那么在executePendingBroadcasts中派发消息的时候，里面的代码都是运行在Main线程了 Handler里面的逻辑也比较简单，接收到Message后调用executePendingBroadcasts()方法来分发消息，由于使用了MainLooper，所以在广播接收器BroadcastReceiver的onReceive函数中，是可以进行UI操作的，比如这样： new Thread(() -&gt; { LocalBroadcastManager.getInstance(null).registerReceiver(new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { //执行UI操作 } },new IntentFilter()); }).start(); 示例代码中在子线程中注册了一个广播接收器，在里面做执行UI的操作是完全没问题的，因为onReceive()方法最终运行在Main线程 2. getInstance()：获取实例 public static LocalBroadcastManager getInstance(@NonNull Context context) { synchronized (mLock) { if (mInstance == null) { //使用Application的上下文创建实例 mInstance = new LocalBroadcastManager(context.getApplicationContext()); } return mInstance; } } getInstance()方法只做一件事：检查mInstance实例是否为空，为空的话创建一个新的对象赋值给mInstance 这里调用context的getApplicationContext()方法，获取的是Application的上下文，这样就不用担心传入生命周期短的组件造成内存泄漏的问题了 我们细看这段代码会发现，LocalBroadcastManager只要初始化过一次之后，再次传进来的context其实是没有用到的 这时候你可能会想：既然用不到，那我是不是可以在应用创建之初调用LocalBroadcastManager.getInstance()方法初始化实例，之后在其他的地方使用时不传context呢？ 答案是当然可以，一旦创建LocalBroadcastManager实例后，我们可以在任意线程调用getInstance()且不传入context来获取实例发送广播啥的 如果你使用Kotlin语言开发，因为context被@NonNull注解修饰，直接传null的话编译器会不通过~ 使用Java语言开发的同学可以试一试 3. registerReceiver()：注册广播 public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) { synchronized (mReceivers) { //point 1 ReceiverRecord entry = new ReceiverRecord(filter, receiver); //1. 获取订阅者的过滤器集合，目的是给这个订阅者新增一个过滤器 ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.get(receiver); if (filters == null) { filters = new ArrayList&lt;&gt;(1); mReceivers.put(receiver, filters); } //point 2 filters.add(entry);//point 2 这里需要注意，因为entry是重新创建的，所以多次调用时，哪怕传入的接收器和过滤器是相同的，在发送广播时也会回调接收器多次 //解析过滤器要监听的事件(Action) for (int i = 0; i &lt; filter.countActions(); i++) { String action = filter.getAction(i); //2. 获取事件(Action)绑定的订阅者集合，目的是给这个事件增加一个订阅者 ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) { entries = new ArrayList&lt;&gt;(1); mActions.put(action, entries); } entries.add(entry); } } } 注册广播的关键步骤注释都已经标好了，总结一下在registerReceiver()方法中一共完成了两件事： 向订阅者集合添加一条数据，增加一个订阅者 遍历订阅者要订阅的事件集合，把当前的订阅者绑定到订阅的事件上去 这里的订阅者指的是广播接收器(BroadcastReceiver)，事件集合指的是广播接收器的过滤器(IntentFilter)包含的actions 在日常开发中调用registerReceiver()方法注册广播时，有一点需要注意，我们回头看注释标注point 1、point 2的地方会发现，不管传入的广播接收器和过滤器是否已经存在订阅者集合中，在point 1的位置总会重新创建ReceiverRecord来描述广播接收器和过滤器 什么意思呢 当你在注册广播时小手一抖，不小心按了Ctrl+D复制了一行 private BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { //do something * 手抖次数 } }; private IntentFilter filter = new IntentFilter(); public void test(){ LocalBroadcastManager.getInstance(this).registerReceiver(receiver,filter); LocalBroadcastManager.getInstance(this).registerReceiver(receiver,filter);//不小心手抖出来的 } 那么当事件发生时，广播接收器会收到多个回调，手抖多少次就会收到多少次~ 4. unregisterReceiver()：解除注册 public void unregisterReceiver(@NonNull BroadcastReceiver receiver) { synchronized (mReceivers) { //1. 获取订阅者绑定的过滤器集合，并将当前订阅者从订阅者集合中删除 final ArrayList&lt;ReceiverRecord&gt; filters = mReceivers.remove(receiver); if (filters == null) { return; } for (int i = filters.size() - 1; i &gt;= 0; i--) { final ReceiverRecord filter = filters.get(i); filter.dead = true;//宣告当前广播接收器死亡 //2. 遍历当前订阅者订阅的事件集合，再将它从每个事件绑定的订阅者集合中删除 for (int j = 0; j &lt; filter.filter.countActions(); j++) { final String action = filter.filter.getAction(j); //找到这个事件绑定的所有订阅者 final ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action); if (receivers != null) { //这里的倒序遍历应该是Google的小优化，通常最后注册的广播都会被优先删除，因为当前Activity被kill解除注册后就返回上一级页面了 for (int k = receivers.size() - 1; k &gt;= 0; k--) { final ReceiverRecord rec = receivers.get(k); if (rec.receiver == receiver) { rec.dead = true;//我觉得这一步多余了，因为这个订阅者在方法入口时就已经宣告死亡了，这里直接将订阅者删除就行了 receivers.remove(k); } } //安全检查，删除掉当前订阅者后，这个事件没有订阅者愿意监听了，那么从事件集合中删除 if (receivers.size() &lt;= 0) { mActions.remove(action); } } } } } } 在unregisterReceiver()解除注册广播的方法中，同样也是做了两件事： 把订阅者从订阅者集合中删除 遍历全局的事件集合(mActions)，把订阅者从绑定的事件集合中删除 这里和广播的注册流程是一样的，无非一个是增，一个是删，没什么需要特别注意的地方 5. sendBroadcast()：发送广播 public boolean sendBroadcast(@NonNull Intent intent) { synchronized (mReceivers) { //匹配规则详情 final String action = intent.getAction(); final String type = intent.resolveTypeIfNeeded( mAppContext.getContentResolver()); final Uri data = intent.getData(); final String scheme = intent.getScheme(); final Set&lt;String&gt; categories = intent.getCategories(); //获取当前事件的所有订阅者们 ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction()); if (entries != null) { //receivers集合里面保存的是，一圈遍历匹配下来，符合规则的订阅者们 ArrayList&lt;ReceiverRecord&gt; receivers = null; for (int i = 0; i &lt; entries.size(); i++) { ReceiverRecord receiver = entries.get(i); //point 1 if (receiver.broadcasting) { continue; } //规则匹配过程 int match = receiver.filter.match(action, type, scheme, data, categories, &quot;LocalBroadcastManager&quot;); if (match &gt;= 0) { if (receivers == null) { receivers = new ArrayList&lt;&gt;(); } receivers.add(receiver); //point 2 receiver.broadcasting = true; } } if (receivers != null) { //point 3 for (int i = 0; i &lt; receivers.size(); i++) { receivers.get(i).broadcasting = false; } //将订阅者们添加到待执行的任务集合中 mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); //point 4 防止重复发消息，代价是要遍历消息队列里所有消息 ummmm.. if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) { mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); } return true; } } } return false; } 发送广播的方法中就只做了一件事：从订阅事件集合(mActions)中找到符合intent条件的订阅者们，并将它们放入待执行集合(mPendingBroadcasts) 注意哦，虽然方法名称叫做发送广播，但是其实里面并没有发送的动作，只是找出符合发送规则的订阅者们丢进待执行集合，等待Handler来执行 这里有两个槽点要说一下： 一是point 1/2/3标注的broadcasting变量，压根就没用到，不知道存在的意义是什么 二是point 4标注的防止重复发消息的设计，咱创建一个bool类型的变量来标识不行嘛，为啥要想不开去遍历消息队列一个个检查 6. sendBroadcastSync()：发送同步广播 //从方法名称就可以看出这是一个同步方法，调用者会阻塞到消息分发给所有订阅者才会返回 public void sendBroadcastSync(@NonNull Intent intent) { if (sendBroadcast(intent)) { executePendingBroadcasts(); } } sendBroadcastSync()方法代码量不多，一共做了两件事： 调用sendBroadcast()方法，将符合条件的订阅者放入待执行集合(mPendingBroadcasts)，等待执行 调用executePendingBroadcasts()方法，立刻执行消息分发 这里需要重点关注的点时：由于sendBroadcastSync()方法内部调用了executePendingBroadcasts()立刻执行了消息分发，所以，各个广播接收器的onReceive()函数运行的线程，取决于广播发送者所在的线程 什么意思呢 我们知道，当调用sendBroadcast()方法发送广播时，executePendingBroadcasts()方法最终是由Handler来调用的，也就是说不管广播接收器是在哪个线程注册的，都会切换到Main线程来执行onReceive()方法中的代码 而当广播的发送者可以直接调用executePendingBroadcasts()分发消息时，性质就不一样了！！！ public void test(){ //子线程发送同步广播 new Thread(() -&gt; { LocalBroadcastManager.getInstance(null).sendBroadcastSync(new Intent(&quot;action&quot;)); }).start(); } 如上，当发送者处于子线程调用发送同步广播方法时，广播接收器的onReceive()方法也运行在这个子线程 这时候，如果在onReceive()方法中执行操作UI的代码，那你将会收到异常：Only the original thread that created a view hierarchy can touch its views. 7. executePendingBroadcasts()：派发广播 void executePendingBroadcasts() { while (true) { //保存待分发的订阅者集合 final BroadcastRecord[] brs; synchronized (mReceivers) { final int N = mPendingBroadcasts.size(); if (N &lt;= 0) { return; } brs = new BroadcastRecord[N]; mPendingBroadcasts.toArray(brs); mPendingBroadcasts.clear(); } for (int i = 0; i &lt; brs.length; i++) { final BroadcastRecord br = brs[i]; final int nbr = br.receivers.size(); for (int j = 0; j &lt; nbr; j++) { final ReceiverRecord rec = br.receivers.get(j); if (!rec.dead) { //分发事件 rec.receiver.onReceive(mAppContext, br.intent); } } } } } executePendingBroadcasts()的职责就是分发广播，在源码中也只有两个地方调用 一是构造函数的Handler，二就是sendBroadcastSync()方法，两者调用区别在2.2.6小节已经讲过了，这里就不再赘述 3、小结 介绍完LocalBroadcastManager所有的成员属性和成员方法后，我们可以总结本地广播使用的几个特点： 本地广播基于发布/订阅模式实现，通信范围只能在当前进程，若组件在manifest文件中指定运行在其他进程，就无法使用本地广播通信了 Handler的加入让本地广播有切换到主线程执行代码的能力，不管注册广播和创建广播接收器的动作执行在哪个线程，最终的回调函数都会切换到Main线程 LocalBroadcastManager在初始化后，getInstance(context)的context参数可以不传 sendBroadcastSync()发送同步广播最终的广播接收器的回调函数是运行在广播发送者线程的，要小心使用 三、总结 在本篇文章中经常把广播接收器称为订阅者，之所以这样称呼是因为LocalBroadcastManager的设计与发布/订阅模式太相似了，呐，你看Android开发者官网也是这样介绍的 LocalBroadcastManager目前在开发者官网已经Google声明为弃用状态，猜测可能因为任何组件都可以使用本地广播来发送、注册与解除注册，甚至不需要在组件内使用，任意线程都可以获取本地广播的实例来操作 若APP应用内完全依靠本地广播来通信，对整个工程来说，如何管理这些广播接收器是个问题，若再因为疏忽大意忘记手动解除绑定，那么还会造成内存泄漏的问题 不过不管是否弃用，LocalBroadcastManager内部的设计思想依旧值得学习 全文完 ","link":"https://yibaoshan.github.io/post/android-components-localbroadcastmanager/"},{"title":"漫谈设计模式（三）：行为型模式","content":" 点击跳转到掘金阅读 一、前言 在漫谈设计模式(一)、(二)中分别介绍了创建型模式和结构型模式，每种类型的设计模式侧重点不同 创建型模式关注的是如何创建对象，为工程师提供服务 结构型模式关注的是如何根据业务解耦各个模块/类，最后通过组合/关联的方式在一起工作，服务于业务 今天要介绍的是设计模式专题中的最后一种类型：行为型模式(Behavioral Pattern) 行为型模式关注的是类或对象的职责分配，同样也是为业务提供服务；和结构型模式相比较，行为型模式关注的粒度更小，更像是对结构型模式的补充 行为型模式有11种，数量看起来会比前两种类型要多，不过随着这些年语言特性和开发模式的进化，能够留下来在项目中真正落地的就不多了。 经过筛选，本文将会介绍行为型中的4种模式： 观察者模式(Observer) 责任链模式(Chain of Responsibility) 中介者模式(Mediator) 策略模式(Strategy) 以下7种模式不包含在本文中： 命令模式(Command)：简单的指令封装，参考Java封装概念 解释器模式(Interpreter)：为了解决业务需求必须存在的方案，个人认为称不上是设计模式，参考Android LayoutInflater 迭代器模式(Iterator)：源于容器访问，使用场景单一，参考Java iterator接口 模板方法(Template Method)：规范方法调用顺序，到处都是，参考Android生命周期及各种base层 状态模式(State)：不同的状态下执行不同的策略，个人认为等同策略模式 访问者模式(Visitor)：看不懂/头大.jpg (´･_･`) 备忘录模式(Memento)：纯属业务需求，参考Android Canvas的save和restore方法 以上观点属于个人理解，若您发现描述有不准确甚至完全错误的地方，请到这里进行反馈，感谢 最后，生产者消费者虽然不在23种设计模式中，但考虑到它的使用范围非常广泛，本文将在最后一章番外篇中介绍 以下，enjoy： 二、行为型模式：观察者模式 1、模式介绍 观察者模式(Observer Pattern)通常有由至少一个可被观察的对象和多个观察这个对象的观察者组成，当被观察者的状态发生变化时，会通知这些观察者 还有一种做法是增加一个中介角色，也叫发布订阅中心，把被观察者中的订阅和通知的逻辑抽离处理放在发布订阅中心，类似于Android EventBus，这种做法被叫做发布/订阅模式(Publish-Subscribe Design Pattern) 为了方便记忆，本章会把两者区分开来，两个角色的叫观察者模式，三个角色的叫做发布/订阅模式 接下来我们通过类图来看一看两者之间的区别 观察者模式： 如图所示，观察者模式一般由至少一个可被观察的对象(示例中的LiveData) ，和多个观察这个对象的观察者(示例中的LiveDataObserver)组成去观察。二者的关系是通过被观察者来建立的，所以在被观察者中，至少要有三个方法：添加观察者、删除观察者、通知消息。 当被观察者将某个观察者添加到自己的观察者列表(observers)后，观察者与被观察者的关联就建立起来了。此后只要被观察者在某种时机触发通知观察者方法时，观察者即可接收到来自被观察者的消息。 发布/订阅模式： 如图所示，发布/订阅模式是将原先在被观察者中的添加、删除、通知的逻辑抽离出来，放在发布订阅中心；观察者和被观察者之间不直接进行通讯，而是发布者将要发布的消息交由发布订阅中心管理，订阅者也是根据自己的情况，按需订阅发布订阅中心中的消息。 讲完了两者的区别后，我们通过两个简单的代码示例来分别实现一下观察者模式和发布/订阅模式： 2、代码示例 观察者模式： //定义通知方法及值类型 public interface Observer&lt;T&gt; { void onChanged(T t); } //被观察者 public class LiveData&lt;T&gt; { private final List&lt;Observer&lt;T&gt;&gt; observers = new LinkedList&lt;&gt;(); //添加观察者 public void addObserver(Observer&lt;T&gt; observer) { observers.add(observer); } //删除观察者 public void remove(Observer&lt;T&gt; observer) { observers.remove(observer); } //通知消息 public void setValue(T t) { for (Observer&lt;T&gt; observer : observers) observer.onChanged(t); } } //观察者 public class LiveDataObserver implements Observer&lt;String&gt;{ @Override public void onChanged(String s) { System.out.println(&quot;received message:&quot;+s); } } //测试代码 public class Test { @org.junit.Test public void main() { LiveData&lt;String&gt; liveData = new LiveData&lt;&gt;(); liveData.addObserver(new LiveDataObserver()); liveData.setValue(&quot;404&quot;); } } 打印结果： received message:404 以Android LiveData为例，在LiveData中提供添加/删除观察者等一系列方法，当调用setValue改变状态时就会去通知保存在观察者列表(observers)各个观察者 发布/订阅模式： //定义通知方法及值类型 public interface BroadcastReceiver { void onReceive(Object obj); } //消息订阅者 public class LoginBroadcastReceiver implements BroadcastReceiver { private String pageName; public LoginBroadcastReceiver(String pageName) { this.pageName = pageName; } @Override public void onReceive(Object obj) { System.out.println(pageName+&quot; : &quot;+obj); } } //发布订阅中心 public class LocalBroadcastManager { private static final List&lt;BroadcastReceiver&gt; broadcasts = new LinkedList&lt;&gt;(); public static void sendBroadcast(Object obj) { for (BroadcastReceiver receiver : broadcasts) receiver.onReceive(obj); } public static void register(BroadcastReceiver broadcastReceiver) { broadcasts.add(broadcastReceiver); } public static void unregister(BroadcastReceiver broadcastReceiver) { broadcasts.remove(broadcastReceiver); } } //消息发布者 public class LoginPage { private HashMap&lt;String, String&gt; dp; public LoginPage() { dp = new HashMap&lt;&gt;(); dp.put(&quot;admin&quot;, &quot;admin&quot;); } public void login(String name, String pwd) { if (dp.containsKey(name)) { if (dp.get(name).equals(pwd)) LocalBroadcastManager.sendBroadcast(&quot;successful login&quot;); else LocalBroadcastManager.sendBroadcast(&quot;login failed, access denied&quot;); } else { LocalBroadcastManager.sendBroadcast(&quot;login failed, user does not exist&quot;); } } } //测试代码 public class Test { @org.junit.Test public void main() { register(); LoginPage loginPage = new LoginPage(); loginPage.login(&quot;admin&quot;,&quot;admin&quot;); } private void register(){ LoginBroadcastReceiver mainReceiver = new LoginBroadcastReceiver(&quot;主页&quot;); LoginBroadcastReceiver basketReceiver = new LoginBroadcastReceiver(&quot;购物车&quot;); LoginBroadcastReceiver UCReceiver = new LoginBroadcastReceiver(&quot;用户中心&quot;); LocalBroadcastManager.register(mainReceiver); LocalBroadcastManager.register(basketReceiver); LocalBroadcastManager.register(UCReceiver); } } 打印结果： 主页 : successful login 购物车 : successful login 用户中心 : successful login 同样的，在发布订阅中心LocalBroadcastManager中也提供添加/删除等一系列方法，和观察者相比较有一点不同的是：任意一个消息发布者都可以通过发布订阅中心来发布消息 3、源码锚点 在Android源码中，大部分的事件监听都是使用观察者模式，所以我们随便挑一个记住就行了，比如OnClickListener 发布/订阅模式有经典的Android EventBus，如果在代码中发现有watch、watcher、observe、observer、listen、listener、dispatch、on、event、register这类单词出现的地方，很有可能是在使用观察者模式或发布订阅的思想 4、小结 2.2的代码示例实现了观察者和发布/订阅的简化版，在实际应用中，对于以上二者的实现可能会更加的复杂，所以只需理解两种模式的设计思想即可，我们来简单回顾一下： 观察者模式由观察者和被观察者两个角色组成，一旦发生被观察者的状态/数据发生变化，被观察者就会通知在观察者列表中的各个观察者 发布/订阅模式是在观察者模式的基础上增加一个发布订阅角色，加入这个角色的最重要作用就是解耦，将被观察者和观察者分离，使得它们之间的依赖性更小，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责 小结完 三、行为型模式：责任链模式 1、模式介绍 责任链模式(Chain Of Responsibility Design Pattern)：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。 根据以上GoF对责任链模式的定义，一旦某个处理器能处理这个请求，就不会继续将请求传递给后续的处理器了，事实上，在实际的开发中会有不允许请求中断的情况，每个处理器处理完成后需要继续向下传递，这个请求最终被所有的处理器都处理一遍，所以责任链模式的实现大体上可以分成两种： 允许中断请求：Android事件分发机制、Android有序广播 不中断请求：Android OKhttp 我们接着来看责任链模式的角色分配，在一个完整的责任链模式中，至少要包含两个角色： Handler：抽象处理者角色，声明一个请求处理的方法，并在其中保持一个对下一个处理节点Handler对象的引用 ConcreteHandler：具体处理者角色，对请求进行处理，如果不能处理则将该请求转发给下一个节点上的处理对象 责任链模式UML类图： 2、代码示例 //抽象处理者 public abstract class Handler { protected Handler next; public abstract void handleRequest(String msg); } //具体的处理者1 public class ConcreteHandler1 extends Handler { @Override public void handleRequest(String msg) { if (msg.equals(&quot;ConcreteHandler1&quot;)) System.out.println(&quot;ConcreteHandler1 handled&quot;); else if (next != null) next.handleRequest(msg); } } //具体的处理者2 public class ConcreteHandler2 extends Handler { @Override public void handleRequest(String msg) { if (msg.equals(&quot;ConcreteHandler2&quot;)) System.out.println(&quot;ConcreteHandler2 handled&quot;); else if (next != null) next.handleRequest(msg); } } //测试类 public class Test { public void main() { ConcreteHandler1 handler1 = new ConcreteHandler1(); ConcreteHandler2 handler2 = new ConcreteHandler2(); handler1.next = handler2; handler2.next = handler1; handler1.handleRequest(&quot;ConcreteHandler2&quot;); } } 打印结果 ConcreteHandler2 handled 3、源码锚点 责任链模式多使用于框架的设计中，我们可以利用责任链模式来提供框架的扩展点，这样就能够让使用者在不修改框架源码的情况下，复用和扩展框架的功能，以Android OkHttp举例： 我们知道，OkHttp使用方法是通过OkHttpClient的newCall方法创建了一个Call对象，并调用execute方法发起同步请求或者调用enqueue方法发起异步请求 这其中，每一个Call对象就代表一个网络请求，它的实现类只有一个RealCall： package okhttp3; //https://github.com/square/okhttp //OkHttp从4.0转为Kotlin实现，对Kotlin代码比较吃力的同学可以将分支切换到okhttp_3.14.x final class RealCall implements Call { //1. 调用execute发起请求 @Override public Response execute() throws IOException { //... try { client.dispatcher().executed(this); return getResponseWithInterceptorChain(); } finally { client.dispatcher().finished(this); } } //2. 获取响应报文，基于责任链模式 Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(new RetryAndFollowUpInterceptor(client)); interceptors.add(new BridgeInterceptor(client.cookieJar())); //... //最终调用发起 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); try { Response response = chain.proceed(originalRequest); return response; } catch (IOException e) { //... } } } getResponseWithInterceptorChain()中的代码不是很复杂，就是将用户传入的拦截器收集起来再加上默认的一些缓存拦截器、连接拦截器等，然后组装成一个RealInterceptorChain类，再调用其proceed方法，得到响应报文response 在proceed方法中，会不断的查找下一个拦截器，然后再调用拦截器的intercept()方法 package okhttp3.internal.http; public final class RealInterceptorChain implements Interceptor.Chain { public Response proceed(Request request, Transmitter transmitter, Exchange exchange) throws IOException { // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout); //找到下一个拦截器 Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); return response; } } 最后在intercept方法中，我们就可以对请求报文和响应报文做处理 public final class Interceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { //处理request请求，报文加密之类就是在这一步 Request request = chain.request(); //处理返回结果，比如统一报错拦截 Response response = chain.proceed(request); return response; } } 至此，整个调用链路就结束了，最后我们用一张图来总结拦截器责任链： 4、小结 责任链模式通常由链式结构组成，对于链式结构来说，每个节点都可以被拆开再连接(也叫可插拔)，因此，责任链模式生来就具有很好的灵活性 我们可以把链上的每一个节点看作是一个对象，不同的对象拥有不同的处理逻辑；将一个请求从链式的首端发出，沿着链的路径依次传递，每一个注册到链上的处理者可以选择要不要消费当前的请求，当前节点处理完成后，可以再根据业务场景选择要不要向下传递，直到最后一个处理者处理完成或者某个节点终止传递 小节完 四、行为型模式：中介者模式 1、模式介绍 中介者模式(Mediator)定义了一个单独的中介对象，来封装一组对象之间的交互；将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。 当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时涉及修改很多其他对象的行为，可采用中介者模式，来解决紧耦合问题。 举个例子来解释一下：在客户端电商首页开发总，要求banner轮播切换的同时要修改背景图，还要注意色值来动态改变状态栏颜色深浅，下拉展示二楼和左右滑动切换tab时要渐变透明度，浏览商品时状态栏要复原同时banner停止滚动，对于客户端开发来说，当一个页面的控件改变需要同步给其他若干个控件时，其它控件状态改变也需要互相之间同步时，这代码逻辑写起来简直要爆炸 这个时候，我们就需要引入一个中间人，把每个控件状态改变都交给同一人处理，每个控件控制权也交由中间人 加入了中介者之后的逻辑图： 有了中介者之后，砍去了各个类之间的直接联系，将杂乱无章的逻辑关系改为星状的逻辑关系，自己的状态控制和状态改变全部交由中介者来处理，大大减少各个类的逻辑处理 2、小结 中介者模式从某种角度来说像是算法里面的贪心策略，回顾4.1中的例子，当一个页面的控件改变需要同步给其他若干个控件时，单单维护控件通信一项就已经很麻烦了，这时候会自然而然的选择最优解，即引入中间层然后将每个控件状态改变都交给它来处理，正因为如此，在客户端开发中，中介者模式常常与观察者模式同时出现 小节完 五、行为型模式：策略模式 1、模式定义 策略模式，英文全称是 Strategy Design Pattern，在 GoF 的《设计模式》一书中，它是这样定义的： Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 定义一系列算法，将每个算法分别封装起来，并使它们可互换；策略模式可以使算法的变化独立于使用它们的客户端 GoF中还提到，在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色，策略模式仅仅封装算法 在翻阅了大量书籍/文章后，笔者认为上面的话也可以这么理解：在一个系统中，不同对象的同一行为会有不同的结果，便可使用策略模式 听起来好像很熟悉，和Java语言中的多态解决的场景是重复的，我们可以把策略模式等同于多态的话理解起来就容易多了 小节完 六、番外篇：生产者-消费者模式 1、模式介绍 生产者/消费者模式虽然不在23种设计模式之列，但我认为它在软件工程的重要性绝不亚于23种设计模式中任何一种 无论是Android客户端的Handler机制，还是后端的各种MQ消息中间件，他们的设计思想都是基于生产者/消费者模式 简单一句话概括什么是生产者/消费者模式：多个进程/线程共享一个阻塞队列，生产者负责push任务进队列，消费者负责取出任务去执行 2、代码示例 我们用代码实现UML类图的模式，拆分一下上面的图，有三个角色：消息队列、生产者、消费者 首先是消息队列，这个比较简单，使用集合框架中现成的队列就行了，如下： static final Queue&lt;String&gt; messageQueue = new ArrayDeque&lt;&gt;(); 接着要有至少一个生产者，负责生产消息，示例这里的生产者是Java Scanner，负责不断获取控制台输入的消息，然后添加到消息队列当中 final static class ProducerThread extends Thread { @Override public void run() { Scanner scanner = new Scanner(System.in); System.out.println(&quot;please input:&quot;); //生产者线程获取控制台消息 while (true) { String line = scanner.next(); if (line.equals(&quot;exit&quot;)) break; //获取到消息后添加到共享的消息队列，同时唤醒可能正在等待的消费者线程 synchronized (messageQueue) { messageQueue.add(line); messageQueue.notify(); } } } } 接着要有一个消费者，负责消费消息队列中的消息 final static class ConsumerThread extends Thread { public ConsumerThread(String name) { super(name); } @Override public void run() { synchronized (messageQueue) { //消费者一直不停的从共享消息队列取消息 while (true) { if (messageQueue.isEmpty()) { messageQueue.wait();// 没有消息则阻塞，等待唤醒 } // 被唤醒后会执行该方法 execute(messageQueue.poll()); } } } private void execute(String msg) { //do something System.out.println(getName() + &quot; take msg:&quot; + msg); } } 好了，三个角色都已经有了，下面我们来测试一下 public static void main(String[] args) { ProducerThread producerThread = new ProducerThread(); producerThread.start();//启动生产者线程 ConsumerThread consumerThread1 = new ConsumerThread(&quot;消费者1号&quot;); ConsumerThread consumerThread2 = new ConsumerThread(&quot;消费者2号&quot;); //启动消费者线程 consumerThread1.start(); consumerThread2.start(); } 打印结果 please input: 1 消费者1号 take msg:1 2 消费者2号 take msg:2 3、源码锚点 笔者是Android工程师，所以本章节我们来探讨一下Android Handler机制的设计 我们知道，Andorid Handler机制由Handler、Looper、Message和MessageQueue这4个类组成，他们的职责分工和6.2中的代码示例没什么区别： Handler：消息生产者 只要是在MainLooper所在线程创建的Handler就会持有共享消息队列MessageQueue，在任意线程中调用该Handler的sendMessage发送的消息都会被添加到共享消息队列中，共享消息队列由Java的线程局部存储机制(ThreadLocal)保证唯一性 Looper：消息的消费者 loop()方法中会一直轮询消息队列，它的任务就是取消息、取消息和取消息，取到消息后就分发消息、分发消息和分发消息 MessageQueue：共享的消息队列 在next()方法中，若消息队列为空则会阻塞等待，参考6.2示例中消息队列为空时就挂起当前线程，知道被唤醒 Message：不配拥有姓名，只是个消息对象 这里注意一点，在Handler机制中，Looper的角色虽然是消费者，但是它只负责从消息队列取消息，不负责处理。loop()方法中每次取到消息就交给消息所属的Handler类处理 此小节涉及到的代码在这里 4、小结 生产者/消费者模式解耦了生产者与消费者之间的直接联系，而且由于共享消息队列的存在，大多应用在各大多线程异步协作当中 在后端开发中，共享消息队列本身就是个缓冲区，所以我们可以调整缓冲区的大小来应对高并发时请求数量太大服务器应付不过来等类似场景 在Android或其他包含用户界面的操作系统中，共享消息队列可以保证所有更新界面的操作都只在UI线程进行 小结完 七、总结 至此，行为型模式已经全部介绍完了，我们来简单回顾一下： 观察者模式(Observer)：持有回调列表 责任链模式(Chain of Responsibility)：OkHttp 中介者模式(Mediator)：星状连接图 策略模式(Strategy)：Java多态 命令模式(Command)：Java封装 解释器模式(Interpreter)：Android LayoutInflater 迭代器模式(Iterator)：Java iterator接口 模板方法(Template Method)：Android生命周期及各种base层 状态模式(State)：迪迦奥特曼力量/速度形态，等同策略模式 访问者模式(Visitor)：嗯~看不懂/头大.jpg (´･_･`) 备忘录模式(Memento)：Android Canvas(save/restore) 行为型模式的数量看起来比较多，但毕竟20多年过去了，以前的模式或不适用当前环境，或直接被融入语言/开发模式中，以本章行为型模式来举例： 有为了业务需求必须这么设计的，例如：解释器模式、备忘录 有被融入语言特性的：命令模式(Java封装)、策略模式(Java多态) 有是人都会选择最优解的：中介者模式 还有我认为雷同的，状态模式和策略模式，在实际开发中，不管是从实现角度还是解决问题的场景来看我不认为它们两者有什么区别 有用的几种行为型模式中，如观察者模式、责任链模式主要是解决对象与对象之间职责分配的问题 八、参考资料 图说设计模式 refactoringguru.cn 极客时间：设计模式之美-王争 《设计模式：可复用面向对象软件的基础》 《Android 源码设计模式解析与实战》-何红辉 / 关爱民 《深入浅出设计模式-LeetCode》 《Head First 设计模式》 jimuzz：从设计模式角度看OkHttp源码 ","link":"https://yibaoshan.github.io/post/design-pattern-behavioral/"},{"title":"漫谈设计模式（二）：结构型模式","content":" 点击跳转到掘金阅读 一、前言 结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单的组合形成复杂的、功能更为强大的结构。 结构型模式的实现可以分为两种，类结构型模式和对象结构型模式，其中： 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和接口实现关系。 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。 本文将会介绍几种常见的结构型模式，他们分别是： 享元模式(Flyweight) 代理模式(Proxy) 装饰模式(Decorator) 适配器模式(Adapter) 桥接模式(Bridge) 外观模式(Facade) 同时，为了更加方便的理解结构型模式的设计思想，本文将加入一个项目阶段的概念： 开发中，也包含开发前期，一般是代码未发布可以随意更改的阶段 开发完成，已发布/封装完成，或是没有源码，只能补救的阶段 不同的开发阶段所能适用的设计模式也不同，在理解设计者的意图时，这一点尤其重要 另外，本篇文章是笔者个人对结构型模式的理解，由于结构型模式的概念有些抽象(相较于创建型模式)，每个人的理解也不尽相同，因此，若您发现笔者的描述有不准确甚至完全错误的地方，请到这里进行反馈，感谢 二、结构型模式：享元模式 1、模式定义 享元模式(又称蝇量模式)是对象池的一种实现，它的英文名称叫做Flyweight，代表轻量级的意思。 享元模式用来尽可能减少内存使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能，是典型的以空间换时间的设计模式。 享元模式的设计思想比较简单，关于享元模式有争议的一点是：享元模式是否只是对象池的一种实现，如果是，那么原文中提到的需要关注对象的内部状态和外部状态是什么意思？ 换句话说，享元模式和池化技术之间是否可以直接划等号？ 要探讨这个问题，我们先来看一下《设计模式》一书中对享元模式的定义： A flyweight is a shared object that can be used in multiple contexts simultaneously. The flyweight acts as an independent object in each context—it's indistinguishable from an instance of the object that's not shared. Flyweights cannot make assumptions about the context in which they operate. The key concept here is the distinction between intrinsic and extrinsic state. Intrinsic state is stored in the flyweight; it consists of information that's independent of the flyweight's context, thereby making it sharable. Extrinsic state depends on and varies with the flyweight's context and therefore can't be shared. Client objects are responsible for passing extrinsic state to the flyweight when it needs it. —《Design Patterns: Elements of Reusable Object-Oriented Software》 flyweight是一个共享对象，它可以同时在多个场景(context)中使用，并且在每个场景中flyweight都可以作为一个独立的对象—这一点与非共享对象的实例没有区别。flyweight不能对它所运行的场景做出任何假设，这里的关键概念是内部状态和外部状态之间的区别。内部状态存储于flyweight中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享。而外部状态取决于flyweight场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给flyweight。 —《设计模式：可复用面向对象软件的基础》机械工业出版社 从这段话的描述可以看出，作者强调享元模式的特点之一是对象的内部状态可变、外部状态不可变且不可被共享。那么什么是对象的内部状态和外部状态？下面我们一起来通过2.2中的代码示例看一看能否找出答案 2、代码示例 /*国家类*/ public class Country { private String countryName;//国家名称 private String countryArea;//国土面积 //more.. public static Country query(String country){ //通过key查询内存/数据库等保存的国家对象 } } /*用户信息类*/ public class UserInfo { public Integer age;//用户年龄 public String nickname;//昵称 public Country country;//国家 //more.. public static UserInfo obtain(){ //内部维护一个对象缓存池 } } /*测试类*/ public class Test { @org.junit.Test public void main() { UserInfo sanZ = UserInfo.obtain(18, &quot;张三&quot;, Country.query(&quot;中国&quot;)); UserInfo siL = UserInfo.obtain(18, &quot;李四&quot;, Country.query(&quot;中国&quot;)); //移民到新加坡养老 siL.country = Country.query(&quot;新加坡&quot;); } } 代码示例中只有两个类，用户信息类和国家类，在用户信息类的内部状态中，有一个country属性，country属性对应的国家类中内部维护一组数据，不公开set()方法。当某一个用户更改自身的country属性时，只能通过国家名称重新查询国家对象，这就是所谓享元对象内部属性更改时不影响其外部状态的含义； 总结一下，享元对象指的是可以被共享的对象，在2.2的示例代码中，用户信息类就是享元对象。由于享元对象可以被共享，其内部属性(姓名、年龄、国家等)可以被重新赋值，这被叫做对象的内部状态；国家类是独立的一个组织，不管用户信息类中的country属性如何更改都不会影响到国家类中的内部数据，国家类就被称为享元对象类的外部状态 3、源码锚点 在看过了2.2小节的示例之后，我们再回过头来看看Android Message的实现 /*伪代码*/ public class Message { private String val; private Message next; private static Message root; private static int size = 0; private static final int MAX_SIZE = 10; public static Message obtain() { if (root != null) { //获取链表表头的对象 Message temp = root; root = temp.next; temp.next = null; size--; return temp; } return new Message(); } public String getVal() { return val; } public void setVal(String val) { this.val = val; } public void recycle() { //回收对象，将属性内容清空 this.val = null; //若缓存池还没满，将该对象保存至链表表头位置 if (size &lt; MAX_SIZE) { next = root; root = this; size++; } } } 从代码中可以看到，Message用链表实现了个复用池，回到2.1中的疑问，Android Message的链表复用池的设计思想是能被称为享元模式吗？笔者认为是可以的，只不过Message没有外部状态罢了 除了Android Message外，Java中还有String常量池，int，float等基础类型的包装类型也都使用了享元模式，感兴趣的朋友可以自行搜索了解 4、小结 总结一下，享元模式的设计思想是通过复用对象，以达到节省内存的目的，享元模式适合在以下的场景中使用： 系统中存在大量的相似对象，可以抽离为外部对象，例如2.2中的国家对象 需要缓冲池的场景，例如Android Message对象，Java基本类型的包装类 有些书籍/资料将享元模式翻译为蝇量模式，这一点需要注意，享元模式和蝇量模式是同一个 此小节涉及到的代码在这里 三、结构型模式：代理模式 1、模式定义 代理模式是指在不改版原始类的情况下，通过新增代理类的方式，来给原始类加入新的功能 代理模式实现的场景分为两种，外部类和内部类。 外部类一般是在原始类无法进行更改的情况使用，以3.2中的方法耗时统计举例来说，要统计Stack每个方法的耗时，我们可以创建StackProxy类继承自Stack类，然后在StackProxy中调用Stack的方法同时加入耗时统计的代码。 内部类指的是原始类代码可以更改的情况，通常会抽象出统一的接口，实现类和代理类都实现该接口，在代理类中添加逻辑代码；还是以Stack耗时统计为例，我们可以抽象出IStack类，创建Stack类实现IStack接口以完成功能，创建StackProxy类同样实现IStack接口以完成耗时统计逻辑； 代理模式的原理和代码实现都不难掌握，接下来一起来看3.2中的代码示例 2、代码示例 2.1 内部类的实现 /*统一接口类*/ public interface IStack { void push(int val); int pop(); } /*实现类*/ public class Stack implements IStack { private Node root; private int size = 0; @Override public void push(int val) { root = new Node(val, root); size++; } @Override public int pop() { if (root != null) { Node temp = root; root = root.next; size--; return temp.val; } throw new EmptyStackException(); } private static final class Node { int val; Node next; public Node(int val, Node next) { this.val = val; this.next = next; } } } /*代理类*/ public class StackProxy implements IStack { private final IStack stack; public StackProxy(IStack stack) { this.stack = stack; } @Override public void push(int val) { long start = System.currentTimeMillis(); stack.push(val); System.err.println(&quot;push:&quot; + (System.currentTimeMillis() - start)); } @Override public int pop() { long start = System.currentTimeMillis(); int res = stack.pop(); System.err.println(&quot;pop:&quot; + (System.currentTimeMillis() - start)); return res; } } /*使用示例*/ public class Test { @org.junit.Test public void main() { IStack stack = new StackProxy(new Stack()); } } 需求是统计Stack中插入和弹出的方法耗时，倘若上述角色只有Stack一个，那么统计耗时就需要耦合在业务代码之中，违背了单一职责原则。这时候我们就可以引入代理模式来解决这个问题，将Stack类分成三个角色(统一接口、实现类、代理类)，将统计逻辑和实际业务解耦，保持实现类的职责单一，通过实现抽象接口来完成代理工作的被称为代理模式的内部类实现 2.2 外部类的实现 /*代理类*/ public class StackProxy&lt;E&gt; extends java.util.Stack&lt;E&gt; { @Override public E push(E item) { long start = System.currentTimeMillis(); E push = super.push(item); System.err.println(&quot;push:&quot; + (System.currentTimeMillis() - start)); return push; } @Override public synchronized E pop() { long start = System.currentTimeMillis(); E pop = super.pop(); System.err.println(&quot;pop:&quot; + (System.currentTimeMillis() - start)); return pop; } } /*使用示例*/ public class Test { @org.junit.Test public void main() { Stack&lt;Integer&gt; stack = new StackProxy&lt;&gt;(); } } 接着上面耗时统计的需求，在此示例中，Stack类是来自java.util包，内部代码不可以进行更改。这种情况便只有创建StackProxy继承java.util.Stack类，再对每个方法都加入耗时统计的代码来完成需求，这种方式被称为代理模式的外部类实现 3、动态代理 在2.1和2.2小节中我们发现，在每个方法中，耗时统计的逻辑代码是类似的，根据能自动绝不手动的开发原则，我们可以使用动态代理来解决这个问题，这也是实际开发中经常使用的。所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。 如果您使用的是 Java 语言，实现动态代理就是件很简单的事情，因为 Java 语言本身就已经提供了动态代理的语法。接下来我们看一下如何用Java的动态代理来实现上一小节的功能： /*动态代理类*/ public class StackDynamicProxy { public Object createProxy(Object proxyObject) { Class[] interfaces = proxyObject.getClass().getInterfaces(); DynamicProxyHandler handler = new DynamicProxyHandler(proxyObject); return Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(), interfaces, handler); } private static class DynamicProxyHandler implements InvocationHandler { private final Object proxyObject; public DynamicProxyHandler(Object proxyObject) { this.proxyObject = proxyObject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { long start = System.currentTimeMillis(); Object result = method.invoke(proxyObject, args); System.err.println(method.getName() + &quot;:&quot; + (System.currentTimeMillis() - start)); return result; } } } /*使用示例*/ public class Test { @org.junit.Test public void main() { StackDynamicProxy proxy = new StackDynamicProxy(); IStack stack = (IStack) proxy.createProxy(new Stack()); } } 4、源码锚点 代理模式在Android源码中的应用，除了有经典的retrofit外，Android Hook、插件化也都使用了代理模式，笔者这里简单介绍一下插件化是如何使用代理模式做到替换Activity的： 在调用context.startActivity()方法启动Activity时，最终是由Instrumentation类负责创建Activity对象的。那么，我们可以创建代理类来替换掉系统的Instrumentation对象，在监控到启动的是AndroidManifest中占位Activity时，替换成插件中的目标Activity，大致流程如下： 创建Instrumentation的代理类InstrumentationProxy public class InstrumentationProxy extends Instrumentation { private final Instrumentation instrumentation; public InstrumentationProxy(Instrumentation instrumentation) { this.instrumentation = instrumentation; } } Hook系统的Instrumentation //1. 获取进程中ActivityThread的对象 Class&lt;?&gt; classes = Class.forName(&quot;android.app.ActivityThread&quot;); Method activityThread = classes.getDeclaredMethod(&quot;currentActivityThread&quot;); activityThread.setAccessible(true); Object currentThread = activityThread.invoke(null); Field instrumentationField = classes.getDeclaredField(&quot;mInstrumentation&quot;); instrumentationField.setAccessible(true); Instrumentation instrumentationInfo = (Instrumentation) instrumentationField.get(currentThread); //2. 创建代理对象，将mInstrumentation实例保存到代理对象中 InstrumentationProxy proxy = new InstrumentationProxy(instrumentationInfo); //3. 将系统mInstrumentation示例替换为代理对象 instrumentationField.set(currentThread, proxy); 代理类中重写execStartActivity方法 public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { //... ComponentName componentName = intent.getComponent(); String packageName = componentName.getPackageName(); String classname = componentName.getClassName(); if (classname.equals(&quot;TargetActivity&quot;)) { //判断是否为目标Activity intent.setClassName(who, ProxyActivity.class.getCanonicalName()); // 替换为占位的Activity启动 } //... } 代理类中重写newActivity方法，创建真正启动的Activity public Activity newActivity(ClassLoader cl, String className, Intent intent) { //... String classnameIntent = intent.getStringExtra(ACTIVITY_RAW); String packageName = intent.getComponent().getPackageName(); // 获取Intent中保存的真正Activity包名、类名 if (className.equals(ProxyActivity.class.getCanonicalName())) { ComponentName componentName = new ComponentName(packageName, classnameIntent); // 替换真实Activity的包名和类名 intent.setComponent(componentName); className = classnameIntent; } //... } Hook Instrumentation实现Activity插件化启动小结： Hook系统的Instrumentation对象，设置创建的代理类 在代理类中修改启动Activity的Intent，将启动的目标Activity替换为占位Activity，从而避免注册清单的检查 在代理类中重写newActivity()将启动的活动换回真实目标，然后继续执行原有逻辑 Android提供的AIDL跨进程通信同样也用到了代理模式，Client端调用asInterface()保存的interface对象其实就是Server端的代理，这里有笔者实现的一个小Demo，感兴趣的同学可以点击查看 5、小结 最后我们再来复习一下代理模式的定义：在不改版原始类的情况下，通过新增代理类的方式，来给原始类加入新的功能 实现方式分为内部类和外部类，内部类使用接口或抽象类，外部类使用继承实现 代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让开发人员只需要关注业务方面的开发。除此之外，代理模式在跨进程通信、插件化等场景中也有使用 此小节涉及到的代码在这里 四、结构型模式：装饰者模式 1、模式定义 从代码结构上来看，装饰模式和代理模式(内部类实现)两者间非常相似，从结构来看它俩不能说是毫无关系，只能说是一模一样；回顾上一小节对代理模式的定义：代理模式是指在不改变原始类的情况下，通过新增代理类的方式，来给原始类加入新的功能 这句话动动俩字就是装饰模式：装饰模式是指在不改变原始类的情况下，通过新增装饰类的方式，加强原始类的属性。 虽然装饰模式和代理模式结构非常相似，但适用场景中却太不一样；装饰模式在日常开发中主要解决继承过于复杂的问题，通过组合来替代继承，也就是说装饰模式是继承关系的一种替代方案之一 一般有两种方式可以实现给一个类或对象增加行为： 继承：继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法，相当于给父类增加行为 关联：将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为 接下来我们通过4.2示例代码模拟的应用场景来解释为什么说装饰模式是继承关系的替代方案： 2、代码示例 /*衣服-接口类*/ public interface IClothes { int getWarmValue(); } /*衣服-大衣类*/ public class Coat implements IClothes { private final IClothes clothes; public Coat(IClothes clothes) { this.clothes = clothes; } @Override public int getWarmValue() { return clothes.getWarmValue() + 50; } } /*衣服-裤子类*/ public class Pants implements IClothes { private final IClothes clothes; public Pants(IClothes clothes) { this.clothes = clothes; } @Override public int getWarmValue() { return clothes.getWarmValue() + 50; } } /*衣服-衬衫类*/ public class Shirt implements IClothes { private final IClothes clothes; public Shirt(IClothes clothes) { this.clothes = clothes; } @Override public int getWarmValue() { return clothes.getWarmValue() + 30; } } /*使用示例*/ public class Test { @Test public void main() { IClothes bob = new Bob(); //在浴室洗澡 System.out.println(&quot;什么都没穿时的保暖值：&quot; + bob.getWarmValue()); bob = new Shirt(bob); //穿好衣服在家 System.out.println(&quot;穿了件衬衫时的保暖值：&quot; + bob.getWarmValue()); bob = new Pants(bob); System.out.println(&quot;又穿了条裤子时的保暖值：&quot; + bob.getWarmValue()); //出门约朋友 bob = new Coat(bob); System.out.println(&quot;又穿了件外套时的保暖值：&quot; + bob.getWarmValue()); } private class Bob implements IClothes { @Override public int getWarmValue() { return 0; } } } 打印结果 什么都没穿时的保暖值：0 穿了件衬衫时的保暖值：30 又穿了条裤子时的保暖值：80 又穿了件外套时的保暖值：130 在该示例中，衬衫、裤子、外套等衣物分别实现了IClothes接口，不同的衣物保暖程度也不一样，也就是每件衣服增强的属性值都不一样；在不同场景的衣服搭配也不同，若本例不适用装饰模式而是使用继承的话，各种各样的排列组合可能会躲到爆炸；使用了装饰模式就只需要为每件衣服生成一个装饰类即可，所以就增加对象功能来说，装饰模式比生成子类实现更为灵活。 3、源码锚点 在极客时间：设计模式之美中王争老师提到了Java I/O 类的设计中使用了装饰模式，无奈笔者水平有限，无法将王争老师的思想以自己的语言重新表述；笔者平时读/写文件都是通过项目中封装的工具类来操作，Java I/O如何设计的笔者确实不是很清楚，关于Java I/O类的使用以及用到哪些设计模式笔者会单独写一篇文章来介绍，对此感兴趣的同学可以自行搜索其他资料阅读 除了Java I/O外，许多文章提到Android Context也是装饰者模式，关于这一点笔者倒是有不同的看法 图片来源：自己画的 从类图中可以看到，Application、Service、Activity都继承自ContextWrapper；虽然ContextWrapper和ContextImpl都是Context的实现类，但在ContextWrapper中，所有的方法其实都委托给mBase(也就是ContextImpl)来实现；所以，基于现在Context的结构，笔者认为Context说是代理模式可能更为贴切 但是，我们把场景稍微改动一下，假设现在新增ContextImpl2角色，增加的目的是为了使在Application和在Activity所能获取权限不同，ContextImpl2的权限更为强大，这样做就更符合装饰模式的设定 图片来源：自己画的 4、小结 装饰模式来实现扩展比继承更加灵活，装饰模式和代理模式内部类实现)极为相似，但它们所适用的场景不一样；当看到类似的代码结构时，需要联系上下文才能判断出设计者的意图；另外，装饰模式和代理模式在项目中所适用阶段也不相同，代理模式在任何阶段都可以使用，而装饰模式通常在项目前期设计阶段就应该考虑到。 此小节涉及到的代码在这里 五、结构型模式：适配器模式 1、模式定义 适配器模式的定义是将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作 适配器模式有两种实现方式：类适配器和对象适配器；其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现，两者的区别可以在这里查看 在实际开发中，适配器模式往往充当遗留问题的实现转换器，通常在项目后期代码更改代价很高，或者某个功能依赖第三方来实现的情况下使用，举个栗子： 假设我们在一个Android项目中集成了阿里支付SDK，在调用登录方法时需要传入高德地图提供的位置信息，但是早期项目中已经接入腾讯地图，腾讯地图能够提供阿里支付所需的位置信息，只是入参类型不同接口不兼容。这种场景我们就可以使用适配器模式，定义一个包装类，把腾讯地图提供的位置信息转换成阿里支付需要的类型，这个包装类指的就是适配器(Adapter) 2、代码示例 /*阿里支付SDK*/ public class AliPay { /*登录方法需要传入位置信息*/ public boolean login(String id, String pwd, IAMap.AMapParams location) { return res; } /*高德地图接口*/ public interface IAMap { AMapParams getAMapParams(); class AMapParams { public float aMapLongitude;//经度 public float aMapLatitude;//纬度 } } } /*腾讯地图SDK*/ public class TencentMap { private final TencentMapParams params; public TencentMap() { params = new TencentMapParams(); params.tencentMapLongitude = new Random().nextFloat(); params.tencentMapLatitude = new Random().nextFloat(); } /*提供腾讯地图的位置信息*/ public TencentMapParams getTencentMapParams() { return params; } public static class TencentMapParams { public float tencentMapLongitude;//经度 public float tencentMapLatitude;//纬度 } } /*适配器，使用继承实现，也可以改为使用对象实现*/ public class Adapter extends TencentMap implements IAMap { @Override public AMapParams getAMapParams() { //将腾讯地图提供的位置信息转为高德的位置信息 AMapParams aMapParams = new AMapParams(); TencentMapParams tencentMapParams = this.getTencentMapParams(); aMapParams.aMapLongitude = tencentMapParams.tencentMapLongitude; aMapParams.aMapLatitude = tencentMapParams.tencentMapLatitude; return aMapParams; } } /*使用示例*/ public class Test { @Test public void main() { Adapter adapter = new Adapter(); AliPay aliPay = new AliPay(); aliPay.login(&quot;admin&quot;, &quot;admin&quot;, adapter.getAMapParams()); } } 代码示例中有三个角色，阿里支付SDK、腾讯地图SDK、适配器Adapter，其中适配器的作用就是将腾讯地图提供的位置信息转换成阿里支付想要基于的高德地图接口的位置信息，这就是所谓的不兼容的接口转换为可兼容的接口 3、源码锚点 在Android领域的大多数博客中，总是以RecyclerView.Adapter为例来讲解适配器模式，这一点笔者认为可能不是很恰当，在查看了部分RecyclerView源码和讲解设计模式的书籍之后，笔者认为RecyclerView的Adapter虽然名字叫适配器，但它完成的工作说是桥接模式可能更适合一些 关于适配器模式的源码示例笔者暂时没有找到，若您发现适配器模式的源码应用，请到这里告诉我，感谢 4、小结 总结一下，适配器模式可以简单理解成转换器，大部分情况下是作为一种补偿机制，用来补救设计上的缺陷，或者像5.2代码示例中源码无法更改的情况；使用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避掉接口不兼容的问题，那这种模式就没有应用的机会了 此小节涉及到的代码在这里 六、结构型模式：桥接模式 1、模式定义 桥接模式的定义比较简单：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 由于桥接模式的定义比较简短，所以网上关于桥接模式的争议比较多，不管是在中文网站还是英文网站；存在争议的地方在于，桥接模式是GoF定义的的将实现与抽象分离，还是一个类存在两个(或多个)独立变化的维度，可以通过组合的方式，让这两个(或多个)维度可以独立进行扩展；若是后者，那么它和策略模式的区别是什么 目前关于桥接模式还没有定论，所以本篇文章根据GoF的原文定义来展开。笔者个人会将桥接模式等同于依赖倒置原则的实现，包括上文提到的桥接模式以及接下来的代码示例都基于此，若和您理解的有偏差，可以跳过此章节 2、代码示例 public interface IImageLoader { void loadUrlIntoImageView(ImageView view, String url); } public class ImageLoader implements IImageLoader { @Override public void loadUrlIntoImageView(ImageView view, String url) { //do something.. } } 上面的例子比较简单，但大多数桥接模式的实现也都是在此基础上进行扩展，增加更多的类和更多的方法 3、小结 桥接模式在实际开发中使用的比较多，多数Android项目都会使用桥接模式来隔离第三方库，以图片加载框架举例，其中，定义属性行为的抽象层放在Base模块，而实现方一般放在Business或APP层 此小节存在争议，笔者另提供其他的资料供您参考：桥接模式、桥接模式2、Bridge Pattern、Bridge Design Pattern in Java 七、结构型模式：外观模式 1、模式定义 外观模式是指给一个复杂的系统提供一个统一的外观(接口)，方便调用者使用，不会改变任何接口 以商品下单为例，当服务端接收到客户端的下单请求时，需要检查用户身份，商品库存、价格、邮费、优惠券等信息，外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能 从外观模式的职能来看，笔者认为可能叫做封装模式更合适，因为外观模式貌似也只解决了对外公开方法属性的问题，甚至都不能被称为设计模式 八、总结 本文介绍了7大结构型模式中的6种模式，其中，除了享元模式和外观模式相对独立之外，其他4种设计模式：代理、装饰者、适配器、桥接，它们之间的代码结构非常相似。笼统来说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。 尽管代码结构相似，但这4种设计模式的用意完全不同，也就是说要解决的问题、应用场景、适用的项目阶段不同，这也是它们的主要区别 代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。 装饰器模式：装饰者模式同样在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。 适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。 桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。 区别结论来源：极客时间：设计模式之美-王争 Stack Overflow有关于代理、适配、适配器、桥接这4种模式有什么不同的讨论话题，可以点击下面的链接进行查看 https://stackoverflow.com/questions/350404/how-do-the-proxy-decorator-adapter-and-bridge-patterns-differ/350471#350471 组合模式不包含在本文中，想要了解更多的可以点击这里 全文完 再次说明：以上是笔者个人对结构型模式的理解，由于结构型模式的概念有些抽象(相较于创建型模式)，每个人的理解也不尽相同 若您发现笔者的描述有不准确甚至完全错误的地方，请到这里进行反馈，感谢 九、参考资料 图说设计模式 refactoringguru.cn 极客时间：设计模式之美-王争 《设计模式：可复用面向对象软件的基础》 《Android 源码设计模式解析与实战》-何红辉 / 关爱民 《深入浅出设计模式-LeetCode》 《Head First 设计模式》 Android插件化—高手必备的Hook技术 ","link":"https://yibaoshan.github.io/post/design-pattern-structural/"},{"title":"漫谈设计模式（一）：创建型模式","content":" 点击跳转到掘金阅读 一、前言 创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。 为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 简单来讲，相较于另外两种类型(结构型和行为型)，创建型模式的侧重点在于如何创建对象 本文会简单介绍几种常见的创建型模式： 单例模式 工厂模式 建造者模式 注意，原型模式不包含在本文中，想要了解更多的可以自行冲浪搜索 二、创建型模式：单例模式 1、模式定义 单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。 除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。 该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。 图片来源：自己画的 2、使用方法 单例使用方法简单，理解起来也比较容易，笔者这里就直接开门见山，介绍四种常见的使用方式 2.1 饿汉式 public class Singleton1 { private static final Singleton1 instance = new Singleton1(); public Singleton1() { } public static Singleton1 getInstance() { return instance; } public void doSomething() { //doSomething } } 饿汉式是常见使用方法中最简单的一种，JVM类加载机制得以保证类加载过程中是线程安全的，所以多线程环境下使用也是没问题的 饿汉式单例模式唯一的问题可能就是：并非懒加载，只要单例类被虚拟机加载，就必然会创建instance实例。此时，若是被提前初始化的示例工程中用不到，那的确是白白消耗了初始化的时间和内存空间 不过考虑到单例模式的使用场景，笔者认为大多数情况下使用饿汉式并不会给项目带来多余的负担。 2.2 懒汉式：静态内部类 public class Singleton2 { private Singleton2() { } public static Singleton2 getInstance() { return SingletonHolder.instance; } private static class SingletonHolder { private static final Singleton2 instance = new Singleton2(); } public void doSomething() { //doSomething } } 和2.1的代码示例相同，静态内部类同样由JVM类加载机制保证了多线程环境下的安全性；同时，由于没有在局部变量中声明，所以就算因为非主观因素导致单例类被虚拟机加载，也无需担心创建了暂时用不到的对象导致占用内存。 静态内部类的单例模式既能保证多线程环境下的安全又实现了懒加载，代码写起来比较方便，这也是笔者个人比较喜欢用的一种方式 2.3 懒汉式：双重校验锁DCL public class Singleton3 { private volatile static Singleton3 instance; private Singleton3() { } public static Singleton3 getInstance() { if (instance == null) { synchronized (Singleton3.class) { if (instance == null) { instance = new Singleton3(); } } } return instance; } public void doSomething() { //doSomething } } DCL(DoubleCheckLock)双重校验锁可能是所有单例模式中传播最广的方式了，这也是笔者在工作早期接触最多的单例模式；DCL双重检验锁的方式把线程安全和懒加载都考虑到了，并且涉及到Java并发编程中两个比较重要的关键字：volatile和synchronized，相较于上面的两种示例，DCL可以拎出来的点比较多，笔者猜测可能这也是为什么DCL传播这么广的原因 在实际的项目开发中如果不觉得使用步骤较为繁琐，代码量可以接受的话，DCL也是比较推荐的一种使用方式 注：关于DCL双重校验锁要不要加volatile关键字取决于Java版本，在jdk8中已经确保new、初始化为原子性操作，不会出现JIT导致指令重排的情况，想了解更多的朋友请点击[这里] 2.4 枚举类 public enum Singleton4 { getInstance(); public void doSomething() { //doSomething } } Java1.5以后，单例模式的实现方式终于迎来的新面孔：枚举类单例，这也是《Effective Java》作者Joshua 力荐的一种使用方式 枚举类是没有构造方法的，枚举类的创建完全由JVM内部实现，不对外开放。这样的特性也使得我们不能使用new的方式来创建枚举对象，对应的缺点就是枚举类的单例模式不是懒加载的 枚举类单例除了能保证线程安全外，还加入了新功能：防止单例模式被破坏，原因有两点： 枚举类无法被反射创建 强行使用反射创建会收到错误：java.lang.IllegalArgumentException: Cannot reflectively create enum objects 枚举类不能被反序列化 序列化的时候，仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。 同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 最后，关于枚举类还有一点需要注意：枚举类不能继承任何类，枚举类在编译后会继承自java.lang.Enum，由于Java单继承的特性导致枚举类不能再继承任何其他类，但是枚举类可以实现接口 3、破坏单例模式及防止破坏单例 正如2.4小节中提到的，除了枚举类单例外，其他的三种单例模式都可以通过使用反射来破坏在进程中的唯一性 单例类由于自身的特殊性导致无法被反射和反序列化创建，所以对象的唯一性暂时无法被破坏，但是可以修改枚举类的值 笔者这里写了一个简单的示例代码来破坏单例，感兴趣的朋友也可以自己在单元测试中试一试 @Test public void main() { testSingleton1(); testSingleton2(); testSingleton3(); } /*1.恶汉模式*/ private static void testSingleton1() { Object fromInstance = Singleton1.getInstance(); Object fromReflect = createClassWithReflect(Singleton1.class); System.out.println(fromInstance.equals(fromReflect)); } /*2.懒汉模式-静态内部类*/ private static void testSingleton2() { Object fromInstance = Singleton2.getInstance(); Object fromReflect = createClassWithReflect(Singleton2.class); System.out.println(fromInstance.equals(fromReflect)); } /*3.懒汉模式-DoubleCheckLock*/ private static void testSingleton3() { Object fromInstance = Singleton3.getInstance(); Object fromReflect = createClassWithReflect(Singleton3.class); System.out.println(fromInstance.equals(fromReflect)); } private static &lt;T&gt; T createClassWithReflect(Class&lt;T&gt; clz) { Constructor&lt;?&gt; constructor = clz.getDeclaredConstructor(); constructor.setAccessible(true); return (T) constructor.newInstance(); } 打印结果 false false false 从打印结果可以看出，除枚举类外的三种实现方式全部沦陷，都可以通过反射来创建不同的实例对象来破坏单例模式的唯一性 反射创建枚举类会受到报错信息：java.lang.IllegalArgumentException: Cannot reflectively create enum objects，笔者这里就不展示了，感兴趣的同学可以自己动手试一试 最后提一句，网上其他文章提到了使用clone方法来破坏单例，笔者认为这点不成立，因为不重写clone()方法并且不将访问修饰符改为public，使用者是无法调用clone方法来创建新的实例对象的 4、小结 至此，几种常见的单例模式实现方式都介绍完了，简单总结下：上述几种实现方式都可以在保证多线程环境下安全性；除了枚举单例之外，其他几种方式的单例模式都可以被破坏 此小节涉及到的代码在这里 三、创建型模式：工厂方法 1、模式定义 工厂方法模式又称为工厂模式，在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 工厂方法模式包含四个角色： 抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口； 具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应； 抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口； 具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。 图片来源：自己画的 2、代码示例 角色1：抽象产品类 public abstract class AbstractProduct { public abstract String getName(); } 角色2：产品实现类 public class ProductA extends AbstractProduct { @Override public String getName() { return &quot;A&quot;; } } public class ProductB extends AbstractProduct { @Override public String getName() { return &quot;B&quot;; } } 角色3：抽象工厂类 public abstract class AbstractFactory { public abstract AbstractProduct createProduct(); } 角色4：工厂实现类 public class ProductAFactory extends AbstractFactory { @Override public AbstractProduct createProduct() { return new ProductA(); } } public class ProductBFactory extends AbstractFactory { @Override public AbstractProduct createProduct() { return new ProductB(); } } 工厂方法使用示例 @Test public void main() { AbstractFactory factoryA = new ProductAFactory(); AbstractFactory factoryB = new ProductBFactory(); AbstractProduct productA = factoryA.createProduct(); AbstractProduct productB = factoryB.createProduct(); System.out.println(&quot;工厂A生产的产品名称：&quot; + productA.getName()); System.out.println(&quot;工厂B生产的产品名称：&quot; + productB.getName()); } 打印结果 工厂A生产的产品名称：A 工厂B生产的产品名称：B 3、源码锚点 从本小节开始，笔者将会对每种设计模式都以Java/Android源码举例说明，用锚点记忆法来辅助记忆；比如提起建造者模式就像到Android AlertDialog，提到观察者模式就想到OnClickListener一样 工厂模式在源码中的提现，我们可以记住Java容器类的迭代器：Iterator 为了加深记忆，我们这里简单剖析使用工厂方法迭代器的角色分工： 抽象工厂 Iterable 工厂实现 ArrayList HashMap 抽象产品 Iterator 产品实现(jdk1.8) ArrayList中的Itr类 HashMap中的EntryIterator/KeyIterator/ValueIterator类 从上面的结构来看，ArrayList和HashMap中的iterator方法其实就相当于一个工厂方法，专为new对象而生，这里iterator方法是构造并返回一个具体的迭代器 4、小结 工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性 笔者这里没有提到简单工厂，实际上，当把工厂方法的抽象工厂类删除掉，就是简单工厂模式了，所以可以把简单工厂理解为工厂方法的简化版本；笔者这里没有给出示例，想要了解更多的可以去看阿里巴巴淘系技术在知乎上的回答：简单工厂模式、工厂方法模式和抽象工厂模式有何区别 此小节涉及到的代码在这里 四、创建型模式：抽象工厂 1、模式定义 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构 抽象工厂模式同样包含四个角色： 抽象工厂用于声明生成抽象产品的方法； 具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中； 抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法； 具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。 虽然抽象工厂的角色数量和工厂方法相同，都是4个，但由于每个角色下还有其他角色，理解起来就会稍微有点费劲，这一点也可以从抽象工厂和工厂方法的UML类图看出来区别，抽象工厂明显更复杂一些 由于抽象工厂稍微有点复杂，不能再用上面的ProductA、FactoryB等无实际意义的类名来举例，为了方便理解，笔者这里使用手机组装厂来做类比，他们的角色分工如下： 抽象产品 电池组装厂 屏幕组装厂 具体产品实现 电池 比亚迪电池供应商 德赛电池供应商 屏幕 京东方屏幕供应商 LG屏幕供应商 抽象工厂 手机组装厂 具体工厂实现 华为P50的组装厂 小米10的组装厂 有了上面的角色分工结构，在下面代码示例我们就直接对号入座，这样的方式可能会方便理解 图片来源：自己画的 2、代码示例 角色1-1：抽象产品类-电池 public abstract class AbstractProductBattery { public AbstractProductBattery() { createBattery(); } public abstract String getBatteryName(); protected abstract void createBattery(); } 角色1-2：抽象产品类-屏幕 public abstract class AbstractProductScreen { public AbstractProductScreen() { createScreen(); } public abstract String getScreenName(); protected abstract void createScreen(); } 角色2-1-1：产品实现类-电池-比亚迪 public class BYDBattery extends AbstractProductBattery { @Override public String getBatteryName() { return &quot;比亚迪(BYD)&quot;; } @Override protected void createBattery() { System.out.println(&quot;加班加点生产比亚迪电池中...&quot;); } } 角色2-1-2：产品实现类-电池-德赛 public class DesayBattery extends AbstractProductBattery { @Override public String getBatteryName() { return &quot;德赛(Desay)&quot;; } @Override protected void createBattery() { System.out.println(&quot;加班加点生产德赛电池中...&quot;); } } 角色2-2-1：产品实现类-屏幕-京东方 public class BOEScreen extends AbstractProductScreen { @Override public String getScreenName() { return &quot;京东方(BOE)&quot;; } @Override protected void createScreen() { System.out.println(&quot;加班加点生产京东方屏幕中...&quot;); } } 角色2-2-2：产品实现类-屏幕-LG public class LGScreen extends AbstractProductScreen { @Override public String getScreenName() { return &quot;LG&quot;; } @Override protected void createScreen() { System.out.println(&quot;加班加点生产LG屏幕中...&quot;); } } 角色3：抽象工厂类 public abstract class AbstractPhoneFactory { protected String brand;//工厂生产的手机品牌 protected String model;//工厂生产的手机型号 protected AbstractProductScreen phoneScreen;//手机使用的屏幕 protected AbstractProductBattery phoneBattery;//使用的电池 public AbstractPhoneFactory(String brand, String model) { this.brand = brand; this.model = model; this.phoneScreen = createPhoneScreen(); this.phoneBattery = createPhoneBattery(); } public String getBrand() { return brand; } public String getModel() { return model; } public AbstractProductScreen getPhoneScreen() { return phoneScreen; } public AbstractProductBattery getPhoneBattery() { return phoneBattery; } protected abstract AbstractProductScreen createPhoneScreen(); protected abstract AbstractProductBattery createPhoneBattery(); } 角色4-1：工厂实现类-华为 public class HuaWeiPhoneFactory extends AbstractPhoneFactory { public HuaWeiPhoneFactory() { super(&quot;华为(HuaWei)&quot;, &quot;P50&quot;); } @Override protected AbstractProductScreen createPhoneScreen() { return new LGScreen();//Lg屏幕 } @Override protected AbstractProductBattery createPhoneBattery() { return new DesayBattery();//德赛的电池 } } 角色4-2：工厂实现类-小米 public class XiaoMiPhoneFactory extends AbstractPhoneFactory { public XiaoMiPhoneFactory() { super(&quot;小米(XiaoMi)&quot;, &quot;10&quot;); } @Override protected AbstractProductScreen createPhoneScreen() { return new BOEScreen();//京东方的屏幕 } @Override protected AbstractProductBattery createPhoneBattery() { return new DesayBattery();//德赛电池 } } 抽象工厂使用示例 public void main() { AbstractPhoneFactory phoneFactory1 = new HuaWeiPhoneFactory(); AbstractPhoneFactory phoneFactory2 = new XiaoMiPhoneFactory(); print(phoneFactory1); print(phoneFactory2); } private void print(AbstractPhoneFactory phoneFactory) { System.out.println(&quot;产线品牌：&quot; + phoneFactory.getBrand() + &quot;,生产型号：&quot; + phoneFactory.getModel() + &quot;,电池厂商：&quot; + phoneFactory.getPhoneBattery().getBatteryName() + &quot;,屏幕厂商：&quot; + phoneFactory.getPhoneScreen().getScreenName()); } 打印结果 产线品牌：华为(HuaWei),生产型号：P50,电池厂商：德赛(Desay),屏幕厂商：LG 产线品牌：小米(XiaoMi),生产型号：10,电池厂商：德赛(Desay),屏幕厂商：京东方(BOE) 从打印结果可以看到，小米和华为都是用德赛的电池，但屏幕供应商用的不是同一家 若我们想增加一个产品线，只需要想小米和华为工厂一样，继承/实现AbstractPhoneFactory抽象工厂类即可，每个零件来自哪个供应商可以随便选择；相同的，我们也可以增加供应商来丰富我们的产品，这就是抽象工厂模式带来的好处 3、源码锚点 抽象工厂方法模式在Android源码中的实现相对来说是比较少的，在《Android 源码设计模式解析与实战》一书中提到是Android底层对MediaPlayer的创建是可以看作为抽象工厂，这一块代码笔者不熟悉，为了防止误人子弟，抽象工厂模式的源码这里笔者就不再举例，对抽象工厂源码体现感兴趣的可以自行查找其他资料 4、小结 抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。 笔者个人总结的抽象工厂和工厂方法不同点：抽象工厂模式拥有多个抽象产品类，也就是本示例的电池抽象类和屏幕抽象类 抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 此小节涉及到的代码在这里 五、创建型模式：建造者模式 1、模式定义 建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节 下面我们以Android中创建一个弹窗类来举例，该类有以下几个特性： 弹窗类有左右两个按钮，标题和内容共四个属性，弹窗类提供Builder类来组装自己 一旦弹窗被创建，左右两个按钮文字不希望被更改，也就说Dialog本身不提供修改左右按钮的方法 Builder提供不同的创建方法，比如：创建左右两个按钮的弹窗、只有确认按钮的弹窗，创建过程由Builder来管理 建造者模式理解起来也比较容易，我们接下来康康5.2中的代码示例 2、代码示例 public class CommonDialog { private Params mParams; private CommonDialog(Params params) { this.mParams = params; } public void setTitleText(String title) { mParams.titleText = title; } public void setMessageText(String message) { mParams.messageText = message; } public void show() { //set view... } public static class Builder { protected Params mParams = new Params(); public Builder setTitleText(String title) { mParams.titleText = title; return this; } public Builder setMessageText(String message) { mParams.messageText = message; return this; } public Builder setConfirmText(String confirm) { mParams.confirmText = confirm; return this; } public Builder setCancelText(String cancel) { mParams.cancelText = cancel; return this; } public CommonDialog create() { //create normal dialog logic return new CommonDialog(mParams); } public CommonDialog createOnlyConfirm() { //create only have confirm btn dialog logic mParams.cancelText = null; return new CommonDialog(mParams); } } private static class Params { /*public to anyone*/ private String titleText; private String messageText; /*private field , runtime not change*/ private String confirmText; private String cancelText; } } 建造者模式使用示例 public void main() { CommonDialog.Builder builder = new CommonDialog.Builder(); builder.setMessageText(&quot;will you marry me&quot;); builder.setConfirmText(&quot;yes&quot;); builder.setCancelText(&quot;no&quot;); CommonDialog normalDialog = builder.create();//创建普通对话框 normalDialog.show(); builder.setMessageText(&quot;are you free now?&quot;); builder.setConfirmText(&quot;yes&quot;); CommonDialog onlyConfirmDialog = builder.createOnlyConfirm();//创建只有确认按钮的对话框 onlyConfirmDialog.show(); onlyConfirmDialog.setMessageText(&quot;Let's go to the movies?&quot;); onlyConfirmDialog.show(); } 看使用示例就能明白，当在创建Dialog过程中，可以随意的更改任何属性；一旦创建了Dialog实例对象，可修改的属性就不多了。基于此，笔者总结一下Builder模式两大特点：限制、封装 3、源码锚点 建造者模式在Android源码中的实现：AlertDialog 4、小结 建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程 当然，建造者模式也是有缺点的，其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，相对应的代码量也会增加不少；如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 建造者模式适用情况包括： 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性； 需要生成的产品对象的属性相互依赖，需要指定其生成顺序； 对象的创建过程独立于创建该对象的类； 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。 此小节涉及到的代码在这里 六、总结 本文介绍了常见的几种创建型设计模式，简单总结一下： 单例模式：保证一个类仅有一个实例，常见实现方式有 饿汉式：若被提前加载会占用内存 懒汉式-静态内部类 懒汉式-双重校验锁DCL 枚举类单例：由虚拟机初始化，防止破坏唯一性 工厂方法模式，通过工厂子类来确定究竟应该实例化哪一个具体产品类 简单工厂：工厂方法的简化模式 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类 建造者模式：将复杂对象的构造与它的表示分开，这样可以在相同的构造过程中创建不同的表示形式。 由于笔者水平有限，文中难免会出现遗漏甚至错误的地方，若您发现任何问题或者有任何建议请在这里提交Issue，感谢 全文完 七、参考资料 图说设计模式 《Android 源码设计模式解析与实战》-何红辉 / 关爱民 知乎：简单工厂模式、工厂方法模式和抽象工厂模式有何区别 ","link":"https://yibaoshan.github.io/post/design-pattern-creational/"},{"title":"Hello","content":"👏 欢迎来到我的博客 这是我第一个静态博客，主要用它来记录自己的成长，同时也会分享一些我的生活 博主坐标杭州，双鱼座，ENTJ，爱好烹饪、摄影，乐于接受新鲜事物，欢迎扫码面基 (*▽*)（二维码在文章底部） 一、我的书单 计算机类 《剑指Offer》- 何海涛 ✅ 《汇编语言（第4版）》- 王爽 ✅ 《Linux内核完全注释》- 赵炯 ⏳ 《Linux内核完全剖析》- 赵炯 ⏳ 《Android 开发高手课》- 张绍文 ✅ 《Android开发艺术探索》- 任玉刚 ✅ 《深入理解 Android : 卷I》- 邓凡平 ✅ 《深入理解 Android : 卷II》- 邓凡平 ✅ 《深入理解 Android : 卷III》- 张大伟 ✅ 《穿越计算机的迷雾（第2版）》- 李忠 ✅ 《Android系统源代码情景分析》- 罗升阳 ✅ 《深入理解Android内核设计思想》- 林学森 ✅ 《Java编程思想（第4版）》- [美] Bruce Eckel ✅ 《深入理解 Android : Java虚拟机ART》- 邓凡平 ✅ 《Android 源码设计模式解析与实战》- 何红辉 / 关爱民 ✅ 《深入理解Linux网络： 修炼底层内功，掌握高性能原理》- 张彦飞 ⏳ 社会科学类 《详谈：左晖》- 李翔 ✅ 《人间修炼指南》- 半佛仙人 ✅ 《金字塔原理》- [美]芭芭拉•明托 ⏳ 《疯人说：精神病院医生手记 》- 穆戈 ✅ 《经济学原理(第7版)》- 曼昆 (N.Gregory Mankiw) ✅ 二、技术文章 Android 图形系统 Android图形系统（一）硬件篇：LCD和OLED怎么选？ Android图形系统（二）驱动篇：垂直同步到底要不要开？ Android图形系统（三）系统篇：渲染/合成的底层原理浅析 Android图形系统（四）应用篇：自定义View/ViewGroup详解 Android图形系统（五）番外篇：触摸事件详解 Android 系统组件 Android组件系列：Handler机制详解 Android组件系列：再谈Handler机制（Native篇） Android组件系列：LocalBroadcastManager源码解析 Android 设计模式 从Android源码角度谈设计模式（一）：创建型模式 从Android源码角度谈设计模式（二）：结构型模式 从Android源码角度谈设计模式（三）：行为型模式 闲聊系列 为什么会发生 Fragment not attached to Activity 异常？ 读书笔记：穿越计算机的迷雾（上） 读书笔记：穿越计算机的迷雾（下） 读书笔记：十天学会51单片机 其他(工具/效率) 给马总：斐讯K2-老毛子固件翻墙教程 三、工作和生活 个人成长与思考 双月记录（2023） 易保山 2023.1~2 双月记录 易保山 2023.3~4 双月记录 易保山 2023.5~6 双月记录 易保山 2023.7~8 双月记录 易保山 2023.9~10 双月记录 易保山 2023.11~12 双月记录 本站主题不支持目录功能，技术文章建议跳转到 稀土掘金 阅读。 本站使用 GitHub Pages 搭建，偶尔会存在无法访问或加载时间过长的情况，请耐心等待(╹▽╹)。 ","link":"https://yibaoshan.github.io/post/hello/"}]}