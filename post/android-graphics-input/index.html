<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Android图形系统（五）番外篇：触摸事件详解 | 易保山</title>

<link rel="shortcut icon" href="https://yibaoshan.github.io//favicon.ico?v=1699367045276">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://yibaoshan.github.io//styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


<script async src="https://www.googletagmanager.com/gtag/js?id=G-JR8EKM67KY"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', 'G-JR8EKM67KY');
</script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
        <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script> 
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            易保山
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1699367045276"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Android图形系统（五）番外篇：触摸事件详解
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2022-11-29 ·
                    </time>
                    
                        <a href="https://yibaoshan.github.io/tag/Android-Graphics/" class="post-tags">
                            # Android图形系统
                        </a>
                    
                </div>
                <div class="post-content">
                    <blockquote>
<p><em><a href="https://juejin.cn/post/7171130176158302245">点击跳转到掘金阅读</a></em></p>
</blockquote>
<p>Android 是一个有用户界面（<em>GUI</em>）的操作系统，在它诞生之初，就是为带有触摸屏的手持设备准备的。作为提供给用户最重要的交互方式之一，了解触摸系统是怎么工作的，对于实际的项目开发有着非常大的帮助</p>
<p>本篇是图形系列的第五篇文章，在之前的几篇文章中，我们分别了解了 Android 系统<a href="https://juejin.cn/post/7132777622487957517">[渲染/合成的底层原理]</a>和<a href="https://juejin.cn/post/7140332948485570596">[自定义 View / ViewGroup 的流程]</a></p>
<p>今天我们来聊聊图形系统中，另一个老生常谈的话题：<strong>事件分发</strong></p>
<p>和以往相比，今天的文章会稍微有那么一点点不一样</p>
<p>我们会从认识硬件驱动开始，自底向上，一步步的来了解，事件是怎么到达的系统内核，内核又是怎么传递到应用，以及应用最终是如何消费掉事件的</p>
<p>废话不多说，我们直接进入正题，let's go</p>
<blockquote>
<p><em>前排提醒：全文 1.5w 字，建议阅读时长 30 分钟</em></p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be3079e548ac414c883c88b64ae38ca6~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_overview.png" loading="lazy"></figure>
<h1 id="一-触摸事件的起源linux-kernel">一、触摸事件的起源（Linux Kernel）</h1>
<p>Android 输入事件的类型，和分发的流程都比较复杂，除了触摸事件外，系统还有来自<code>鼠标</code>、<code>键盘</code>、<code>音量键</code>、<code>电源键</code>等其他 Input 设备的事件需要处理</p>
<p>我们日常开发接触比较多的是 ‘触摸事件’，因此，本文主要讨论的是 ‘触摸事件’ 的分发流程，其他类型的输入事件顺带会提一嘴，不是本文的重点</p>
<p>本文一共分为三大部分：</p>
<p>第一部分介绍 ‘<code>触摸事件的起源</code>’ ，主要讲的是驱动上报原始事件，内核解析原始事件并保存到设备文件中，以供 Framework 读取分发</p>
<p>第二部分介绍 ‘<code>触摸事件的传递</code>’ ，主要讲的是 InputManagerService 怎么把事件传递到应用进程，并分发给目标 Window</p>
<p>第三部分介绍 ‘<code>触摸事件的消费</code>’ ，这是我们应用开发者最熟悉的事件分发/拦截的过程，主要讲的是 ViewGroup / View 的几个关键方法以及使用场景</p>
<p>在文章的开头，我们先来聊聊第一部分的内容，触摸事件的起源</p>
<h2 id="从硬件到内核">从硬件到内核</h2>
<p>在<a href="https://mp.weixin.qq.com/s/JeGPyknzc0G_TCQNHZD3AQ">《当我们点击“微信”应用后，它是怎么显示出来的？》</a>这篇文章中，为了搞清楚 Android 设备的绘图硬件是什么，我们拆了一台 小米11 手机</p>
<p>今天，我们继续来拆小米</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16fb8b07a3be49dc93c21796f2859b2b~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_mi10.png" loading="lazy"></figure>
<p><em>图片来源：<a href="https://www.laoyaoba.com/n/748691">【集微拆评】小米10拆解：内部布局与iPhone相似，1亿像素主摄吸睛</a></em></p>
<p>如上图，这是拆解后 小米10 的内部布局，图中左边黄色箭头所指的部分，是触摸屏的<code>触控芯片</code></p>
<p>米10 <code>触控芯片</code>使用的是，来自意法半导体的 &quot;<code>FJABH</code>&quot;，这块芯片是用来干嘛的呢？</p>
<p>用来和 CPU 进行通信的</p>
<figure data-type="image" tabindex="3"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1fcf2e034e142e9a1c5ea0755214a6a~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_ic_touch.png" loading="lazy"></figure>
<p><em>图片是重绘版，参考自：https://blog.csdn.net/qq_39797956/article/details/118863217</em></p>
<p>我们知道，当我们按下触摸屏后，屏幕的电压/电流大小会发生变化（<em>不展开讨论触摸屏工作原理</em>）</p>
<p>变化的电压/电流会被图中间的<code>触控 IC </code>捕获，接着计算出触摸位置的坐标值，通过<code>I²C</code>总线（<em>如上图</em>）发送到主板上的 CPU</p>
<p><a href="https://elixir.bootlin.com/linux/v4.4.1/source/drivers/i2c"> I²C </a>是硬件之间常用的一种通信协议，它规定了什么表示起始、停止、应答和非应答等一系列信号</p>
<p>当然，作为应用开发，我们无需关心他们的通信细节</p>
<p>我们只需要知道： &quot;<strong>一旦触摸屏的信号发生变化，<code>触控芯片</code>就能通过 <code>I²C</code> 总线通知到 CPU</strong> &quot;。了解这一点就够了</p>
<p>好了，现在触摸信号已经能被 CPU 读取了，接下来我们看 CPU ，也就是操作系统如何处理触摸信号</p>
<h2 id="内核创建设备文件">内核创建设备文件</h2>
<p>我们都知道，Google 使用 Linux 作为 Android 系统的内核，管理着主板上的 <code>内存</code>、<code>网卡</code>、<code>硬盘</code> 等硬件设备，其中也包括 <code>CPU</code></p>
<p>在上一小节中，触摸屏已经和 CPU 建立了通信。也就是说，操作系统可以读取触摸屏发送过来的信号了</p>
<p>接下来的工作重点分为两个部分，<strong>一是制定触摸屏具体的上报规则；二是想办法把设备发生的事件报告给应用程序</strong></p>
<p>先来看设备的上报规则，我们以键盘事件举例，同样都是按下 '<code>A</code>' 按键</p>
<blockquote>
<p><em><code>达尔优</code></em> 键盘上报的是：<code>0010</code></p>
<p><em><code>罗技</code></em> 键盘上报的是：<code>0001</code></p>
</blockquote>
<p>同一个按键事件，两个键盘厂商上报的按键值却不相同，这显然是不行的。</p>
<p>所以，只有上一小节的通信规则（<em>I²C</em>）还不够，我们还需要制定一个内容规则，来规范各个厂家发送的数据内容</p>
<p>说到输入规范，这就不能不提 Linux 的 Input 子系统了</p>
<p>在 2001 年发布的 <a href="https://elixir.bootlin.com/linux/2.4.0/source/drivers/input"><em>[2.4.0</em>]</a> 版本，Linux 首次加入了 Input 子系统的代码，为的就是将输入设备的共性抽象出来，制定统一的输入规则</p>
<p>首发版本只支持 <code>手柄</code>、<code>鼠标</code> 和 <code>键盘</code> 这三种硬件，在随后 2002 年发布的 <a href="https://elixir.bootlin.com/linux/v2.5.25/source/drivers/input"><em>[2.5.25</em>]</a> 版本中，加入了对 <code>触摸屏</code> 的支持</p>
<p>这样一来，厂商只需要按照 Linux 制定的规范，来上报<code>按键值</code>、<code>屏幕坐标</code>等信息即可，上报规则的问题就解决了</p>
<p>除了规范输入内容，Input 子系统还为应用程序提供了 <code>操作/读取</code> 输入设备的接口，来看框架图：</p>
<figure data-type="image" tabindex="4"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0b059bcf09b4b8d9af8ebdd5468968d~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_linux_input_system.png" loading="lazy"></figure>
<p><em>图片来源：自己画的</em></p>
<p>如图，Input 子系统分为三层：</p>
<ul>
<li>
<p><strong>最下层：输入设备驱动层，<code>drivers/input/xxx</code>，这里就是各大厂商需要遵循的协议规范，向内核层报告输入的内容</strong></p>
</li>
<li>
<p><strong>中间层：输入核心层，<code>input.c</code> 属于这一层。这是 Linux 核心逻辑，用来管理设备添加、卸载等操作，事件提供给应用前的准备工作</strong></p>
</li>
<li>
<p><strong>最上层：输入事件驱动层，到这里硬件驱动已经抽象为设备文件了，对应 <code>/dev/input/xxx</code> ，硬件驱动发送的数据就保存在该路径下的各个设备文件中，等待应用读取</strong></p>
</li>
</ul>
<p>最下面的 Drivers 层，是 Linux 平台对各种输入设备的规范，各大厂商都需要去遵循该协议，否则 Linux 内核无法识别，设备也就无法正常工作</p>
<p>然后是中间的核心层，它是输入设备驱动的管理层，在输入框架中起着承上启下的作用：<strong>向下提供驱动层的接口，向上提供事件处理层的接口</strong></p>
<p>我们来看一眼 input.c 中的几个关键方法，也就大概知道它提供了哪些功能</p>
<pre><code class="language-c">/drivers/input/input.c
class input { //Linux input 框架的核心层，为驱动层提供设备注册和操作接口

  	/* 设备注册 */
    int input_register_device(input_dev *dev); // 注册一个 input 设备到内核
    void input_unregister_device(input_dev *dev); // 从内核注销掉一个 input 设备

  	/* 设备连接 */
    int input_attach_handler(input_dev *dev, input_handler *handler);
  	void input_disconnect_device(input_dev *dev);
  
  	/* 事件上报 */
  	void input_handle_event(input_dev *dev, type, code, value);
  
  	/* 应用程序数据读取 */
  	int input_event_to_user(input_dev *dev, type, code, value);

}
</code></pre>
<p>从代码来看，核心层负责 <code>设备的注册</code>、<code>设备的连接</code>、<code>事件上报</code> 和 <code>数据读取</code> 这几件事，具体的实现逻辑我们这里不展开讨论，太长了。</p>
<p>在 Input 子系统的最上层（Handlers），事件驱动层负责的是，<strong>为用户访问提供接口，将硬件驱动层发送的消息报告给用户</strong></p>
<p>我们可以在 <code>/dev/input/xxx</code> 找到所有已加载成功的输入设备，它们就是事件驱动层创建的设备文件</p>
<figure data-type="image" tabindex="5"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a98094cfb2004478adf3c7a4f3b67b60~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_pixel3_devices.jpg" loading="lazy"></figure>
<p><em>图片来源：自己截的</em></p>
<p>如图所示，我手里的 Pixel 3 在 <code>/dev/input/</code> 这个路径下，发现了4个输入设备，从 <code>event0</code> 到 <code>event3</code></p>
<p>我们可以用 ' <code>cat /proc/bus/input/devices</code> ' 命令，查看每个输入设备的信息，我这台手机 <code>event2</code> 节点是触摸屏的设备文件（<em>' <code>name = fts</code> ' 表示的触控驱动厂商是 '<code>敦泰</code>'</em>）</p>
<p>接着，我们还可以用 '<code>getevent</code>' 命令打开这个设备文件，获取它发送的原始数据</p>
<figure data-type="image" tabindex="6"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69f3437a220d46e29090b0cac4d5c27d~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_pixel3_getevent.GIF" loading="lazy"></figure>
<p><em>图片来源：自己录的</em></p>
<p>你看，当我们滑动屏幕时，终端窗口会不停的打印来自 <code>event2</code> 的触摸事件消息</p>
<p>好，现在触摸事件已经能被应用程序读取了，我们来简单总结下第一部分 ‘触摸事件的起源’ 的内容：</p>
<p>首先，按下触摸屏后，<code>触控芯片</code>捕获到电压/电流的变化，计算出位置坐标后，通过<code> I²C</code> 总线汇报给 CPU</p>
<p>接着，我们需要统一通信内容的规则，在 Linux 平台下，触控芯片需要实现 <code>input.c</code> 协议，事件按照规定的协议上报给内核系统</p>
<p>最后，等到设备开机，内核加载触摸屏驱动，再然后是设备的<code>注册/连接/上报</code>的过程</p>
<p>到这里，内核已经为我们收集好触摸屏的输入事件，并存放在了 <code>eventX</code> 设备文件中，Linux Input 子系统的任务已经完成</p>
<p>接下来我们看 Android 系统的框架层（Framework）是如何处理触摸事件的</p>
<h1 id="二-触摸事件的传递android-framework">二、触摸事件的传递（Android Framework）</h1>
<p>上回书说到，触摸屏上报的事件已经保存到 <code>/dev/input/xxx</code> 设备文件中，那么系统接下来的任务是：</p>
<p>读取触摸事件，并封装成 <code>MotionEvent</code> / <code>KeyEvent</code> 对象，最后分发给正在运行的 APP 使用</p>
<p>”<strong>读取</strong>“ 和 “<strong>分发</strong>” ，是 Android Framework 的主线任务</p>
<p>在接下来的章节中，我们将主要围绕着这两件事展开</p>
<blockquote>
<p>ps：本章节的 '<code>事件分发</code>' 探讨的是，如何将触摸事件从设备文件传递到 APP 进程，和 View 的事件分发不是一回事儿，注意别搞混了</p>
</blockquote>
<h2 id="初识-inputmanagerservice">初识 InputManagerService</h2>
<p>我们都知道，在 Framework 中，输入事件是由 InputManagerService（后续简称IMS） 来管理</p>
<p>我们又知道，InputManagerService 是 Java 层代码，不可能直接调用到 Linux 内核层的 Input 框架来获取输入事件</p>
<p>因此，IMS 必然需要 native 层的支持，才能实现对事件的读取与分发</p>
<p>实际的 InputManagerService 实现一共分为三层</p>
<ol>
<li><strong>native 层，这是 IMS 的核心层，负责 <code>读取/分发</code> 事件，<code>EventHub.cpp</code>、<code>InputReader.cpp</code>、<code>InputDispatcher.cpp</code> 三员大将都在这</strong></li>
<li><strong>jni 层，主要是对 natvie 做转发，另外负责创建对象啥的，不怎么需要关注</strong></li>
<li><strong>Java 层，主要负责通信部分，和 WMS 同步窗口数据啦，和 APP 跨进程通信啦等等</strong></li>
</ol>
<p>在这其中，只有 native 层稍微有那么一点点复杂，因为数据的读取和分发都发生在 native 层</p>
<p>好，接下来，我们来认识 native 层的主力人员</p>
<p>注意，我们本小节只关注 native 中各个角色有哪些方法功能，做了哪些事情</p>
<p>至于对象什么时候创建，运行在哪个进程，哪个线程，这个后面会讲到，不是本小节关注的重点</p>
<h3 id="1-eventhub">1、EventHub</h3>
<p>EventHub 的作用是监听、读取 <code>/dev/input</code> 目录下产生的新事件，并封装成 <code>RawEvent</code> 结构体供其他人使用</p>
<p>文件在 frameworks/native/services/inputflinger/EventHub.cpp</p>
<p>我们来看 EventHub 中的关键方法</p>
<pre><code class="language-c++">//frameworks/native/services/inputflinger/EventHub.cpp
class EventHub {

    EventHub::EventHub(void)  {
        mEpollFd = epoll_create(EPOLL_SIZE_HINT); // 创建 epoll，用于监听设备文件是否有可读事件
        mINotifyFd = inotify_init(); // 创建 inotify ，用于监听文件系统是否变化，有变化说明发生设备插拔
    }

    size_t EventHub::getEvents( timeoutMillis, buffer, bufferSize) {
        //getEvents() 是 IMS 的核心，该方法一共做了两件事
        // 1. 监听设备插拔动作，执行对应的设备的打开/卸载操作，并生成 RawEvent 结构通知调用者
        // 2. 监听输入设备文件的事件变化
        //如果没有任何事件发生，调用 epoll_wait() 函数执行等待
        return event - buffer; // 返回读取到的事件数量
    }


}
</code></pre>
<p>EventHub 在初始化时，会创建 <code>mEpollFd</code> 和 <code>mINotifyFd</code> 两个 Fd，利用 <code>INotify</code> 机制监听设备增删事件，利用 <code>Epoll</code> 监听设备文件读写状态变化</p>
<p>然后是 <code>getEvents()</code> 方法，这个方法用来获取当前的设备事件，包括设备数量变化，和设备上报的事件，是 IMS 获取消息的 “核心方法”</p>
<p>如果没有任何事件发生，<code>getEvents()</code> 会发生阻塞，直到有事件发生才返回</p>
<p>EventHub 整个过程如下图</p>
<figure data-type="image" tabindex="7"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9ccef4f808e408aad0affcb835bf2fa~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_native_1.png" loading="lazy"></figure>
<p><em>图片来源：自己画的</em></p>
<h3 id="2-inputreader">2、InputReader</h3>
<p>从类的命名就能看出来，InputReader 的职责是读取输入消息</p>
<p>不过，它可不是只会读取事件，拿到原始事件以后，还需要解析事件，拆解为<code>按键</code>、<code>触摸屏</code>、<code>鼠标</code>等，根据不同的输入，封装成不同的对象，提交到消息队列等待分发</p>
<p>所以，原始事件的解析、转换，最后生成 <code>KeyEvent</code>、<code>MotionEvent</code> 对象，才是 InputReader 的主要工作</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputReader.cpp
class InputReader {

    class InputReaderThread : Thread { //内部类

        /*InputReaderThread 线程启动后，循环将不断地执行 InputReader#loopOnce()函数*/
        bool InputReaderThread::threadLoop() {
            mReader-&gt;loopOnce();
            return true;
        }
    }

    void InputReader::loopOnce(); // 核心方法，负责读取事件，解析事件
}
</code></pre>
<p>InputReader 类的核心方法是 <code>InputReader#loopOnce()</code> ，它负责读取事件和解析事件</p>
<p><code>loopOnce()</code> 方法被 InputReaderThread 线程的 <code>threadLoop()</code> 所调用，InputReaderThread 是 InputReader 的内部线程类</p>
<p>和 Java 不同，在 C++ 中，我们只需要将 <code>threadLoop()</code> 返回值设置为 true，当 InputReaderThread 线程启动后， 该方法就会被循环调用，不用手动写 <code>while(true)</code></p>
<p>InputReaderThread 线程启动时机我们后面会讲到，先回过头来看 <code>InputReader#loopOnce()</code> 的工作</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputReader.cpp
class InputReader {
  
    // 读取事件，解析事件
    void InputReader::loopOnce() {
        int count = mEventHub-&gt;getEvents(); // 读消息，有消息返回，没消息阻塞到 epoll()。由于事件分发需要时间，所以单次读取的事件可能是多个
        if(count) processEventsLocked();//解析原始事件、提交到队列等待分发
    }
}
</code></pre>
<p>关键代码只有两行</p>
<p>第一行是调用了 <code>EventHub#getEvents()</code> 获取事件，我们在上一节已经介绍过这个方法了，有消息返回，没消息阻塞到 <code>epoll()</code></p>
<p>并且，因为执行事件分发需要时间，在上一次分发还没有执行结束之前，如果多个设备都发生了事件，或者一个设备发送了多次事件，都会造成数据的积压，<code>getEvents()</code> 返回的事件数量可能是多条</p>
<p>第二行代码 <code>processEventsLocked()</code> 是获取到事件以后，对原始事件进行解析，然后提交到队列等待分发</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputReader.cpp
class InputReader {

    void InputReader::processEventsLocked(rawEvents, count) {
        // 遍历所有事件，解析、分发
        for (const RawEvent* rawEvent = rawEvents; count;) {
            int32_t type = rawEvent-&gt;type; // 获取事件类型
            switch (type){ // 源码不包含此 switch 逻辑，这是 InputDevice 中的内容，为了方便理解我才搬了过来
                case EV_KEY; // 按键类型的事件。能够上报这类事件的设备有键盘、鼠标、手柄、手写板等一切拥有按钮的设备（包括手机上的实体按键）
                case EV_ABS; // 绝对坐标类型的事件。这类事件描述了在空间中的一个点，触控板、触摸屏等使用绝对坐标的输入设备可以上报这类事件
                case EV_REL; // 相对坐标类型的事件。这类事件描述了事件在空间中相对于上次事件的偏移量。鼠标、轨迹球等基于游标指针的设备可以上报此类事件
                case EV_SW; // 开关类型的事件。这类事件描述了若干固定状态之间的切换。手机上的静音模式开关按钮、模式切换拨盘等设备可以上报此类事件
                ...
            }
            // 我们只专注 touch 触摸事件
            dispatchTouches(when, policyFlags);
        }
    }

    void dispatchTouches(){
        // 判断是否只是单指事件，或是多指触摸等等等
        // 解析完成后，调用 dispatchMotion() 分发
        dispatchMotion();
    }

    void dispatchMotion(){
        // 最终生成 NotifyMotionArgs 结构，交给 InputDispatcher 执行最后的分发
        NotifyMotionArgs args;
        InputDispatcher::notifyMotion(args);//提交到 InputDispatcher
    }

}
</code></pre>
<blockquote>
<p>ps：为了方便理解，我把其他分支整合到主方法来，中间还省略了许多代码。所以建议不要对照源码看这篇文章，不然你可能会因为找不到某个方法回来骂我的~</p>
</blockquote>
<p>解析事件的业务逻辑几乎都放在了 <code>processEventsLocked()</code> 方法</p>
<p>在 <code>processEventsLocked()</code> 方法中，首先遍历事件集合，根据不同的事件类型，调用不同的解析方法</p>
<p>我们只专注 touch 触摸事件，也就是 <code>dispatchTouches()</code></p>
<p>在 <code>dispatchTouches()</code> 方法中，根据触摸点信息来决定，是单指还是多指事件</p>
<p>解析完成后，调用 <code>dispatchMotion()</code> 生成 <code>NotifyMotionArgs</code> 对象，通知 <code>InputDispatcher#notifyMotion()</code> 方法</p>
<p>当 <code>InputDispatcher#notifyMotion()</code> 方法被调用，也就代表着，一次读取事件，解析事件的过程就结束了</p>
<p>接下来就看事件是怎么分发的了，InputReader 整个过程如下图</p>
<figure data-type="image" tabindex="8"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed45d0d9149840debc41d52d337d16ff~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_native_2.png" loading="lazy"></figure>
<p><em>图片来源：自己画的</em></p>
<h3 id="3-inputdispatcher">3、InputDispatcher</h3>
<p>接下来的 InputDispatcher 应该不用再介绍了，就是用来分发输入事件的</p>
<p>上一小节结束时放的图片，左边的 InputReader 向中间的 EventQueue 队列提交了事件消息，我先来解释一下这是什么时候发生的</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputDispatcher.cpp
class InputDispatcher {

    void notifyMotion(const NotifyMotionArgs* args) {
        MotionEntry* newEntry = new MotionEntry(args);//封装成entry
        enqueueInboundEventLocked(newEntry);//入列一个节点，等待分发被执行，逻辑在 dispatchOnce()
    }

}
</code></pre>
<p>呐，看代码</p>
<p>上一小节最后一行调用的 <code>InputDispatcher#notifyMotion()</code> 方法，作用就是把事件消息提交到消息队列，等待分发</p>
<p>好，尾收完了我们继续来看 InputDispatcher 类</p>
<p>到了 InputDispatcher 这里，原始的输入事件已经被封装成 <code>Key</code> 、<code>Motion</code> 等对象，InputDispatcher 的任务是：找到合适的 Window，并把数据传递过去</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputDispatcher.cpp
class InputDispatcher {

    class InputDispatcherThread : Thread {

        bool InputDispatcherThread::threadLoop() {
            mDispatcher-&gt;dispatchOnce();
            return true;
        }
    }

    void dispatchOnce() {
        if(!queue.isEmpty()) dispatchOnceInnerLocked();//有消息就执行分发
    }

}
</code></pre>
<p>首先来看 InputDispatcher 的 <code>dispatchOnce()</code> 主方法，和 InputReader 设计思路相同，InputDispatcher 也是内部有个线程类，然后循环调用 <code>dispatchOnce()</code> 执行分发</p>
<p>如果消息队列中有消息，调用 <code>dispatchOnceInnerLocked()</code> 执行分发</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputDispatcher.cpp
class InputDispatcher {

    void dispatchOnceInnerLocked() {
        mPendingEvent = queue.dequeue(); // 从派发队列取出一个事件，简略写法
        switch (mPendingEvent-&gt;type) { // 判断消息的类型：配置更改、插拔消息、key事件、触摸事件等等
            case EventEntry::TYPE_MOTION:
                dispatchMotionLocked(); // 我们只专注 触摸事件
        }
    }

    void dispatchMotionLocked() {
        int32_t injectionResult = findTouchedWindowTargetsLocked(); // 为 Motion 事件寻找合适的目标窗口
        if (injectionResult) dispatchEventLocked(); // 如果成功地找到了可以接收事件的目标窗口，则通过dispatchEventLocked()函数完成实际的派发工作
    }

}
</code></pre>
<p>负责分发的 <code>dispatchOnceInnerLocked()</code> 方法需要处理不同输入类型的事件，我们这里还是只关注触摸消息</p>
<p>如果是触摸事件，那么触摸消息的分发是由 <code>dispatchMotionLocked()</code> 方法来完成的</p>
<p><code>dispatchMotionLocked()</code> 触摸消息的分发，分为两步执行：</p>
<p><strong>第一步，为 <code>Motion</code> 事件寻找合适的目标窗口，这个任务交给 <code>findTouchedWindowTargetsLocked()</code> 函数去完成</strong></p>
<p><strong>第二步，如果成功地找到了可以接收事件的目标窗口，交给 <code>dispatchEventLocked()</code> 函数完成实际的派发工作</strong></p>
<p>接下来我们来看，<code>findTouchedWindowTargetsLocked()</code> 和 <code>dispatchEventLocked()</code> 这两个方法的实现</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputDispatcher.cpp
class InputDispatcher {

    int findTouchedWindowTargetsLocked(){
        size_t numWindows = mWindowHandles.size(); // 获取窗口集合
        for (size_t i = 0; i &lt; numWindows; i++);//从前向后遍历所有的window以找出触摸的window，将满足条件的放入inputTargets，没找到返回第一个前台window
    }
  
  	// 合适的目标窗口被确定下来之后，便可以开始将实际的事件发送给窗口了
    void dispatchEventLocked(Vector&lt;InputTarget&gt;&amp; inputTargets) {
        InputChannel channel = inputTarget.inputChannel;//删减过的流程
        channel-&gt;sendMessage(&amp;msg);//给能够被触摸的window发送跨进程消息
    }

}
</code></pre>
<p><code>findTouchedWindowTargetsLocked()</code> 方法的主要逻辑，是根据窗口的点击区域与事件发生的坐标点选取合适的目标窗口</p>
<p>代码稍微有点长，这里就不展开讨论了，感兴趣的朋友可以阅读<a href="https://xianzhu21.space/developer/window_touchable_region/">《Window Touchable Region》</a>这篇文章</p>
<p>再来看负责分发的 <code>dispatchEventLocked()</code> 方法，代码实现也很简单，根据窗口查找该窗口对应的 <code>channel</code> ，然后通过 <code>channel</code> 跨进程把事件传递到 APP</p>
<p>到这里，InputDispatcher 所有的分发工作就全部结束了，整个过程如下图</p>
<figure data-type="image" tabindex="9"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4f6c593f19e49758181f137ac9164e4~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_native_3.png" loading="lazy"></figure>
<p><em>图片来源：自己画的</em></p>
<p>哎， 还没完，回头来看负责分发触摸消息的 <code>InputDispatcher#dispatchMotionLocked()</code> 函数</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputDispatcher.cpp
class InputDispatcher {

    void dispatchMotionLocked() {
        int32_t injectionResult = findTouchedWindowTargetsLocked(); // 为 Motion 事件寻找合适的目标窗口
        if (injectionResult) dispatchEventLocked(); // 如果成功地找到了可以接收事件的目标窗口，则通过dispatchEventLocked()函数完成实际的派发工作
    }
  
    int findTouchedWindowTargetsLocked(){
        size_t numWindows = mWindowHandles.size(); // 获取窗口集合
        for (size_t i = 0; i &lt; numWindows; i++)
        ...
    }

    void dispatchEventLocked(Vector&lt;InputTarget&gt;&amp; inputTargets) {
        InputChannel channel = inputTarget.inputChannel;
        channel-&gt;sendMessage(&amp;msg);//给能够被触摸的window发送跨进程消息
    }

}
</code></pre>
<p>再看一遍源码，我们来思考两个问题 🤔</p>
<ol>
<li>
<p><strong>负责查找窗口的 <code>findTouchedWindowTargetsLocked()</code> 方法中，<code>mWindowHandles</code> 所持有的窗口集合，是从哪里来的？</strong></p>
</li>
<li>
<p><strong>负责通信的 <code>dispatchEventLocked()</code> 方法中，InputChannel 是什么？IMS 是什么时候和 APP 建立通信的？</strong></p>
</li>
</ol>
<p>回想一下，在 InputDispatcher 之前，不管是 EventHub ，还是 InputReader ，我们一直都是在和 Linux 内核打交道，读取事件、解析事件啥的</p>
<p>但到了 InputDispatcher 这里，突然和应用程序产生了联系</p>
<p><strong><code>findTouchedWindowTargetsLocked()</code> 的窗口集合从哪里来的？</strong></p>
<p><strong><code>dispatchEventLocked()</code> 又是如何把触摸事件通知到 APP 进程的？</strong></p>
<p>带着这两个疑问，我们开始进入 InputManagerService 的启动流程环节，这里面一定有我们要寻找的答案</p>
<h2 id="启动-inputmanagerservice">启动 InputManagerService</h2>
<p>我们知道，InputManagerService 作为运行在 SystemServer 进程中的服务，启动顺序是排在 Zygote 进程之后的</p>
<p>Java 虚拟机初始化完成后，再由 Zygote 进程 fork 而来</p>
<p>本小节我们将要来跟踪 InputManagerService 的启动流程，中间会涉及到一些没那么重要的类（<em>重要的都在上面介绍过了</em>）</p>
<p>比如，同为在 <code>/frameworks/native/services/inputflinger</code> 包下面的 InputManager 类，我们在介绍 native 层成员的时候就没有带上它</p>
<p>因为 InputManager 只是负责管理 <code>reader</code> 和 <code>dispatcher</code> 线程 ，没有业务逻辑，不是很重要</p>
<p>在整个 IMS 的启动流程中，我们时刻要谨记，本节的重点是：</p>
<ul>
<li><strong>了解 InputManagerService 大致的启动流程</strong></li>
<li><strong>了解 InputDispatcher 的窗口集合从哪里来，以及 IMS 如何建立跟 APP 通信的？</strong></li>
</ul>
<p>搞清楚这两个关键问题， IMS 启动流程这 part 就可以翻篇了，千万别被陷入到源码中，很难出来的~</p>
<h3 id="1-ims-窗口集合从哪里来">1、IMS 窗口集合从哪里来？</h3>
<p>在前两节我们了解到，InputManagerService 可以分为 native、jni、Java 三层</p>
<p>这三层大致的启动顺序是：<strong>先从 Java 层的初始化开始，再调用到 jni 层，由 jni 拉起 native 的各个类，进而完成 native 部分的初始化，最后返回到 Java 层，IMS 开始为各个 APP 提供服务</strong></p>
<p>我们先来看 Java 层的初始化工作</p>
<pre><code class="language-java">/frameworks/base/services/java/com/android/server/SystemServer.java
class SystemServer {

    private void startOtherServices() {
        inputManager = new InputManagerService(context); // 创建 IMS 对象
        ...
        //将 InputMonitor 对象保存到 IMS 对象
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
    }
}
</code></pre>
<p>在 <code>SystemServer#startOtherServices()</code> 启动服务的方法中，首先创建了 InputManagerService 对象</p>
<p>然后，将 WindowManagerService 中的 InputMonitor 对象保存到 IMS 中</p>
<p><strong>这是 InputMonitor 类是干嘛的？之前好像没见过</strong></p>
<p>简单来说，它是连接 WMS 和 IMS 的枢纽。WMS 通过 <code>InputMonitor.java</code> 持有了 IMS 的引用，当窗口信息发生变化后，通过 <code>InputMonitor#updateInputWindowsLw()</code> 方法，将新的窗口集合更新到 IMS 中，IMS 又将窗口集合同步到 InputDispatcher</p>
<p>我们本小节的目标之一，是为了搞清楚 InputDispatcher 持有的窗口集合从哪里来？</p>
<p><strong>现在，答案有了，是 WMS 通过调用 <code>InputMonitor#updateInputWindowsLw()</code> 函数，最终同步到 InputDispatcher 类中</strong></p>
<p>简单说一下查找过程</p>
<p>先回到 InputDispatcher 源码，搜索 <code>mWindowHandles</code> 关键字，很容易就能发现了 <code>mWindowHandles</code> 集合是在 <code>setInputWindows()</code> 函数中被赋值</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/InputDispatcher.cpp
class InputDispatcher {

    void InputDispatcher::setInputWindows(inputWindowHandles) {
        mWindowHandles = inputWindowHandles;
    }
}
</code></pre>
<p>那么 <code>setInputWindows()</code> 是谁调用的？接着搜索 Framework ，结果如图</p>
<figure data-type="image" tabindex="10"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69e4eebfa05a4818ad2864f90ec0c89c~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_method_setInputWindows.jpg" loading="lazy"></figure>
<p><em>图片来源：<a href="http://www.aospxref.com/android-7.1.2_r39/search?page-nav=android-7.1.2_r39&amp;full=setInputWindows&amp;project=frameworks">aospxref.com/android-7.1.2</a></em></p>
<p>我们发现，Java 层的 IMS 也有一个 <code>setInputWindows()</code> 方法，并通过 JNI 指向了 native 中的 <code>InputDispatcher#setInputWindows()</code></p>
<p><strong>最终的调用动作就发生在 InputMonitor 类的 <code>updateInputWindowsLw()</code> 方法中！</strong></p>
<p>好了，InputDispatcher 持有的窗口集合来源，这个疑问已经解决了。我们继续来跟启动流程</p>
<pre><code class="language-java">/frameworks/base/services/java/com/android/server/SystemServer.java
class SystemServer {
  
    private void startOtherServices() {
        inputManager = new InputManagerService(context);
        inputManager.start();
    }
}

/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java
class InputManagerService {
    // 【step 1.0】初始化流程
    public InputManagerService(Context context) {
       mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue());
       LocalServices.addService(InputManagerInternal.class, new LocalService());
    }

    // 【step 2.0】 启动流程
    public void start() {
        nativeStart(mPtr); // 详见 【2.1】
        Watchdog.getInstance().addMonitor(this);
    }
}
</code></pre>
<p>在 SystemServer 创建完 InputManagerService 对象后，紧接着就调用了 <code>inputManager#start()</code> 启动了服务</p>
<p>所以我们需要把启动流程分为两个步骤来看，<strong>一个是初始化流程做了什么，第二个才是启动流程</strong></p>
<p>在 InputManagerService 的构造函数中，调用了 <code>nativeInit()</code> 执行了初始化工作，这是个 jni 方法，我们一起去看看源码实现</p>
<h3 id="2-ims-的初始化工作">2、IMS 的初始化工作</h3>
<pre><code class="language-c++">/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp
class NativeInputManager {

    static jlong nativeInit(env, jclass, serviceObj, contextObj, messageQueueObj) {
        NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,messageQueue-&gt;getLooper()); 
    }

    NativeInputManager::NativeInputManager(contextObj, serviceObj, looper)  {
        sp&lt;EventHub&gt; eventHub = new EventHub(); // 创建 EventHub 对象
        mInputManager = new InputManager(eventHub, this, this); // 创建 InputManager 对象
    }

}
</code></pre>
<p><code>nativeInit()</code> 方法中创建了 NativeInputManager 对象</p>
<p>在 NativeInputManager 的构造函数中，又创建了两个我们熟悉的对象，<code>EventHub</code> 和 <code>InputManager</code></p>
<p>EventHub 在前面已经介绍过了，负责监听事件变化，并对外提供获取事件变化的接口</p>
<p>InputManager 也提到过，负责创建 Reader 和 Dispatcher 两线程，没什么逻辑</p>
<pre><code class="language-c++">/frameworks/native/services/inputflinger/EventHub.cpp
class EventHub {

    EventHub::EventHub(void)  {
        mEpollFd = epoll_create(EPOLL_SIZE_HINT); // 创建 epoll，用于监听设备文件是否有可读事件
        mINotifyFd = inotify_init(); // 创建 inotify ，用于监听文件系统是否变化，有变化说明发生设备插拔
    }
}

/frameworks/native/services/inputflinger/InputManager.cpp
class InputManager {
  
    InputManager::InputManager(eventHub, readerPolicy, dispatcherPolicy) {
        mDispatcher = new InputDispatcher(dispatcherPolicy);
        mReader = new InputReader(eventHub, readerPolicy, mDispatcher);
        initialize(); 
    }

    void InputManager::initialize() {
        mReaderThread = new InputReaderThread(mReader); //创建线程 “InputReader”
        mDispatcherThread = new InputDispatcherThread(mDispatcher); //创建线程 ”InputDispatcher“
    }

}
</code></pre>
<p>呐，你看</p>
<p>EventHub 只是创建了 <code>mEpollFd</code> 和 <code>mINotifyFd</code> 两个 Fd 对象</p>
<p>InputManager 也只是创建了 <code>InputReader</code> 和 <code>InputDispatcher</code> 两个对象，然后创建了 <code>InputReaderThread</code> 和 <code>InputDispatcherThread</code> 两个线程</p>
<p><strong>好了，现在 IMS 底层的三员大将：<code>EventHub</code>、<code>InputReader</code>、<code>InputDispatcher</code> 全部成功创建，IMS 类的初始化工作就全部结束了</strong></p>
<h3 id="3-ims-的启动流程">3、IMS 的启动流程</h3>
<p>我们把 SystemServer 的代码再拿出来看看，看看接下来应该做什么</p>
<pre><code class="language-java">/frameworks/base/services/java/com/android/server/SystemServer.java
class SystemServer {
  
    private void startOtherServices() {
        inputManager.start();
    }
}

/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java
class InputManagerService {
  
    public InputManagerService(Context context); // 初始化工作已完成 

    public void start() {
        nativeStart(mPtr); // 启动服务
        Watchdog.getInstance().addMonitor(this);
    }
}
</code></pre>
<p>初始化工作完成以后，紧接着调用了 <code>start()</code> 方法启动了服务</p>
<p><code>start()</code> 内部调用了 <code>nativeStart()</code> 方法，这又是个 jni 函数，我们继续向下跟</p>
<pre><code class="language-c++">/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp
class NativeInputManager {
  
    static void nativeStart(env, jclass , ptr) {
      	getInputManager()-&gt;start(); // 调用 InputManager 的 start() 方法
    }
}

/frameworks/native/services/inputflinger/InputManager.cpp
class InputManager {
   
    status_t InputManager::start() {
        result = mDispatcherThread-&gt;run(&quot;InputDispatcher&quot;, PRIORITY_URGENT_DISPLAY); // 启动线程“InputReader”
        result = mReaderThread-&gt;run(&quot;InputReader&quot;, PRIORITY_URGENT_DISPLAY); // 启动线程”InputDispatcher“
        ...
        return OK;
    }
}
</code></pre>
<p><code>nativeStart()</code> 内部调用了 <code>InputManager#start()</code> ，启动了 <code>InputReaderThread</code> 和 <code>InputDispatcher</code> 线程</p>
<p>这俩线程我们已经见过了，启动后，<code>InputReaderThread</code> 循环读消息，读到消息解析，生成 Event 对象，提交到事件队列，等待分发</p>
<p><code>InputDispatcher</code> 循环派发消息，一直从事件队列中取 Event 消息，派发给合适的窗口</p>
<p>到这里， IMS 的启动工作就全部结束了，整个过程如下图</p>
<figure data-type="image" tabindex="11"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/687b6ef552ed4eaab96bbdba26e6bd5e~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_ims_process.png" loading="lazy"></figure>
<p><em>图片来源：自己画的</em></p>
<p>IMS 启动流程稍微有那么一点点长，完整的启动分析我放在了 GitHub ，点击<a href="https://github.com/yibaoshan/Blackboard/blob/master/Blog/src/main/java/com/android/blog/android/graphics/code/v5/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.cpp">[这里]</a>跳转查看</p>
<h2 id="启动-app-进程">启动 APP 进程</h2>
<p>在上一小节 InputManagerService 的启动流程中，我们解决了“ <strong>InputDispatcher 的窗口集合从哪里来</strong>” 的问题</p>
<p>现在还剩下 “ <strong>APP 是如何和 IMS 建立通信的</strong> ” 这个问题还没有解决</p>
<p>系统服务全部准备就绪后，接下来是 APP 应用的启动流程，在跟踪启动应用进程的过程中，我们会找到 “ <strong>APP 是如何和 IMS 建立通信的</strong> ” 这个问题的答案</p>
<h3 id="1-为-activity-分配窗口">1、为 Activity 分配窗口</h3>
<p>APP 的启动过程我们应该都多少有点了解，和 AMS 通信怎么创建进程这部分我们就跳过了，本篇重点是触摸事件，我们直接快进到为 Activity 设置视图，分配窗口这部分内容</p>
<pre><code class="language-java">/frameworks/base/core/java/android/view/ViewRootImpl.java
class ViewRootImpl {

    InputChannel mInputChannel; // 保存的是 client 端的 socket

    void setView(View view){
        mInputChannel = new InputChannel(); // 创建了空的 InputChannel ，下面代码将会生成真实的 InputChannel
        Session.addToDisplay(view,mInputChannel);//向wms添加窗口

        if(mInputChannel!=null) mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
    }

}
</code></pre>
<p>我们在 Activity 设置的视图文件，最终会调用到 <code>ViewRootImpl#setView()</code> 方法</p>
<p>在 <code>setView()</code> 方法中，一共有三行关键代码</p>
<ol>
<li><strong>创建了属于该视图的 InputChannel 空对象，先不用管</strong></li>
<li><strong>向 WMS 添加窗口，并将刚刚创建的 InputChannel 对象一并传递过去，重要逻辑</strong></li>
<li><strong>创建了 WindowInputEventReceiver ，将该视图的 InputChannel 保存起来，也不用管</strong></li>
</ol>
<p>在这三行代码中，第2行是关键代码，第1行和第3行，以现有的信息没办法解释它们内部做了什么，等到后面有机会在介绍</p>
<p>好，我们来看第2行代码发生了什么</p>
<pre><code class="language-java">/frameworks/base/services/core/java/com/android/server/wm/Session.java
class Session {

    void addToDisplay(InputChannel inputChannel){
        WindowManagerService.addWindow(inputChannel);
    }

}

/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
class WindowManagerService {

    int addWindow(InputChannel outInputChannel){
        WindowState win = new WindowState(); // 首次添加视图时创建，用于描述一个window
        win.openInputChannel(outInputChannel); // 创建通信的关键代码，打开一对已连接的 socket
    }

}
</code></pre>
<p><code>Session#addToDisplay()</code> 方法只是做了转发，实际创建窗口的工作还是由 <code>WindowManagerService#addWindow()</code> 来完成的</p>
<p>在 <code>addWindow()</code> 方法中，首先创建了 WindowState 对象，用于描述该窗口信息</p>
<p>随后调用了 WindowState 对象中的 <code>openInputChannel()</code> 方法，它是创建通信的关键代码，内部是创建了一对已连接的 <code>socket</code></p>
<p>我们来重点关注 <code>WindowState#openInputChannel()</code> 方法</p>
<pre><code class="language-java">/frameworks/base/services/core/java/com/android/server/wm/WindowState.java
class WindowState {

    InputChannel mInputChannel;
    InputChannel mClientChannel;

    void openInputChannel(InputChannel outInputChannel) {
        InputChannel[] inputChannels = InputChannel.openInputChannelPair(); // 返回一对已连接的 socket
        // 这是一对已连接的管道，将 socket 两端分别保存到服务端和客户端即可进行通信
        mInputChannel = inputChannels[0]; // 下标为0的传递给 IMS 服务端，服务端可通过该 socket 向窗口发送消息
        mClientChannel = inputChannels[1]; // 下标为1的回传给 client 端
        // 1. Client 端 InputChanenl 调用 transforTo() 方法传给 ViewRootImpl 的 mInputChannel
        mClientChannel.transferTo(outInputChannel);
        // 2. Server 端 InputChannel 存在 WindowState 的 mInputChannel 变量
        InputManagerService.registerInputChannel(mInputChannel);
    }
}

/frameworks/native/libs/input/InputTransport.cpp
status_t InputChannel::openInputChannelPair(name,outServerChannel,outClientChannel) {
    int sockets[2] = socketpair(sockets);
    serverChannelName.append(&quot; (server)&quot;);
    outServerChannel = new InputChannel(serverChannelName, sockets[0]);
    clientChannelName.append(&quot; (client)&quot;);
    outClientChannel = new InputChannel(clientChannelName, sockets[1]);
    return OK;
}
</code></pre>
<p><code>WindowState#openInputChannel()</code> 中，首先调用了 <code>InputChannel#openInputChannelPair()</code> 函数创建两个 InputChannel，其内部调用 Linux 的 <code>socketpair()</code> 函数</p>
<p><code>socketpair()</code> 是 Linux 提供的一种进程间通信的方式，跟 <code>pipe()</code> 函数是类似的。但 <code>pipe()</code> 创建的匿名管道是半双工的，而 <code>socketpair()</code> 可以认为是创建一个全双工的管道：</p>
<p>我向我持有的 <code>socket</code> 中写数据，你在你持有的 <code>socket</code> 中能够读到数据，反过来也一样，即两端都可以对自己持有的 <code>socket</code> 进行读写</p>
<p>在触摸事件的传递中，Google 团队使用了 <code>socketpair()</code> 创建一对已连接的 <code>socket</code> ，用于 IMS 和 APP 间跨进程通信</p>
<p>其中，IMS 会持有名为 <code>server</code> 的一端（<code>sockets[0]</code>）进行读写； APP 持有名为 <code>client</code> 的一端（<code>sockets[1]</code>）进行读写</p>
<p><strong>提个醒，我们现在看的代码是：设置 Activity 视图时，经过 <code>binder</code> 通信后，跑在了 <code>system_server</code> 进程中的 WMS 服务里</strong></p>
<p>因此，我们接下来的任务，是把 <code>sockets[0]</code> 的 <code>server</code> 端，传递给 IMS ，让触摸事件发生后， IMS 能够通知到 APP</p>
<p>然后，把 <code>sockets[1]</code> 的 <code>client</code> 端通过 <code>binder</code> 跨进程回传给 APP 进程保存，让 APP 能够接收到来自 IMS 的消息</p>
<p>好，开始干活</p>
<h3 id="2-sockets1-回传给-app">2、sockets[1] 回传给 APP</h3>
<p>源码里是先将 Client 的回传给 APP 进程，那我们就按照源码的顺序来看，先把属于 APP 进程的 <code>socket</code> / <code>InputChannel</code> 回传过去</p>
<pre><code class="language-java">/frameworks/base/services/core/java/com/android/server/wm/WindowState.java
class WindowState {

    void openInputChannel(InputChannel outInputChannel) {
        // 1. Client 端 InputChanenl 调用 transforTo() 方法传给 ViewRootImpl 的 mInputChannel
        mClientChannel.transferTo(outInputChannel);
        // 2. Server 端 InputChannel 存在 WindowState 的 mInputChannel 变量
        InputManagerService.registerInputChannel(mInputChannel);
    }
}

/frameworks/base/core/java/android/view/ViewRootImpl.java
class ViewRootImpl {

    InputChannel mInputChannel; // 保存的是 client 端的 socket 

    void setView(View view){
        mInputChannel = new InputChannel(); // 创建了空的 InputChannel
      	try {
          	Session.addToDisplay(view,mInputChannel);
        } catch (RemoteException e) {
          	mInputChannel = null;
        }
        ...
        if(mInputChannel != null ) mInputEventReceiver = new InputEventReceiver(mInputChannel, Looper.myLooper()); 
    }

}
</code></pre>
<p>看代码，<code>Session#addToDisplay()</code> 是将我们设置的视图，和刚刚创建的空的 <code>mInputChannel</code> 传递到 WindowManagerService</p>
<p>如果 WMS 成功添加了视图，没有发生异常，表示属于 APP 端的 <code>socket</code> / <code>InputChannel</code> 已经创建成功并通过 <code>binder</code> 跨进程传递回来了，此时 <code>mInputChannel</code> 变量就不是刚刚创建的空对象了，里面已经包含了 APP 端的 <code>socket</code></p>
<p>监听这个 <code>socket</code> ，我们可以收到来自 IMS 的消息；往这个 <code>socket</code> 写数据，IMS 也可以收到我们发送的消息，美滋滋</p>
<p>如果 WMS 添加视图失败了，会抛出 <code>RemoteException</code> 远程连接异常，<code>mInputChannel</code> 变量将被清空。</p>
<p>总之，只要 <code>mInputChannel</code> 变量不为空，就表示属于 APP 端的 <code>socket</code> 已经传回来了， WMS 和 APP 中间的传递过程我们先不管</p>
<p>好，现在 APP 端的 InputChannel 已经回传成功，下一步的代码是创建了 <code>InputEventReceiver</code> 对象，并将 APP 端的 InputChannel 和 APP 端的 Looper 一同传递过去</p>
<p>一起来看 InputEventReceiver 的代码</p>
<pre><code class="language-java">/frameworks/base/core/java/android/view/InputEventReceiver.java
class InputEventReceiver {

    public InputEventReceiver(InputChannel inputChannel, Looper looper) {
        mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this),inputChannel, looper.getQueue());
    }

}
</code></pre>
<p>java 层的 InputEventReceiver 只是个空壳子，实际的实现在 native 层，继续向下跟</p>
<pre><code class="language-c++">/frameworks/base/core/jni/android_view_InputEventReceiver.cpp
class NativeInputEventReceiver {

    static jlong nativeInit(env, clazz, receiverWeak, inputChannelObj,  messageQueueObj) { // 简略写法
       int fd = inputChannelObj-&gt;getFd();
       messageQueueObj-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL);
       ...
    }

}
</code></pre>
<p>代码我又合并过，关键代码就两行</p>
<p><strong>第一行是利用 <code>inputChannelObj</code> 对象获取里面的 <code>socketfd</code></strong></p>
<p><strong>第二行是利用 <code>messageQueueObj</code> 对象获取里面的 Looper ，把上一步拿到的 <code>socketfd</code> 丢进去监听</strong></p>
<p>代码虽然不多，但理解这两行代码，需要对 Handler 机制比较熟悉，包括 native 层</p>
<p>我来简单解释一下：</p>
<p>在<a href="https://juejin.cn/post/7146239048191836190">《Android组件系列：再谈Handler机制（Native篇）》</a>这篇文章中，我们了解到：<strong>在 native 层同样拥有一套 Looper 机制。这套 Looper 不但可以处理 native 层消息，还支持监听 <code>自定义 fd</code>，这是本小节的重点</strong></p>
<p>Java 层的 MessageQueue 在初始化时，会调用 <code>nativeInit()</code> 方法，同步创建 naive 层的 <code>NativeMessageQueue</code> 对象，并将返回的 native 引用保存到 <code>mPtr</code> 变量中</p>
<p>注意看，我们现在跟踪的 <code>NativeInputEventReceiver</code> 构造函数的入参，传递过来的参数一个是 <code>InputChannel</code> ，里面包含了属于 APP 端的 <code>socket</code>，还有一个参数是来自 Java 层的 <code>MessageQueue</code> 对象</p>
<p>那么，<code>NativeInputEventReceiver#nativeInit()</code> 方法里完成的事情是：<strong>利用 Java MessageQueue 的 <code>mPtr</code> 变量持有的 <code>NativeMessageQueue</code> 对象，找到 native Looper</strong></p>
<p><strong>然后，利用 native 层的 Looper 对象来监听一同传递过来的 <code>InputChannel</code> 中的 <code>socketfd</code> 。</strong></p>
<p>这一段听起来可能会有点绕，暂时没理解某个点问题也不大，我们只需要知道，在设置视图的时候，顺便创建了和 IMS 通信的通道就行了</p>
<p>好了，APP 端的 <code>socket</code>（<em><code>sockets[1]</code></em>） 回传工作算是结束了，接下来我们看怎么把 <code>sockets[0]</code> 传递给 IMS</p>
<h3 id="3-sockets0-传递到-ims">3、sockets[0] 传递到 IMS</h3>
<p>IMS 端的 <code>socket</code> 最终是由 InputDispatcher 来保管，因为分发事件时，是 InputDispatcher 直接使用 <code>socket</code> 通知 APP 的</p>
<p>所以，我们本小节的目标是：<strong>搞清楚 IMS 端的 <code>socket</code> 是如何传递到 InputDispatcher 类中的？</strong></p>
<p>IMS 传递的起点，依旧是在 <code>WindowState#openInputChannel()</code> 方法中：</p>
<pre><code class="language-java">/frameworks/base/services/core/java/com/android/server/wm/WindowState.java
class WindowState {

    void openInputChannel(InputChannel outInputChannel) {
        // 1. Client 端 InputChanenl 调用 transforTo() 方法传给 ViewRootImpl 的 mInputChannel
        mClientChannel.transferTo(outInputChannel);
        // 2. Server 端 InputChannel 存在 WindowState 的 mInputChannel 变量
        InputManagerService.registerInputChannel(mInputChannel);
    }
}

/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java
class InputManagerService {

    void registerInputChannel(){
        nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false);
    }
}
</code></pre>
<p><code>InputManagerService#registerInputChannel()</code> 又是一个空壳，具体实现在 native ，继续向下跟</p>
<pre><code class="language-c++">/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp
class NativeInputManager {

    void nativeRegisterInputChannel(){
        InputManager-&gt;getDispatcher()-&gt;registerInputChannel(inputChannel, inputWindowHandle, monitor);
    }
}

/frameworks/native/services/inputflinger/InputDispatcher.cpp
class InputDispatcher {

    status_t InputDispatcher::registerInputChannel(inputChannel,inputWindowHandle,monitor){
        // 将代表窗口通信的 inputChannel ，以及代表窗口信息的 inputWindowHandle 封装成 Connection 对象
        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);
        mConnectionsByFd.add(fd, connection);
        ... // 省略 IMS 监听来自 client 的代码，这部分是处理 ANR 的逻辑
    }
}
</code></pre>
<p><code>NativeInputManager#nativeRegisterInputChannel()</code> 随手又是一个转发</p>
<p>在 <code>InputDispatcher#registerInputChannel()</code> 方法中，经过一番长途跋涉，最终将 <code>socket</code> 注册到 InputDispatcher，一起被注册过来的还有代表该窗口信息的 <code>inputWindowHandle</code></p>
<p>代表窗口通信的 <code>inputChannel</code> ，以及代表窗口信息的 <code>inputWindowHandle</code> 被封装成 <code>Connection</code> 对象，保存到 <code>mConnectionsByFd</code> 集合中</p>
<p>至此，IMS 端的 <code>socket</code> 传递工作结束，APP 和 IMS 可以愉快的通信了</p>
<p>整个过程如下</p>
<figure data-type="image" tabindex="12"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6f49ee52fdf4f39803b382dfd0c6a22~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_wms_process.png" loading="lazy"></figure>
<p><em>图片来源：自己画的</em></p>
<h2 id="触摸事件到达-viewrootimpl">触摸事件到达 ViewRootImpl</h2>
<p>好了，万事俱备，只欠东风</p>
<p>现在 APP 进程起来了，APP 和 IMS 也成功建立了通信，接下来我们按下屏幕，看看触摸事件是怎么到达我们熟悉的 View 的</p>
<pre><code class="language-c++">/frameworks/base/core/jni/android_view_InputEventReceiver.cpp
class NativeInputEventReceiver {

    static jlong nativeInit(env, clazz, receiverWeak, inputChannelObj,  messageQueueObj) { // 简略写法
       int fd = inputChannelObj-&gt;getFd();
       messageQueueObj-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL);
       ...
    }

}
</code></pre>
<p>在介绍 APP 端的 <code>socket</code> 回传一节中，最后一步停在了<code> NativeInputEventReceiver#nativeInit()</code> 方法，利用 Looper 监听了 <code>socketfd</code></p>
<p>现在我们来聊聊：<strong>当 <code>socketfd</code> 有消息时，APP 端会怎么处理，事件是怎么分发到根 View 的？</strong></p>
<pre><code class="language-c++">/frameworks/base/core/jni/android_view_InputEventReceiver.cpp
class NativeInputEventReceiver {

    int NativeInputEventReceiver::handleEvent( receiveFd, events, data) {
        switch (type) { // 简略写法，这是 consumeEvents() 方法中的逻辑
            case AINPUT_EVENT_TYPE_KEY: {
                inputEventObj = factory-&gt;createKeyEvent(); // 转换为按键类型事件 KeyEvent
            }
            case AINPUT_EVENT_TYPE_MOTION: {
                inputEventObj = factory-&gt;createMotionEvent(); // 转转为触摸类型事件 MotionEvent
            }
        }
        env-&gt;CallVoidMethod(receiverObj.get(),dispatchInputEvent, seq, inputEventObj); // 回调到 Java
    }
}
</code></pre>
<p>APP 端的 <code>socketfd</code> 发生事件变化时，Looper 根据指定的回调地址，调用到 <code>NativeInputEventReceiver#handleEvent()</code> 方法</p>
<p>在 <code>NativeInputEventReceiver#handleEvent()</code> 方法中，根据事件类型，创建不同的事件对象</p>
<p>最后，利用 <code>CallVoidMethod</code> 回调 Java 方法，将事件传递到 Java 层的 <code>InputEventReceiver#dispatchInputEvent()</code> 方法</p>
<pre><code class="language-java">/frameworks/base/core/java/android/view/InputEventReceiver.java
abstract class InputEventReceiver {

    // Called from native code.
    private void dispatchInputEvent(int seq, InputEvent event) {
        onInputEvent(event);
    }
}

/frameworks/base/core/java/android/view/ViewRootImpl.java
class ViewRootImpl extends InputEventReceiver {
    
    class WindowInputEventReceiver extends InputEventReceiver {

        @Override
        public void onInputEvent(InputEvent event) {
            enqueueInputEvent(event, this, 0, true);
        }
    }

    void enqueueInputEvent(InputEvent event,InputEventReceiver receiver, int flags, boolean processImmediately) {
        ...
        // 执行消息入列以后，接着还有一个比较复杂的流水线过程，我们这里先不关心，直接来看 processPointerEvent() 方法
        // input 消息到达 ViewRootImpl 后，Google 使用责任链的模式，将输入事件拆分为 KeyEvent 和 MotionEvent 两种类型，做进一步的处理
        //
        if(event.getType == input) processPointerEvent(event);
        if(event.getType == key) processKeyEvent(event);
    }

    // 责任链模式，每个 InputStage 负责不同的功能，链中的某个 InputStage 的结果会影响对下一节点的执行，或停止继续分发等
    // 在 ViewRootImpl#setView() 函数中指定责任链的前后顺序，这里不展开讨论，请查看参考资料列表中《这一次，带你彻底弄懂 Android 事件分发机制(外/内层责任链)》
    class InputStage {

        // 在 ViewRootImpl 中有好几个同名 processPointerEvent() 方法， eventTarget 通常是 ViewRootImpl 保存的 DecorView 对象，也就是会调用到 View#dispatchPointerEvent() 方法
        private int processPointerEvent(QueuedInputEvent q) {
            MotionEvent event = (MotionEvent)q.mEvent;
            final View eventTarget =  mView; // 通常是 DecorView
            boolean handled = eventTarget.dispatchPointerEvent(event);
            ...
            return handled ? FINISH_HANDLED : FORWARD;
        }

        private int processKeyEvent(QueuedInputEvent q) {
            KeyEvent event = (KeyEvent)q.mEvent;
            mView.dispatchKeyEvent(event)
            final View eventTarget =  mView; // 通常是 DecorView
            boolean handled = eventTarget.dispatchPointerEvent(event);
            ...
            return handled ? FINISH_HANDLED : FORWARD;
        }

    }

}
</code></pre>
<p>InputEventReceiver 是抽象类，在 <code>dispatchInputEvent()</code> 方法中回调 <code>onInputEvent()</code> 方法。</p>
<p>而 ViewRootImpl 的内部类 <code>WindowInputEventReceiver</code> 实现了 InputEventReceiver 类，并且在 <code>onInputEvent()</code> 内部又调用了 <code>enqueueInputEvent()</code> 入列输入消息</p>
<p>所以，接下来的分发逻辑全部都发生在 <code>ViewRootImpl#enqueueInputEvent()</code> 方法中</p>
<p>胜利的曙光就在前方，继续冲</p>
<pre><code class="language-java">/frameworks/base/core/java/android/view/ViewRootImpl.java
class ViewRootImpl extends InputEventReceiver {

    void enqueueInputEvent(InputEvent event,InputEventReceiver receiver, int flags, boolean processImmediately) {
        if(event.getType == input) processPointerEvent(event);
        if(event.getType == key) processKeyEvent(event);
    }

    class InputStage {

        private int processPointerEvent(QueuedInputEvent q) {
            MotionEvent event = (MotionEvent)q.mEvent;
            final View eventTarget =  mView; // 通常是 DecorView
            boolean handled = eventTarget.dispatchPointerEvent(event);
            ...
            return handled ? FINISH_HANDLED : FORWARD;
        }

        private int processKeyEvent(QueuedInputEvent q);// 处理 key 事件，忽略
    }

}
</code></pre>
<p><code>input</code> 消息到达 ViewRootImpl 后，将输入事件拆分为<code> KeyEvent</code> 和 <code>MotionEvent</code> 两种类型，做进一步的处理</p>
<p>Google 团队使用了<code>责任链模式</code>来处理事件消息，每个 <code>InputStage</code> 负责不同的功能，链中的某个 <code>InputStage</code> 的结果会影响对下一节点的执行，或停止分发等</p>
<p><code>ViewRootImpl#setView()</code> 函数中指定了责任链执行的前后顺序，我们这里不展开讨论，感兴趣的同学可以查看参考资料列表中<a href="https://juejin.cn/post/6925336861137174541">《这一次，带你彻底弄懂 Android 事件分发机制(外/内层责任链)》</a></p>
<p>为了省事，我们直接看 <code>processPointerEvent()</code> 处理触摸事件的方法</p>
<p>在 <code>processPointerEvent()</code> 方法中，先是将 <code>InputEvent</code> 强转为 <code>MotionEvent</code> ，然后，调用 <code>mView</code> 的 <code>dispatchPointerEvent()</code> 方法执行分发</p>
<h2 id="触摸事件到达-decorview">触摸事件到达 DecorView</h2>
<p>了解 Window 创建流程的朋友肯定知道，<code>mView</code> 就是 DecorView ，那这里其实调用的是 <code>DecorView#dispatchPointerEvent()</code> 执行分发，接着来跟踪</p>
<pre><code class="language-java">/frameworks/base/core/java/android/view/View.java
class View {

    public final boolean dispatchPointerEvent(MotionEvent event) {
        if (event.isTouchEvent()) {
            return dispatchTouchEvent(event);
        } else {
            return dispatchGenericMotionEvent(event);
        }
    }
}
</code></pre>
<p>DecorView 继承自 <code>FrameLayout</code> ，FrameLayout 继承自 <code>ViewGroup</code> ，ViewGroup 继承自 <code>View</code></p>
<p>View 的 <code>dispatchPointerEvent()</code> 是 <code>final</code> 关键字修饰的，不允许子类重写</p>
<p>所以，调用 <code>DecorView#dispatchPointerEvent()</code> 实际的执行者是 View</p>
<p>在 <code>View#dispatchPointerEvent()</code> 方法中，首先判断是不是触摸事件，那肯定是啊</p>
<p>接着调用 <code>dispatchTouchEvent()</code> 方法执行分发</p>
<p><code>dispatchTouchEvent()</code> 没有被 <code>final</code> 修饰，可以被重写，所以我们现在回到 DecorView 的 <code>dispatchTouchEvent()</code> 方法中</p>
<pre><code class="language-java">/frameworks/base/core/java/com/android/internal/policy/DecorView.java
class DecorView extends FrameLayout {
    
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        Window.Callback cb = mWindow.getCallback(); // 给 Activity 和 Dialog 拦截事件的机会
        return cb != null ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);
    }
}
</code></pre>
<p>在 <code>DecorView#dispatchTouchEvent()</code> 方法中，先是判断了 <code>mWindow</code> 持有的 Callback 是否为空</p>
<p>这里临时补充两个小细节</p>
<ol>
<li><strong>Window.Callback 是个接口，而 Activity 和 Dialog 都实现了这个接口</strong></li>
<li><strong>DecorView 持有的 <code>mWindow</code> 的赋值路径是这样的：<code>PhoneWindow#setContentView()</code> -&gt; <code>installDecor()</code> -&gt; <code>generateDecor()</code> -&gt; <code>DecorView#setWindow()</code>，不展开讨论了</strong></li>
</ol>
<p>接着看代码，如果 <code>mWindow</code> 的 Callback 不为空，则优先调用 Callback 的 <code>dispatchTouchEvent()</code> 函数执行分发</p>
<p>我们以 Activity 来举例</p>
<pre><code class="language-java">/frameworks/base/core/java/android/app/Activity.java
class Activity {
    
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }

    public boolean onTouchEvent(MotionEvent event) {
        ...
    }
}

/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java
class PhoneWindow {
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
    }
}

/frameworks/base/core/java/com/android/internal/policy/DecorView.java
class DecorView extends FrameLayout {
    
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return super.dispatchTouchEvent(event);
    }
}
</code></pre>
<p>Activity 的 <code>dispatchTouchEvent()</code> 方法被调用后，先调用了 <code>getWindow().superDispatchTouchEvent(ev)</code> 执行分发，没人处理再调用自身的 <code>onTouchEvent() </code>方法</p>
<p>而 <code>getWindow().superDispatchTouchEvent()</code> 方法兜兜转转一圈，还是调用到 <code>DecorView#superDispatchTouchEvent()</code> 中</p>
<p>前面说过了，DecorView 继承自 FrameLayout ，FrameLayout 是没有重写 <code>dispatchTouchEvent()</code> 方法的，FrameLayout 继承自 ViewGroup ，ViewGroup 重写了 <code>dispatchTouchEvent()</code></p>
<p>所以，最终执行分发的还是 <code>ViewGroup#dispatchTouchEvent()</code> 方法</p>
<p><strong>合着绕了一圈，Activity 是啥也没做是吧？</strong></p>
<p>ummmm~  是的</p>
<p>不过，我觉得这样的设计是在给 <code>Activity</code> / <code>Dialog</code> 拦截事件的机会，毕竟如果我们在 Activity 中重写了 <code>dispatchTouchEvent()</code> 方法，是可以让整棵 View 树都接收不到触摸事件的</p>
<p>好，现在触摸事件分发的起点到了我们非常熟悉的 <code>ViewGroup#dispatchTouchEvent()</code> 这里</p>
<p>接下来的一整章，我们来复习 View / ViewGroup 事件分发的流程</p>
<h1 id="三-触摸事件的消费application">三、触摸事件的消费（Application）</h1>
<p>在之前的两节内容中，一个 <code>input</code> 事件一路从硬件驱动，成功的到达应用的 <code>DecorView</code></p>
<p>我们接下来的任务是，把这个事件分发给某个具体的 View 或者是 ViewGroup</p>
<p>正文开始前，我们先来聊聊触摸事件的本体：<code>MotionEvent</code></p>
<p><code>MotionEvent</code> 表示一个<code>触摸事件</code>，里面包含了事件的类型，触摸的位置信息等，对分发者来说，事件的类型非常重要，来简单认识一下</p>
<ul>
<li><strong><code>ACTION_DOWN</code>： 按下屏幕</strong></li>
<li><strong><code>ACTION_MOVE</code>：手指滑动</strong></li>
<li><strong><code>ACTION_UP</code>：抬起手指，离开屏幕</strong></li>
<li><strong><code>ACTION_CANCEL</code>：非正常抬起，几乎等同于 <code>ACTION_UP</code> ，通常是父视图拦截</strong></li>
<li><strong><code>ACTION_POINTER_DOWN</code>：多指触摸，表示已经有一只手指按下时，另有一只手指再次按下</strong></li>
<li><strong><code>ACTION_POINTER_UP</code>：多指触摸，表示屏幕上已经有多个手指，抬起其中一只手指后触发的事件</strong></li>
</ul>
<p>几种常用触摸的类型就这么多，最后两种是多指触摸的情况下才会收到的事件类型，本文我们不打算讨论多指触摸（<em>包括 TouchTarget</em>），所以后面会忽略掉</p>
<p>在一次事件分发中，以每个 <code>DOWN</code> 事件为开始， <code>UP</code> / <code>CANCEL</code> 事件为停止，在 <code>DOWN</code> -&gt; <code>MOVE</code> -&gt; <code>MOVE</code> -&gt; <code>UP</code> / <code>CANCEL</code> 整个过程看做是一个事件序列</p>
<h2 id="viewgroup-的消费-分发-拦截与放行">ViewGroup 的消费、分发、拦截与放行</h2>
<p>在进入 ViewGroup 的源码之前，我们先来思考一个问题：<strong>什么是事件分发？</strong></p>
<p>我们都知道，在 Android 图形系统中，主要绘图的任务是交给 View 去完成的，ViewGroup 是作为管理视图的容器，它的任务是按照一定的规则摆放子 View，自身则基本不参与绘图操作</p>
<p>但是在触摸事件的分发中，ViewGroup 对触摸事件的态度就变了，因为它和子 View 一样，都可能需要响应触摸事件</p>
<h3 id="1-viewgroup-四种场景">1、ViewGroup 四种场景</h3>
<p>举个例子，有一个可以纵向滑动的 ViewGroup ，里面摆满了 <code>TextView</code> ，用户在滑动屏幕时，肯定是期望展示更多内容的。那么这时候，就需要 ViewGroup 对子 View 重新布局摆放，将隐藏在屏幕底部的子 View 显示出来</p>
<figure data-type="image" tabindex="13"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f984d3a1b5ba4c509825bbe1269cb69e~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_viewgroup_consumed.GIF" loading="lazy"></figure>
<p><em>图片来源：自己录的</em></p>
<p>上面的场景中，ViewGroup 必须要拿到用户滑动屏幕的数据，才能计算展示多少视图才算合适</p>
<p><strong>即，ViewGroup 需要消费触摸事件</strong></p>
<p>再举个例子，在一个不支持滑动的 ViewGroup 中，有个居中显示的 <code>Button</code> 按钮</p>
<figure data-type="image" tabindex="14"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811bb5cbc6564c8da7153b768c77e7e0~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_viewgroup_dispatch.GIF" loading="lazy"></figure>
<p><em>图片来源：自己录的</em></p>
<p>用户按下屏幕后，ViewGroup 肯定比自己的子 View 要优先拿到触摸事件</p>
<p>而 ViewGroup 自身又不需要这个事件，那么，它就需要根据触摸位置去查找，有没有子 View 需要该事件</p>
<p>经过计算，如果发现用户按偏了，没点到 <code>Button</code> ，那就不管了，<code>dispatchTouchEvent()</code> 返回 false ，爱谁消费谁消费，反正我不要</p>
<p>如果发现用户按到了中间的 <code>Butto</code>n ，这时候 ViewGroup 就需要把这个事件交给 <code>Button</code> ，询问子 View 要不要消费</p>
<p><strong>即， ViewGroup 需要分发事件</strong></p>
<p>再再举个例子，在一个支持纵向滑动的 ViewGroup 中，有个居中显示的 <code>Button</code> 按钮</p>
<p>现在，用户按下了屏幕中的 <code>Button</code> ，ViewGroup 觉得不是滑动事件，就把这个事件分发给了 <code>Button</code></p>
<p>但是用户在按下 <code>Button</code> 后，接着又开始滑动屏幕了</p>
<figure data-type="image" tabindex="15"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5891488d6de04c0dbb2751b3439c0043~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_viewgroup_intercept.GIF" loading="lazy"></figure>
<p><em>图片来源：自己录的</em></p>
<p>此时的 ViewGroup 需要计算滑动距离，所以是需要这个触摸事件的，那只能对不起 <code>Button</code> 了，ViewGroup 会把本来准备分发给 <code>Button</code> 的事件拦截消费掉</p>
<p><strong>即，ViewGroup 需要拦截事件</strong></p>
<p>另外，我们还需要考虑一种极端情况：<strong>如果子 View 和 ViewGroup 都需要触摸事件，应该怎么处理？</strong></p>
<p>按正常的拦截逻辑，ViewGroup 先拿到事件，自己又有消费的需求，肯定是紧着自己用</p>
<p>但是，总会有场景需要将事件优先分发给子视图，比如：</p>
<p>在一个支持纵向滚动的 ViewGroup ，它的两个子 View 同样是支持纵向滚动的 ViewGroup ，两个子 View 分别都包含若干 <code>TextView </code></p>
<p>现在的需求是：<strong>长按某一个 <code>TextView</code> 时，允许该 <code>TextView</code> 上下自由拖动</strong></p>
<figure data-type="image" tabindex="16"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58c4029537de4245b57869bc0076e5d1~tplv-k3u1fbpfcp-watermark.image?" alt="android_graphic_v5_viewgroup_request.GIF" loading="lazy"></figure>
<p><em>图片来源：自己录的</em></p>
<p>当用户长按 <code>TextView</code> 移动时，预期是移动这个 <code>TextView</code>，理论上这个移动事件应该被 <code>TextView</code> 的爸爸消费掉，因为需要重新布局绘制；</p>
<p>但实际上是 <code>TextView</code> 的爷爷消费掉的，因为爷爷觉得用户是在滑动屏幕，要把屏幕下方更多的视图显示出来</p>
<p><strong>ViewGroup 和 ViewGroup 中的子 View 都想要消费事件（滑动冲突），这时候该怎么办？</strong></p>
<p>很简单，我们需要创建一种机制，让 ViewGroup 知道子 View 也需要这个事件</p>
<p>我们暂且把这套机制称之为 “请求放行” 好了</p>
<p>ViewGroup 为子 View 开放一个请求放行的接口，当 ViewGroup 收到来自子 View 的放行请求时，优先将事件分发给子 View，这样，问题就解决了</p>
<p><strong>触摸事件的<code>消费</code>、<code>拦截</code>、<code>放行</code>与<code>分发</code>，这四种情况几乎覆盖了 ViewGroup 对触摸事件处理（单指）的所有场景</strong></p>
<p>好，现在 ViewGroup 的需求基本上了解清楚了，接下来我们来看源码中， Google 是怎么进行代码设计的</p>
<h3 id="2-事件的放行和拦截">2、事件的放行和拦截</h3>
<p>第二章结束时，最终调用停在了 <code>ViewGroup#dispatchTouchEvent()</code> 方法，这也是整个 View / ViewGroup 事件分发的起源</p>
<pre><code class="language-java">/frameworks/base/core/java/android/view/ViewGroup.java
class ViewGroup extends View {

    public boolean dispatchTouchEvent(MotionEvent ev) {
        int actionMasked = ev.getAction() &amp; MotionEvent.ACTION_MASK;
        TouchTarget newTouchTarget = null;
        boolean intercepted;
      	boolean handled = false;
        if (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null) {
            // 检查子视图是否调用了 requestDisallowInterceptTouchEvent(true) 请求放行
            boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
              intercepted = onInterceptTouchEvent(ev); // 子视图未请求放行，询问 ViewGroup 自身是否需要消费
            } else {
              intercepted = false;
            }
        } else {
            intercepted = true; // 如果 mFirstTouchTarget 为空，并且事件类型不为 DOWN ，表示先前的事件也是 ViewGroup 自己消费的，无需执行分发，再次交给自己执行即可
        }
        return handled;
    }

    public boolean onInterceptTouchEvent(MotionEvent ev) {
        //询问 ViewGroup 自身是否需要处理事件
        return false;
    }
  
    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
      	if (disallowIntercept) {
          	mGroupFlags |= FLAG_DISALLOW_INTERCEPT;
      	} else {
          	mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
      	}
  	}
}
</code></pre>
<p>ViewGroup 的几种场景我们已经在上面介绍过了，接下来就是对照源码解释的过程，比较轻松</p>
<p>在事件分发的开始，先是判断了事件是否是 <code>DOWN</code> 类型，或者 <code>mFirstTouchTarget</code> 变量是否不为空（<em><code>mFirstTouchTarget</code> 记录的是消费上一次 <code>DOWN</code> 事件的是谁</em>）</p>
<p>满足条件则进入 “检查放行” 和 “检查是否要拦截” 的逻辑</p>
<p><code>disallowIntercept</code> 为 true ，表示子视图是否调用了 <code>requestDisallowInterceptTouchEvent(true)</code> 方法请求放行，将 <code>intercepted</code> 标识置为false ，并且，本次事件将不询问 ViewGroup 自身是否要消费</p>
<p><strong><code>ViewGroup#requestDisallowInterceptTouchEvent()</code> 方法就是之前介绍过的，开放给子 View 请求放行的一套机制</strong></p>
<p>如果子视图没有请求放行，那么调用 <code>onInterceptTouchEvent()</code> 询问自己要不要拦截消费，不需要消费事件会继续分发，我们后面会讲到</p>
<p>如果 <code>mFirstTouchTarget</code> 为空，并且事件类型不为 <code>DOWN</code> ，表示先前的事件也是 ViewGroup 自己消费的，无需执行分发，再次交给自己执行即可，将 <code>intercepted</code> 变量置为 true</p>
<p>上面这段代码解释完了，我们来总结一下得到的信息：</p>
<p><strong>只要子 View 没有调用 <code>requestDisallowInterceptTouchEvent()</code> 方法请求放行，ViewGroup 有权在任何情况下，通过调用 <code>onInterceptTouchEvent()</code> 返回 true 的方式，拦截任一触摸事件</strong></p>
<p>我们在继承 ViewGroup 以后，首先要重写 <code>onInterceptTouchEvent()</code> 方法，然后我们根据自己的需求，判断要不要消费某个事件</p>
<p>true 表示自身需要消费，该事件将会被拦截，并会在下一步发送到 ViewGroup 自身的 <code>onTouchEvent()</code> 方法中，不会继续向下分发</p>
<p>false 表示不消费，继续向下分发事件</p>
<p>ViewGroup 的放行机制和拦截就结束了，我们继续看代码，下一步该执行事件的分发了</p>
<h3 id="3-事件的分发">3、事件的分发</h3>
<p>如果子视图没有请求放行，ViewGroup 自身也不消费，那么 <code>intercepted</code> 标识为 false ，进入分发流程</p>
<pre><code class="language-java">/frameworks/base/core/java/android/view/ViewGroup.java
class ViewGroup extends View {

    public boolean dispatchTouchEvent(MotionEvent ev) {
        ...
        // 子视图未请求放行，ViewGroup 自身也不消费，进入分发流程
        if (!intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                for (int i = mChildrenCount - 1; i &gt;= 0; i--) {
                    ...// 检查子 View 是否可触摸，是否在触摸区域内等等，过程略
                    // 找到合适的子 View 后，调用 dispatchTransformedTouchEvent() 执行事件分发，如果返回 true，记录本次分发
                    if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                        newTouchTarget = addTouchTarget(child, idBitsToAssign); // 生成一个新的 TouchTarget 对象，用于记录消费的 View
                        break;
                    }
                }
                // 没有新的需要触摸事件的视图，那么，把链表尾部的 TouchTarget 拿出来，在下一步把事件分发给它
                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                }
            }
        }
        return handled;
    }

    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,View child, int desiredPointerIdBits) {
        boolean handled;
        if (child == null) {
            handled = super.dispatchTouchEvent(event); // ViewGroup 继承自 View ，这里调用的是 View#dispatchTouchEvent()
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        return handled;
    }

}
</code></pre>
<p>分发的过程是将所有符合条件的子 View 都询问一遍</p>
<p>在上面这段代码中，使用 <code>for</code> 循环遍历所有的子 View ，检查每个子 View 是否在触摸区域，是否可以被触摸等等</p>
<p>如果找到合适的子 View ，调用 <code>dispatchTransformedTouchEvent()</code> 执行分发，并记录消费的结果</p>
<p>所有的子 View 遍历一遍后，如果发现没有消费的视图，并且，当前 <code>mFirstTouchTarget</code> 不为空，那直接将保留着上一次消费的 View 最近的一个 <code>TouchTarget</code> 拿出来，等待下一步执行</p>
<h3 id="4-事件的消费">4、事件的消费</h3>
<p>事件的消费代码比较简单：</p>
<pre><code class="language-java">/frameworks/base/core/java/android/view/ViewGroup.java
class ViewGroup extends View {

    public boolean dispatchTouchEvent(MotionEvent ev) {
      	...
        // 跑到这，如果 mFirstTouchTarget 还是为空 ，表示这个事件 ViewGroup 自身要消费
        if (mFirstTouchTarget == null) {
            handled = dispatchTransformedTouchEvent(ev,canceled,null,TouchTarget.ALL_POINTER_IDS);
        } else {
            TouchTarget target = mFirstTouchTarget;
            // 遍历 TouchTarget 链表，执行事件分发，代码有去重操作，被我删了，即之前分发过的新添加的节点，不再执行分发
            while (target != null) {
                final TouchTarget next = target.next;
                if (dispatchTransformedTouchEvent(ev, cancelChild,target.child, target.pointerIdBits)) {
                    handled = true;
                }
                target = next;
            }
        }
        return handled;
    }

    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,View child, int desiredPointerIdBits) {
        boolean handled;
        if (child == null) {
            handled = super.dispatchTouchEvent(event); // ViewGroup 继承自 View ，这里调用的是 View#dispatchTouchEvent()
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        return handled;
    }

}
</code></pre>
<p>如果 <code>mFirstTouchTarget</code> 为空 ，表示这个事件 ViewGroup 自身要消费，调用 <code>dispatchTransformedTouchEvent()</code> 方法</p>
<p>在 <code>dispatchTransformedTouchEvent()</code> 方法中，如果 child 参数为空，表示是 ViewGroup 要消费，那么调用 ViewGroup 的父类： <code>View#dispatchTouchEvent()</code></p>
<p><code>dispatchTouchEvent()</code> 方法最终把事件传递给 <code>onTouchEvent()</code> ，我们马上就能看到 View 的消费流程了</p>
<p>如果 <code>mFirstTouchTarget</code> 对象不为空，说明有其他子 View 消费了事件（可能有多个），依旧调用 <code>dispatchTransformedTouchEvent()</code> 执行分发</p>
<p>好了，ViewGroup 的 <code>消费</code>、<code>分发</code>、<code>拦截</code>与<code>放行</code>，到这里就结束了，接下来我们看 <code>View#dispatchTouchEvent()</code> 的流程</p>
<h2 id="view-的消费">View 的消费</h2>
<p>聊完了 ViewGroup 对触摸事件的处理，我们接着来聊 View 这边是怎么处理触摸事件的</p>
<p>在上一节的 <code>dispatchTransformedTouchEvent()</code> 方法中，无论执行的是 <code>super.dispatchTouchEvent(event)</code> 方法，还是 <code>child.dispatchTouchEvent(event)</code> 方法，最终都是调用到 <code>View#dispatchTouchEvent()</code> 中</p>
<p><code>View#dispatchTouchEvent()</code> 逻辑比较少，重要代码只有一句，调用了 <code>onTouchEvent()</code> 消费事件，除此之外 View 的事件分发就没什么好聊的了</p>
<pre><code class="language-java">//frameworks/base/core/java/android/view/View.java
class View {

    public boolean dispatchTouchEvent(MotionEvent event) {
        boolean result = onTouchEvent(event);
        return result;
    }

    public boolean onTouchEvent(MotionEvent event) {
        return false;
    }
}
</code></pre>
<p>好了，View / ViewGroup 的事件分发到这里就结束了，当然我们看到的是非常精简的版本了，只有三两个关键函数，并且几乎没有任何细节</p>
<p>因为 View / ViewGroup 的事件分发比较简单，不像 Framework 的逻辑，绕来绕去的，事件分发的逻辑大部分时间都在内部做跳转，感兴趣的朋友自己去跟一遍源码很快就了解清楚了</p>
<h1 id="四-结语">四、结语</h1>
<p>本篇文章稍微有点长，从硬件驱动，系统内核，到 Framework 都有涉及。其中，了解 IMS 的实现原理，APP 和 IMS 通信的建立，以及 ViewGroup 的 <code>dispatchTouchEvent()</code> 方法的事件派发逻辑，是本篇文章比较重要的内容</p>
<p>在文章的最后，我们用张大伟老师<a href="https://book.douban.com/subject/26598458/">《深入理解Android 卷III》</a>书中的一段话作为本文总结：</p>
<p>简单来说，内核将原始事件写入到设备文件中，InputReader 不断地通过 EventHub 将原始事件取出来，解析加工成 KeyEvent、MotionEvent 事件，然后交给 InputDispatcher</p>
<p>InputDispatcher 根据 WMS 提供的窗口信息将事件交给合适的窗口</p>
<p>接着，窗口的 ViewRootImpl 对象再沿着控件树将事件派发给感兴趣的控件，控件对其收到的事件作出响应，更新自己的画面、执行特定的动作</p>
<p>所有这些参与者以 IMS 为核心，构建了 Android 庞大而复杂的输入体系。</p>
<p>好了，本篇文章到这里就全部结束了。文中提到的硬件驱动和系统内核这两块暂时还不是我擅长的领域，所以如果各位大佬发现本文有写的不对的地方，还望及时指出，我会第一时间改正，感谢</p>
<p>另外，欢迎各位大佬给我留言，我们一起来探讨技术问题</p>
<p><strong>全文完</strong></p>
<h1 id="五-参考资料">五、参考资料</h1>
<ul>
<li><a href="https://book.douban.com/subject/26598458/">《深入理解Android 卷III - 张大伟》</a></li>
<li><a href="https://rohm.eefocus.com/article/id-317">电阻屏已经被智能手机抛弃，还有哪些应用场景？</a></li>
<li><a href="https://blog.csdn.net/weixin_51554164/article/details/124965131">手机全贴合屏幕技术解析</a></li>
<li><a href="https://blog.csdn.net/qq_39797956/article/details/118863217">【Linux驱动】I2C子系统与触摸屏驱动 - @hongZ</a></li>
<li><a href="https://blog.csdn.net/qq_39797956/article/details/117898095">【Linux驱动】input子系统与按键驱动 - @hongZ</a></li>
<li><a href="https://blog.csdn.net/Chuangke_Andy/article/details/122181549">Linux驱动开发|input子系统 - 安迪西</a></li>
<li><a href="https://paper.seebug.org/779/">从 0 开始学 Linux 驱动开发 - Hcamael</a></li>
<li><a href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/">Android(Linux) 输入子系统解析 - Andy Lee</a></li>
<li><a href="https://dqdongg.com/c/touch/android/2014/07/10/Touch-inputevent.html">Android 如何上报 Touchevent 给应用层 - 董刚</a></li>
<li><a href="https://juejin.cn/post/6925336861137174541">这一次，带你彻底弄懂 Android 事件分发机制(外/内层责任链) - 伤心的猪大肠</a></li>
<li><a href="https://www.viseator.com/2017/09/14/android_view_event_1/">Android 触摸事件分发机制（一）从内核到应用 一切的开始 - 吴迪</a></li>
<li><a href="https://www.viseator.com/2017/10/07/android_view_event_2/">Android 触摸事件分发机制（二）原始事件消息传递与分发的开始 - 吴迪</a></li>
<li><a href="https://juejin.cn/post/6920883974952714247">Android事件分发机制二：核心分发逻辑源码解析 - 一只修仙的猿</a></li>
<li><a href="https://xianzhu21.space/developer/inputchannel_inputdispatcher">InputChannel and InputDispatcher in Android</a></li>
</ul>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://yibaoshan.github.io/post/book-notes-computers-microcomputer-8051/" class="post-title gt-a-link">
                    读书笔记：十天学会51单片机
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first"></div>
    <div class="social-container">
        
            
                <a href="https://github.com/yibaoshan" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/yibaoshan?theme=dark" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://yibaoshan.github.io//atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
